<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>kafka核心技术与实战 | 沪指傀儡师</title><meta name="author" content="沪指傀儡师"><meta name="copyright" content="沪指傀儡师"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引论  Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。同时，它也是一个分布式流处理平台（Distributed Streaming Platform）  点击获取《kafka核心技术与实战》 点击获取《Kafka多维度系统精讲，从入门到实战开">
<meta property="og:type" content="article">
<meta property="og:title" content="kafka核心技术与实战">
<meta property="og:url" content="https://hzkls.github.io/posts/717cdc22.html">
<meta property="og:site_name" content="沪指傀儡师">
<meta property="og:description" content="引论  Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。同时，它也是一个分布式流处理平台（Distributed Streaming Platform）  点击获取《kafka核心技术与实战》 点击获取《Kafka多维度系统精讲，从入门到实战开">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/04/30/JI5q8FdjgLk9hyY.jpg">
<meta property="article:published_time" content="2022-02-21T05:18:23.000Z">
<meta property="article:modified_time" content="2022-02-21T05:18:23.000Z">
<meta property="article:author" content="沪指傀儡师">
<meta property="article:tag" content="kafka">
<meta property="article:tag" content="极客时间专栏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/04/30/JI5q8FdjgLk9hyY.jpg"><link rel="shortcut icon" href="/self/img/favicon.png"><link rel="canonical" href="https://hzkls.github.io/posts/717cdc22.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.15/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kafka核心技术与实战',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-21 13:18:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/css/badge.css" /><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/self/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 快速导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Go%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"><i class="fa-fw fa-brands fa-golang"></i><span> Go开发工程师</span></a></li><li><a class="site-page child" href="/categories/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"><i class="fa-fw fa-brands fa-java"></i><span> java面试八股文</span></a></li><li><a class="site-page child" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9B%86%E5%90%88/"><i class="fa-fw fa-solid fa-group-arrows-rotate"></i><span> 中间件集合</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/04/30/JI5q8FdjgLk9hyY.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="沪指傀儡师"><span class="site-name">沪指傀儡师</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-solid fa-paper-plane"></i><span> 快速导航</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/Go%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88/"><i class="fa-fw fa-brands fa-golang"></i><span> Go开发工程师</span></a></li><li><a class="site-page child" href="/categories/java%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/"><i class="fa-fw fa-brands fa-java"></i><span> java面试八股文</span></a></li><li><a class="site-page child" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9B%86%E5%90%88/"><i class="fa-fw fa-solid fa-group-arrows-rotate"></i><span> 中间件集合</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">kafka核心技术与实战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-21T05:18:23.000Z" title="发表于 2022-02-21 13:18:23">2022-02-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-21T05:18:23.000Z" title="更新于 2022-02-21 13:18:23">2022-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9B%86%E5%90%88/">中间件集合</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="kafka核心技术与实战"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="引论">引论</h2>
<blockquote>
<p>Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。<strong>同时，它也是一个分布式流处理平台</strong>（Distributed Streaming Platform）</p>
</blockquote>
<a class="btn-beautify blue inline" href="https://www.aliyundrive.com/s/mZ7xjW5Y46K" 
  title="点击获取《kafka核心技术与实战》" target="_blank"><span>点击获取《kafka核心技术与实战》</span></a>
<a class="btn-beautify purple inline" href="https://www.aliyundrive.com/s/DH6aVAsJiLj" 
  title="点击获取《Kafka多维度系统精讲，从入门到实战开发》" target="_blank"><span>点击获取《Kafka多维度系统精讲，从入门到实战开发》</span></a>
<h2 id="术语">术语</h2>
<h3 id="1-生产者-Producer-、消费者-Consumer-和服务进程Broker">1. 生产者(Producer)、消费者(Consumer)和服务进程Broker</h3>
<ul>
<li>
<p><strong>生产者</strong>：向主题发布消息的客户端应用程序称为<strong>生产者（Producer）</strong>，生产者程序通常持续不断地向一个或多个<strong>主题</strong>发送消息</p>
</li>
<li>
<p><strong>消费者</strong>：订阅这些<strong>主题</strong>消息的客户端应用程序就被称为<strong>消费者（Consumer）</strong></p>
</li>
<li>
<p><strong>服务进程</strong>：Kafka 的服务器端由被称为 <strong>Broker</strong> 的<code>服务进程</code>构成，即一个 Kafka 集群由多个 <strong>Broker</strong> 组成，<strong>Broker</strong> 负责接收和处理客户端发送过来的请求，以及对消息进行<code>持久化</code>。</p>
<div class="note warning flat"><p>虽然多个 <strong><code>Broker</code></strong> 进程能够运行在同一台机器上，但更常见的做法是<strong>将不同的 <code>Broker</code> 分散运行在不同的机器</strong>上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 <strong><code>Broker</code></strong> 进程都挂掉了，其他机器上的 <strong><code>Broker</code></strong> 也依然能够对外提供服务。这其实就是 Kafka 提供 <strong><code>高可用</code></strong> 的手段之一。</p>
</div>
</li>
</ul>
<h3 id="2-副本Replication">2. 副本Replication</h3>
<p>实现高可用的另一个手段就是<code>备份机制（Replication）</code>。备份的思想很简单，就是把<strong>相同的数据</strong>拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为<strong>副本（Replica）</strong>。Kafka 定义了两类副本：<strong>领导者副本（Leader Replica）<strong>和</strong>追随者副本（Follower Replica）</strong>。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，<strong>不能与外界进行交互。</strong></p>
<div class="note warning flat"><p>MySQL的副本是可以对外提供读服务的。但是在 Kafka 中追随者副本不会对外提供服务。</p>
</div>
<p><strong>副本的工作机制</strong>也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。</p>
<h3 id="3-分区（Partitioning）和消息位移（Offset）">3. 分区（Partitioning）和消息位移（Offset）</h3>
<p>有了副本机制可以保证数据的持久化或消息不丢失，但倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳，需要</p>
<p>把数据分割成多份保存在不同的 Broker 上。</p>
<p>Kafka 中的分区机制指的是将每个主题划分成多个<strong>分区（Partition）</strong>，每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。这些位置号也叫<strong>消息位移</strong></p>
<div class="note info flat"><p>可以参考 <strong>MySQL</strong> 中的 <strong>sharding-jdbc</strong> 配置，或者redis的<code>高可用-横向扩容</code></p>
</div>
<h3 id="4-kafka的三层消息结构">4. kafka的三层消息结构</h3>
<ul>
<li>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li>
<li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li>
<li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li>
<li>最后，客户端程序只能与分区的领导者副本进行交互。</li>
</ul>
<h3 id="5-Kafka-Broker-是如何持久化数据的">5. Kafka Broker 是如何持久化数据的</h3>
<p>总的来说，Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。</p>
<ul>
<li>因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段。</li>
<li>在 Kafka 底层，一个日志又近一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。</li>
<li>Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</li>
</ul>
<h3 id="6-消费者位移、消费者组和重平衡">6. 消费者位移、消费者组和重平衡</h3>
<ul>
<li><strong>消费者组</strong>（Consumer Group）：多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。消费者组中，一个分区只会被一个消费者实例消费。</li>
<li><strong>消费者位移</strong>（Consumer Offset）：表征消费者消费进度，每个消费者都有自己的消费者位移。</li>
<li><strong>重平衡</strong>（Rebalance）：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li>
</ul>
<div class="note info flat"><p>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且更酷的是它们还能彼此协助。假设组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者。这个过程就是 Kafka 中大名鼎鼎的“重平衡”（Rebalance）。嗯，其实既是大名鼎鼎，也是臭名昭著，因为由重平衡引发的消费者问题比比皆是。事实上，目前很多重平衡的 Bug 社区都无力解决。</p>
</div>
<h2 id="基本使用">基本使用</h2>
<h3 id="7-操作系统">7. 操作系统</h3>
<p>kafka是属于jvm系的大数据框架，所以可以跨平台部署。但是以<code>linux</code>系统性能为佳。</p>
<ul>
<li>
<p><strong>I/O 模型的使用</strong>：<code>selector</code>在linux中是<strong>epoll</strong>，在windows中的实现机制是<strong>select</strong>。</p>
</li>
<li>
<p><strong>数据网络传输效率</strong>：Kafka 生产和消费的消息都是通过网络传输的，而消息保存在磁盘。故 Kafka 需要在磁盘和网络间进行大量数据传输。Linux 平台实现了这样的零拷贝机制（当数据在磁盘和网络进行传输时避免昂贵的内核态数据拷贝从而实现快速地数据传输）。</p>
<div class="note info flat"><p>主流的 I/O 模型通常有 5 种类型：阻塞式 I/O、非阻塞式 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。每种 I/O 模型都有各自典型的使用场景，比如 Java 中 Socket 对象的阻塞模式和非阻塞模式就对应于前两种模型；而 Linux 中的系统调用 select 函数就属于 I/O 多路复用模型；大名鼎鼎的 epoll 系统调用则介于第三种和第四种模型之间；至于第五种模型，其实很少有 Linux 系统支持，反而是 Windows 系统提供了一个叫 IOCP 线程模型属于这一种。😑redis为啥快？它也是epoll。</p>
</div>
</li>
</ul>
<h3 id="8-磁盘">8. 磁盘</h3>
<p>磁盘类型对于kafka的影响不大，所以机械硬盘物美价廉，最适合kafka。因为kafka的使用方式多是<strong>顺序读写</strong>的，避免了机械硬盘<strong>随机读写数据</strong>的短板。</p>
<blockquote>
<p>关于磁盘选择另一个经常讨论的话题就是到底是否应该使用磁盘阵列（RAID）。使用 RAID 的两个主要优势在于：</p>
<ul>
<li>提供冗余的磁盘存储空间</li>
<li>提供负载均衡</li>
</ul>
<p>不过就 Kafka 而言，一方面 Kafka 自己实现了冗余机制来提供高可靠性；另一方面通过分区的概念，Kafka 也能在软件层面自行实现负载均衡。如此说来 RAID 的优势就没有那么明显了</p>
</blockquote>
<h3 id="9-磁盘容量">9. 磁盘容量</h3>
<p>规划磁盘容量时你需要考虑下面这几个元素：</p>
<ul>
<li>新增消息数</li>
<li>消息留存时间</li>
<li>平均消息大小</li>
<li>备份数</li>
<li>是否启用压缩</li>
</ul>
<h3 id="10-带宽">10. 带宽</h3>
<p>根据实际使用经验，超过 70% 的带宽阈值就有网络丢包的可能性了，故 70% 的设定是一个比较合理的值。这只是它能使用的最大带宽资源，你不能让 Kafka 服务器常规性使用这么多资源，故通常要再额外预留出 2/3 的资源，即47%左右。可以结合你自己机器的使用情况酌情减少此值。</p>
<div class="note info flat"><p>总结一下</p>
<p><img src="https://s2.loli.net/2023/04/30/vDFapAwBehTXNSG.jpg" alt="img"></p>
</div>
<h3 id="11-重要的参数配置">11. 重要的参数配置</h3>
<h4 id="11-1-Broker端参数">11.1. Broker端参数</h4>
<p>针对存储信息的重要参数有以下这么几个</p>
<ul>
<li><strong><code>log.dirs</code></strong>：这是非常重要的参数，指定了 Broker 需要使用的若干个文件目录路径。要知道这个参数是没有默认值的，这说明什么？这说明它必须由你亲自指定。</li>
<li><strong><code>log.dir</code></strong>：注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。</li>
</ul>
<blockquote>
<p>这两个参数只要配置 <code>log.dirs</code>就可以了。在线上生产环境中一定要为<code>log.dirs</code>配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。这样做有两个好处：</p>
<ul>
<li><strong>提升读写性能</strong>：比起单块磁盘，多块物理磁盘同时读写数据有更高的吞吐量。</li>
<li><strong>能够实现故障转移</strong>：即 Failover。这是 Kafka 1.1 版本新引入的强大功能。要知道在以前，只要 Kafka Broker 使用的任何一块磁盘挂掉了，整个 Broker 进程都会关闭。但是自 1.1 开始，这种情况被修正了，坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上，而且 Broker 还能正常工作。这个改进正是我们舍弃 RAID 方案的基础：没有这种 Failover 的话，我们只能依靠 RAID 来提供保障。</li>
</ul>
</blockquote>
<p>下面说说与 <strong>ZooKeeper</strong> 相关的设置。<strong>ZooKeeper</strong>是一个分布式协调框架，负责协调管理并保存 Kafka 集群的所有元数据信息，比如集群都有哪些 Broker 在运行、创建了哪些 Topic，每个 Topic 都有多少分区以及这些分区的 Leader 副本都在哪些机器上等信息。</p>
<ul>
<li><strong><code>zookeeper.connect</code></strong>: Kafka 与 ZooKeeper 相关的最重要的参数当属<code>zookeeper.connect</code>。这也是一个 CSV 格式的参数，比如我可以指定它的值为<code>zk1:2181,zk2:2181,zk3:2181</code>。2181 是 ZooKeeper 的默认端口。多集群可以在后面加 chroot。例如 <code>zk1:2181,zk2:2181,zk3:2181/kafka1</code>和<code>zk1:2181,zk2:2181,zk3:2181/kafka2</code></li>
</ul>
<p>第三组参数是与 Broker 连接相关的，即客户端程序或其他 Broker 如何与该 Broker 进行通信的设置。有以下三个参数：</p>
<ul>
<li><strong><code>listeners</code></strong>：学名叫监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。</li>
<li><strong><code>advertised.listeners</code></strong>：和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。</li>
<li><s><strong><code>host.name/port</code></strong>：列出这两个参数就是想说你把它们忘掉吧，压根不要为它们指定值，毕竟都是过期的参数了。</s></li>
</ul>
<p>第四组参数是关于 Topic 管理的。我来讲讲下面这三个参数：</p>
<ul>
<li><code>auto.create.topics.enable</code>：是否允许自动创建 Topic。建议最好设置成 false，即不允许自动创建 Topic。在我们的线上环境里面有很多名字稀奇古怪的 Topic，我想大概都是因为该参数被设置成了 true 的缘故。</li>
<li><code>unclean.leader.election.enable</code>：是否允许 Unclean Leader 选举。如果设置成 false，则选举保存数据最多的副本为leader。反之，允许从保存数据少的副本中选举leader，这样会丢失更多的数据。</li>
<li><code>auto.leader.rebalance.enable</code>：是否允许定期进行 Leader 选举。设置它的值为 true 表示允许 Kafka 定期地对一些 Topic 分区进行 Leader 重选举，当然这个重选举不是无脑进行的，它要满足一定的条件才会发生。严格来说它与上一个参数中 Leader 选举的最大不同在于，它不是选 Leader，而是换 Leader！换一次leader成本很高，所以建议设置为false</li>
</ul>
<p>最后一组参数是数据留存方面的，即：</p>
<ul>
<li>
<p><code>log.retention.&#123;hour|minutes|ms&#125;</code>：这是个“三兄弟”，都是控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hour 最低。</p>
<div class="note info flat"><p>虽然 ms 设置有最高的优先级，但是通常情况下我们还是设置 hour 级别的多一些，比如<code>log.retention.hour=168</code>表示默认保存 7 天的数据，自动删除 7 天前的数据。很多公司把 Kafka 当做存储来使用，那么这个值就要相应地调大。</p>
</div>
</li>
<li>
<p><code>log.retention.bytes</code>：这是指定 Broker 为消息保存的总磁盘容量大小。这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以。</p>
</li>
<li>
<p><code>message.max.bytes</code>：控制 Broker 能够接收的最大消息大小。默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，因此在线上环境中设置一个比较大的值还是比较保险的做法。</p>
</li>
</ul>
<h4 id="11-2-Topic级别的参数配置">11.2. Topic级别的参数配置</h4>
<p>如果同时设置了 Topic 级别参数和全局 Broker 参数，Topic级别参数会覆盖Broker的参数。</p>
<p>保存消息相关的参数：</p>
<ul>
<li><strong><code>retention.ms</code></strong>：规定了该 Topic 消息被保存的时长。默认是 7 天，即该 Topic 只保存最近 7 天的消息。一旦设置了这个值，它会覆盖掉 Broker 端的全局参数值。</li>
<li><strong><code>retention.bytes</code></strong>：规定了要为该 Topic 预留多大的磁盘空间。和全局参数作用相似，这个值通常在多租户的 Kafka 集群中会有用武之地。当前默认值是 -1，表示可以无限使用磁盘空间。</li>
</ul>
<h4 id="11-3-JVM参数">11.3. JVM参数</h4>
<p>设置的方法也很简单，你只需要设置下面这两个环境变量即可：</p>
<ul>
<li><code>KAFKA_HEAP_OPTS</code>：指定堆大小。</li>
<li><code>KAFKA_JVM_PERFORMANCE_OPTS</code>：指定 GC 参数。</li>
</ul>
<h2 id="实践及原理剖析">实践及原理剖析</h2>
<h3 id="12-生产者消息分区机制原理">12. 生产者消息分区机制原理</h3>
<p>分区的作用就是提供负载均衡的能力，或者说对数据进行分区的主要原因，就是为了实现系统的<strong>高伸缩性</strong>（Scalability）。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来<em>增加整体系统的吞吐量</em>。</p>
<p>所谓<strong>分区策略</strong>是<strong>决定生产者将消息发送到哪个分区的算法</strong>。Kafka 为我们提供了默认的分区策略，同时它也支持你自定义分区策略。</p>
<p>如果要自定义分区策略，你需要显式地配置生产者端的参数<code>partitioner.class</code>。这个参数该怎么设定呢？方法很简单，在编写生产者程序时，你可以编写一个具体的类实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口。这个接口也很简单，只定义了两个方法：<code>partition()</code>和<code>close()</code>，通常你只需要实现最重要的 partition 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span>;</span><br></pre></td></tr></table></figure>
<p>这里的<code>topic</code>、<code>key</code>、<code>keyBytes</code>、<code>value</code>和<code>valueBytes</code>都属于消息数据，<code>cluster</code>则是集群信息（比如当前 Kafka 集群共有多少主题、多少 Broker 等）。Kafka 给你这么多信息，就是希望让你能够充分地利用这些信息对消息进行分区，计算出它要被发送到哪个分区中。只要你自己的实现类定义好了 partition 方法，同时设置<code>partitioner.class</code>参数为你自己实现类的 Full Qualified Name，那么生产者程序就会按照你的代码逻辑对消息进行分区。</p>
<p>比较常见的分区策略也就那么几种:</p>
<h4 id="轮询策略">轮询策略</h4>
<p>也称 Round-robin 策略，即顺序分配。比如一个主题下有 3 个分区，那么第一条消息被发送到分区 0，第二条被发送到分区 1，第三条被发送到分区 2，以此类推。当生产第 4 条消息时又会重新开始，即将其分配到分区 0，就像下面这张图展示的那样。</p>
<p><img src="https://s2.loli.net/2023/04/30/RrkAXP2MWDJe3qB.png" alt="kafka分区策略_轮询策略"></p>
<p>这就是所谓的轮询策略。轮询策略是 Kafka Java 生产者 API 默认提供的分区策略。如果你未指定<code>partitioner.class</code>参数，那么你的生产者程序会按照轮询的方式在主题的所有分区间均匀地“码放”消息。</p>
<div class="note info flat"><p>轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们最常用的分区策略之一。</p>
</div>
<h4 id="随机策略">随机策略</h4>
<p>也称 Randomness 策略。所谓随机就是我们随意地将消息放置到任意一个分区上，如下面这张图所示。</p>
<p><img src="https://s2.loli.net/2023/04/30/rxLQm1z7boascpe.png" alt="kafka分区策略_随机策略"></p>
<p>如果要实现随机策略版的 partition 方法，很简单，只需要两行代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure>
<p>先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。</p>
<p>本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以<strong>如果追求数据的均匀分布，还是使用轮询策略比较好</strong>。事实上，随机策略是老版本生产者使用的分区策略，在新版本中已经改为轮询了。</p>
<h4 id="Key-ordering-策略">Key-ordering 策略</h4>
<p>Kafka 允许为每条消息定义消息键，简称为 Key。这个 Key 的作用非常大，它可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务 ID 等；也可以用来表征消息元数据。特别是在 Kafka 不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进 Key 里面的。一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略。</p>
<p><img src="https://s2.loli.net/2023/04/30/1LFAUwKk75yZrsP.png" alt="kafka分区策略_Key-Ordering策略"></p>
<p>代码实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure>
<h3 id="13-生产者压缩算法">13. 生产者压缩算法</h3>
<h4 id="何时压缩？">何时压缩？</h4>
<p>压缩可能发生在 <strong>生产者</strong> 和 <strong>Broker</strong> 端。</p>
<p>生产者程序中配置 <code>compression.type</code> 参数即表示启用指定类型的压缩算法，如 <code>GZIP</code>等。</p>
<p><strong>Broker</strong> 端也有这个参数。如果 <strong>生产者</strong> 和 <strong>Broker</strong> 端两个参数不一致，那么就会有个消息解压和重新压缩的过程。</p>
<p>其实大部分情况下 Broker 从 Producer 端接收到消息后仅仅是原封不动地保存而不会对其进行任何修改，但这里的“大部分情况”也是要满足一定条件的。有两种例外情况就可能让 Broker 重新压缩消息。</p>
<ul>
<li><strong>Broker端指定了和 Producer 端不同的压缩算法</strong>。一旦你在 Broker 端设置了不同的 compression.type 值，就一定要小心了，因为可能会发生预料之外的压缩 / 解压缩操作，通常表现为 Broker 端 CPU 使用率飙升。</li>
<li><strong>Broker端发生了消息格式转换</strong>。消息格式转换主要是为了兼容老版本的消费者程序。Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩。一般情况下这种消息格式转换对性能是有很大影响的，除了这里的压缩之外，它还让 Kafka 丧失了引以为豪的 <strong>Zero Copy</strong> 特性。</li>
</ul>
<h4 id="何时解压？">何时解压？</h4>
<p>Producer 发送压缩消息到 Broker 后，Broker 照单全收并原样保存起来。当 Consumer 程序请求这部分消息时，Broker 依然原样发送出去，当消息到达 Consumer 端后，由 Consumer 自行解压缩还原成之前的消息。Kafka 会将启用了哪种压缩算法封装进消息集合中，这样当 Consumer 读取到消息集合时，它自然就知道了这些消息使用的是哪种压缩算法。如果用一句话总结一下压缩和解压缩，那么我希望你记住这句话：<strong>Producer 端压缩、Broker 端保持、Consumer 端解压缩。</strong></p>
<h4 id="各种压缩算法的对比">各种压缩算法的对比</h4>
<p>下面这张表是 Facebook Zstandard 官网提供的一份压缩算法 benchmark 比较结果：</p>
<p><img src="https://s2.loli.net/2023/04/30/ikzP8VeyqoIACKh.png" alt="kafka压缩算法"></p>
<p>在实际使用中，GZIP、Snappy、LZ4 甚至是 zstd 的表现各有千秋。</p>
<ul>
<li>吞吐量方面：LZ4 &gt; Snappy &gt; zstd 和 GZIP；</li>
<li>在压缩比方面，zstd &gt; LZ4 &gt; GZIP &gt; Snappy；</li>
<li>具体到物理资源，使用 Snappy 算法占用的网络带宽最多，zstd 最少，这是合理的，毕竟 zstd 就是要提供超高的压缩比；在 CPU 使用率方面，各个算法表现得差不多，只是在压缩时 Snappy 算法使用的 CPU 较多一些，而在解压缩时 GZIP 算法则可能使用更多的 CPU。</li>
</ul>
<h3 id="14-无消息丢失配置">14. 无消息丢失配置</h3>
<div class="note danger flat"><p>这块面试很经常会问！</p>
</div>
<p>Kafka 到底在什么情况下才能保证消息不丢失呢？</p>
<p><strong>一句话概括，Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证。</strong></p>
<ul>
<li>
<p><strong>已提交的消息</strong>：当 Kafka 的若干个 Broker 成功地接收到一条消息并写入到日志文件后，它们会告诉生产者程序这条消息已成功提交。此时，这条消息在 Kafka 看来就正式变为“已提交”消息了。</p>
</li>
<li>
<p><strong>有限度的持久化保证</strong>：假如你的消息保存在 N 个 Kafka Broker 上，那么这个前提条件就是这 N 个 Broker 中至少有 1 个存活。只要这个条件成立，Kafka 就能保证你的这条消息永远不会丢失。</p>
</li>
</ul>
<h4 id="“消息丢失”案例">“消息丢失”案例</h4>
<p><strong>案例 1：生产者程序丢失数据</strong></p>
<p>Producer 程序丢失消息，这应该算是被抱怨最多的数据丢失场景了。我来描述一个场景：你写了一个 Producer 应用向 Kafka 发送消息，最后发现 Kafka 没有保存，于是大骂：“Kafka 真烂，消息发送居然都能丢失，而且还不告诉我？！”如果你有过这样的经历，那么请先消消气，我们来分析下可能的原因。</p>
<p>目前 Kafka Producer 是异步发送消息的，也就是说如果你调用的是 producer.send(msg) 这个 API，那么它通常会立即返回，但此时你不能认为消息发送已成功完成。</p>
<p>这种发送方式有个有趣的名字，叫“fire and forget”，翻译一下就是“发射后不管”。这个术语原本属于导弹制导领域，后来被借鉴到计算机领域中，它的意思是，执行完一个操作后不去管它的结果是否成功。调用 producer.send(msg) 就属于典型的“fire and forget”，因此如果出现消息丢失，我们是无法知晓的。这个发送方式挺不靠谱吧，不过有些公司真的就是在使用这个 API 发送消息。</p>
<p>如果用这个方式，可能会有哪些因素导致消息没有发送成功呢？其实原因有很多，例如网络抖动，导致消息压根就没有发送到 Broker 端；或者消息本身不合格导致 Broker 拒绝接收（比如消息太大了，超过了 Broker 的承受能力）等。这么来看，让 Kafka“背锅”就有点冤枉它了。就像前面说过的，Kafka 不认为消息是已提交的，因此也就没有 Kafka 丢失消息这一说了。</p>
<p>不过，就算不是 Kafka 的“锅”，我们也要解决这个问题吧。实际上，解决此问题的方法非常简单：<strong>Producer 永远要使用带有回调通知的发送 API，也就是说不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)</strong>。不要小瞧这里的 callback（回调），它能准确地告诉你消息是否真的提交成功了。一旦出现消息提交失败的情况，你就可以有针对性地进行处理。</p>
<p>举例来说，如果是因为那些瞬时错误，那么仅仅让 Producer 重试就可以了；如果是消息不合格造成的，那么可以调整消息格式后再次发送。总之，处理发送失败的责任在 Producer 端而非 Broker 端。</p>
<p>你可能会问，发送失败真的没可能是由 Broker 端的问题造成的吗？当然可能！如果你所有的 Broker 都宕机了，那么无论 Producer 端怎么重试都会失败的，此时你要做的是赶快处理 Broker 端的问题。但之前说的核心论据在这里依然是成立的：Kafka 依然不认为这条消息属于已提交消息，故对它不做任何持久化保证。</p>
<p><strong>案例 2：消费者程序丢失数据</strong></p>
<p>Consumer 端丢失数据主要体现在 Consumer 端要消费的消息不见了。Consumer 程序有个“位移”的概念，表示的是这个 Consumer 当前消费到的 Topic 分区的位置。下面这张图来自于官网，它清晰地展示了 Consumer 端的位移数据。</p>
<p><img src="https://s2.loli.net/2023/04/30/CpbSEvPWNj3Fmsw.png" alt="kafka消息丢失案例_消费者程序丢失数据"></p>
<p>比如对于 Consumer A 而言，它当前的位移值就是 9；Consumer B 的位移值是 11。</p>
<p>这里的“位移”类似于我们看书时使用的书签，它会标记我们当前阅读了多少页，下次翻书的时候我们能直接跳到书签页继续阅读。</p>
<p>正确使用书签有两个步骤：第一步是读书，第二步是更新书签页。如果这两步的顺序颠倒了，就可能出现这样的场景：当前的书签页是第 90 页，我先将书签放到第 100 页上，之后开始读书。当阅读到第 95 页时，我临时有事中止了阅读。那么问题来了，当我下次直接跳到书签页阅读时，我就丢失了第 96～99 页的内容，即这些消息就丢失了。</p>
<p>同理，Kafka 中 Consumer 端的消息丢失就是这么一回事。要对抗这种消息丢失，办法很简单：<strong>维持先消费消息（阅读），再更新位移（书签）的顺序</strong>即可。这样就能最大限度地保证消息不丢失。</p>
<p>当然，这种处理方式可能带来的问题是消息的重复处理，类似于同一页书被读了很多遍，但这不属于消息丢失的情形。</p>
<p><strong>案例3：多线程场景位移更新但是处理失败</strong></p>
<p>除了上面所说的场景，其实还存在一种比较隐蔽的消息丢失场景。</p>
<p>我们依然以看书为例。假设你花钱从网上租借了一本共有 10 章内容的电子书，该电子书的有效阅读时间是 1 天，过期后该电子书就无法打开，但如果在 1 天之内你完成阅读就退还租金。</p>
<p>为了加快阅读速度，你把书中的 10 个章节分别委托给你的 10 个朋友，请他们帮你阅读，并拜托他们告诉你主旨大意。当电子书临近过期时，这 10 个人告诉你说他们读完了自己所负责的那个章节的内容，于是你放心地把该书还了回去。不料，在这 10 个人向你描述主旨大意时，你突然发现有一个人对你撒了谎，他并没有看完他负责的那个章节。那么很显然，你无法知道那一章的内容了。</p>
<p>对于 Kafka 而言，这就好比 Consumer 程序从 Kafka 获取到消息后开启了多个线程异步处理消息，而 Consumer 程序自动地向前更新位移。假如其中某个线程运行失败了，它负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于 Consumer 而言实际上是丢失了。</p>
<p>这里的关键在于 Consumer 自动提交位移，与你没有确认书籍内容被全部读完就将书归还类似，你没有真正地确认消息是否真的被消费就“盲目”地更新了位移。</p>
<p>这个问题的解决方案也很简单：<strong>如果是多线程异步处理消费消息，Consumer 程序不要开启自动提交位移，而是要应用程序手动提交位移</strong>。在这里我要提醒你一下，单个 Consumer 程序使用多线程来消费消息说起来容易，写成代码却异常困难，因为你很难正确地处理位移的更新，<code>也就是说避免无消费消息丢失很简单，但极易出现消息被消费了多次的情况。</code></p>
<h4 id="最佳实践">最佳实践</h4>
<ol>
<li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。</li>
<li>设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li>
<li>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li>
<li>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li>
<li>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li>
<li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li>
<li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</li>
<li>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li>
</ol>
<h3 id="15-不常用但是高级的功能——客户端的拦截器">15. 不常用但是高级的功能——客户端的拦截器</h3>
<p>客户端的拦截器设计思想可以参考spring的拦截器。主要有两类：</p>
<ul>
<li>
<p><code>org.apache.kafka.clients.producer.ProducerInterceptor</code>的子类（继承）。ProducerInterceptor主要是两个方法：</p>
<ul>
<li>
<p><code>onSend</code>：发送之前执行</p>
</li>
<li>
<p><code>onAcknowladgement</code>：该方法会在消息成功提交或发送失败之后被调用，并且比callback先执行。</p>
<div class="note danger flat"><p>值得注意的是，这个方法和 onSend 不是在同一个线程中被调用的，因此如果你在这两个方法中调用了某个共享可变对象，一定要保证线程安全哦。还有一点很重要，这个方法处在 Producer 发送的主路径中，所以最好别放一些太重的逻辑进去，否则你会发现你的 Producer TPS 直线下降。</p>
</div>
</li>
</ul>
</li>
<li>
<p><code>org.apache.kafka.clients.consumer.ConsumerInterceptor</code>的实现类（接口实现）</p>
<ul>
<li><code>onConsume</code>：该方法在消息返回给 Consumer 程序之前调用</li>
<li><code>onCommit</code>：Consumer 在提交位移之后调用该方法。通常你可以在该方法中做一些记账类的动作，比如打日志等。</li>
</ul>
</li>
</ul>
<p>写好代码后，将 <strong>全限定名</strong> 添加到kafka的配置中。<strong>Kafka 拦截器可以应用于包括客户端监控、端到端系统性能检测、消息审计等多种功能在内的场景</strong>。</p>
<h3 id="16-Producer的TCP连接">16. Producer的TCP连接</h3>
<ul>
<li>
<p>何时创建？</p>
<div class="note info flat"><p>在 <code>KafkaProducer</code> 实例化的同时，创建了 <code>KafkaProducer.Sender</code>实例 <strong>sender</strong>，然后 <strong>sender</strong> 与 <strong>Broker</strong> 进行TCP连接</p>
</div>
</li>
<li>
<p>何时关闭？</p>
<div class="note info flat"><p>两种情况下会关闭：</p>
<ul>
<li>用户显式调用了close方法</li>
<li>超过配置的最大超时时间 <code>connections.max.idle.ms</code>（默认值为9分钟）没有数据流过</li>
</ul>
</div>
</li>
</ul>
<div class="note danger modern"><p>后续内容可以下载专栏自己看，主要是消费者的生产实践经验。</p>
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hzkls.github.io">沪指傀儡师</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hzkls.github.io/posts/717cdc22.html">https://hzkls.github.io/posts/717cdc22.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hzkls.github.io" target="_blank">沪指傀儡师</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kafka/">kafka</a><a class="post-meta__tags" href="/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E4%B8%93%E6%A0%8F/">极客时间专栏</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/04/30/JI5q8FdjgLk9hyY.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/ab05b615.html" title="HashMap精选13问"><img class="cover" src="https://s2.loli.net/2023/05/09/qRDBZQuSOdhnHU1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HashMap精选13问</div></div></a></div><div class="next-post pull-right"><a href="/posts/ea4e979e.html" title="23种设计模式"><img class="cover" src="https://s2.loli.net/2023/05/09/gtd4hzO6FN1D8HT.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">23种设计模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/80596e28.html" title="kafka篇"><img class="cover" src="https://s2.loli.net/2023/05/09/MESRB4gp1CVsKAm.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">kafka篇</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/self/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">沪指傀儡师</div><div class="author-info__description">迷茫的肥仔︿(￣︶￣)︿</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/hzkls"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA"><span class="toc-text">引论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%9F%E4%BA%A7%E8%80%85-Producer-%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85-Consumer-%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8BBroker"><span class="toc-text">1. 生产者(Producer)、消费者(Consumer)和服务进程Broker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%89%AF%E6%9C%ACReplication"><span class="toc-text">2. 副本Replication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E5%8C%BA%EF%BC%88Partitioning%EF%BC%89%E5%92%8C%E6%B6%88%E6%81%AF%E4%BD%8D%E7%A7%BB%EF%BC%88Offset%EF%BC%89"><span class="toc-text">3. 分区（Partitioning）和消息位移（Offset）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-kafka%E7%9A%84%E4%B8%89%E5%B1%82%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84"><span class="toc-text">4. kafka的三层消息结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Kafka-Broker-%E6%98%AF%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-text">5. Kafka Broker 是如何持久化数据的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B6%88%E8%B4%B9%E8%80%85%E4%BD%8D%E7%A7%BB%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E5%92%8C%E9%87%8D%E5%B9%B3%E8%A1%A1"><span class="toc-text">6. 消费者位移、消费者组和重平衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">7. 操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%A3%81%E7%9B%98"><span class="toc-text">8. 磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="toc-text">9. 磁盘容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%B8%A6%E5%AE%BD"><span class="toc-text">10. 带宽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-text">11. 重要的参数配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-Broker%E7%AB%AF%E5%8F%82%E6%95%B0"><span class="toc-text">11.1. Broker端参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-Topic%E7%BA%A7%E5%88%AB%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-text">11.2. Topic级别的参数配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-JVM%E5%8F%82%E6%95%B0"><span class="toc-text">11.3. JVM参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E5%8F%8A%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-text">实践及原理剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E5%88%86%E5%8C%BA%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">12. 生产者消息分区机制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E7%AD%96%E7%95%A5"><span class="toc-text">轮询策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%AD%96%E7%95%A5"><span class="toc-text">随机策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Key-ordering-%E7%AD%96%E7%95%A5"><span class="toc-text">Key-ordering 策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%94%9F%E4%BA%A7%E8%80%85%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-text">13. 生产者压缩算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%8E%8B%E7%BC%A9%EF%BC%9F"><span class="toc-text">何时压缩？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%A7%A3%E5%8E%8B%EF%BC%9F"><span class="toc-text">何时解压？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">各种压缩算法的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%85%8D%E7%BD%AE"><span class="toc-text">14. 无消息丢失配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E2%80%9D%E6%A1%88%E4%BE%8B"><span class="toc-text">“消息丢失”案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%B8%8D%E5%B8%B8%E7%94%A8%E4%BD%86%E6%98%AF%E9%AB%98%E7%BA%A7%E7%9A%84%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">15. 不常用但是高级的功能——客户端的拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Producer%E7%9A%84TCP%E8%BF%9E%E6%8E%A5"><span class="toc-text">16. Producer的TCP连接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/8ce5b1c.html" title="RocketMq5.X笔记"><img src="https://s2.loli.net/2023/07/04/sQlMNUfeti2uaXz.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMq5.X笔记"/></a><div class="content"><a class="title" href="/posts/8ce5b1c.html" title="RocketMq5.X笔记">RocketMq5.X笔记</a><time datetime="2023-05-01T06:25:05.000Z" title="发表于 2023-05-01 14:25:05">2023-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/491079987.html" title="Golang编程思想2-函数式编程"><img src="https://p2.itc.cn/q_70/images03/20210217/f2e520a8a4014112ab51a454d1bcef52.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang编程思想2-函数式编程"/></a><div class="content"><a class="title" href="/posts/491079987.html" title="Golang编程思想2-函数式编程">Golang编程思想2-函数式编程</a><time datetime="2022-07-25T14:42:59.000Z" title="发表于 2022-07-25 22:42:59">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2854471435.html" title="Golang编程思想（一）——面向接口"><img src="http://www.obzhi.com/wp-content/uploads/2022/03/guyin-scaled.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang编程思想（一）——面向接口"/></a><div class="content"><a class="title" href="/posts/2854471435.html" title="Golang编程思想（一）——面向接口">Golang编程思想（一）——面向接口</a><time datetime="2022-07-03T14:05:05.000Z" title="发表于 2022-07-03 22:05:05">2022-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3459106423.html" title="Golang基础入门(四)——面向对象"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20181030%2F70f9a2f694284c20b6546de01ae276e1.jpeg&amp;refer=http%3A%2F%2F5b0988e595225.cdn.sohucs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1658243109&amp;t=3ebae6d0b19c32b74397227d0da69d28" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang基础入门(四)——面向对象"/></a><div class="content"><a class="title" href="/posts/3459106423.html" title="Golang基础入门(四)——面向对象">Golang基础入门(四)——面向对象</a><time datetime="2022-06-19T15:01:14.000Z" title="发表于 2022-06-19 23:01:14">2022-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1108898725.html" title="Golang基础入门(三)——内建容器"><img src="https://img1.baidu.com/it/u=3928911048,3831610104&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=1200&amp;h=500" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Golang基础入门(三)——内建容器"/></a><div class="content"><a class="title" href="/posts/1108898725.html" title="Golang基础入门(三)——内建容器">Golang基础入门(三)——内建容器</a><time datetime="2022-06-06T14:14:10.000Z" title="发表于 2022-06-06 22:14:10">2022-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">回宅快落水</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.15/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '948919f243bbcee33e45',
      clientSecret: '7d84fd0741584ee8da9edb1ee68d5bfb35ee28e3',
      repo: 'hzkls.github.io',
      owner: 'hzkls',
      admin: ['hzkls'],
      id: '10e0ec31abe25dcef4d40d36b50dda18',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.css')
    getScript('https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const findTrueUrl = (array) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        const urlArray = data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig)
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        saveToLocal.set('github-newest-comments', JSON.stringify(array), 10/(60*24))
        generateHtml(array)
    });
  }

  const getComment = () => {
    fetch('https://api.github.com/repos/hzkls/hzkls.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at,
            'githubUrl': item.html_url
          }
        })
        findTrueUrl(githubArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('github-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>