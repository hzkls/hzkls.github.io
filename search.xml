<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RocketMq5.X笔记(百里)</title>
      <link href="/posts/97f52e5d.html"/>
      <url>/posts/97f52e5d.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>最近RocketMq出了5.X的版本，多了一个proxy的模型，过渡到用grpc的协议，补全支持开发语言少的短板，但是这套视频没有讲proxy，可以自己去官网看一下，就是用新的sdk，但是提供的api少了挺多的。</p><p>这是我看B站视频做的笔记。</p><p><a class="btn-beautify blue inline line" href="https://www.bilibili.com/video/BV1tM4y1t7GE"   title="RocketMq5.X教程" target="_blank"><i class="fa-brands fa-bilibili"></i><span>RocketMq5.X教程</span></a></p></div><h2 id="1-RocketMQ介绍">1. RocketMQ介绍</h2><p>RocketMQ是一款由阿里巴巴开源的分布式消息中间件。它具有低延迟、高吞吐量、高可用性和高可靠性等特点，适用于构建具有海量消息堆积和异步解耦功能的应用系统。</p><h3 id="基本概念">基本概念</h3><ul><li><strong>生产者（Producer）</strong>：也称为消息发布者，是RocketMQ中用来构建并传输消息到服务端的运行实体。</li><li><strong>主题（Topic）</strong>：Topic是RocketMQ中消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息；Topic是一个逻辑概念，并不是实际的消息容器；</li><li><strong>消息队列（MessageQueue）</strong>：队列是RocketMQ中消息存储和传输的实际容器，也是消息的最小存储单元。</li><li><strong>消费者（Consumer）</strong>：也称为消息订阅者，是RocketMQ中用来接收并处理消息的运行实体。</li><li><strong>消费者组（ConsumerGroup）</strong>：消费者组是RocketMQ中承载多个消费行为一致的消费者负载均衡分组。和消费者不同，消费者组是一个逻辑概念。</li><li><strong>NameServer</strong>：可以理解成注册中心，负责更新和发现Broker服务。在NameServer的集群中，NameServer与NameServer之间是没有任何通信的，它是无状态的。</li><li><strong>Broker</strong>：可以理解为消息中转角色，负责消息的存储和转发，接收生产者产生的消息并持久化消息；当用户发送的消息被发送到Broker时，Broker会将消息转发到与之关联的Topic中，以便让更多的接收者进行处理。</li></ul><h3 id="消息模型">消息模型</h3><p><img src="https://s2.loli.net/2023/07/04/murHVq568n7A3UX.png" alt="rocketmq5.x 消息模型"></p><h3 id="部署模型">部署模型</h3><p><img src="https://s2.loli.net/2023/07/04/wJ3H2fb8dSVvYWq.png" alt="img"></p><h2 id="2-下载RocketMQ">2.下载RocketMQ</h2><p>RocketMQ的官网地址：<a href="https://rocketmq.apache.org/">https://rocketmq.apache.org/</a></p><p>Github地址：<a href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></p><p>下载地址：<a href="https://rocketmq.apache.org/zh/download/">https://rocketmq.apache.org/zh/download/</a></p><p>当前最新的版本为5.1.0，本教程安装5.1.0版本。</p><h2 id="3-安装RocketMQ">3.安装RocketMQ</h2><h3 id="3-1-安装前需要准备一个CentOS7的Linux机器，使用的Linux版本如下：">3.1.安装前需要准备一个CentOS7的Linux机器，使用的Linux版本如下：</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># uname -a</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/yikr9vx6sn428Mt.png" alt="img"></p><h3 id="3-2-安装JDK">3.2.安装JDK</h3><p>推荐使用JDK1.8版本。</p><h4 id="1-统一规划目录，创建app文件夹，在创建jdk文件夹，将jdk的包上载到-app-jdk目录下然后解压">1.统一规划目录，创建app文件夹，在创建jdk文件夹，将jdk的包上载到 /app/jdk目录下然后解压</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> /]<span class="comment"># cd ..</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> /]<span class="comment"># mkdir app</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> /]<span class="comment"># cd app/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># mkdir jdk</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># cd jdk/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">jdk</span>]<span class="comment"># tar -zxvf jdk-8u171-linux-x64.tar.gz</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/9HAwgkpQZuiYyMJ.png" alt="img"></p><h4 id="2-配置jdk环境变量，将JAVA-HOME变量加上-将path路径替换成相应配置">2.配置jdk环境变量，将JAVA_HOME变量加上;将path路径替换成相应配置</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">jdk</span>]<span class="comment"># vi /etc/profile</span></span><br><span class="line"><span class="comment">#jdk解压后的目录路径</span></span><br><span class="line">export JAVA_HOME=/app/jdk/jdk1.<span class="number">8.0</span>_171/  </span><br><span class="line">PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH:</span><span class="variable">$HOME</span>/.local/bin:<span class="variable">$HOME</span>/bin</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/OJfFjBrwxItMUsm.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/8EpNKw2lk6Fo3i1.png" alt="img"></p><h4 id="3-更新配置并查看jdk版本，显示以下信息则安装成功。">3.更新配置并查看jdk版本，显示以下信息则安装成功。</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">jdk</span>]<span class="comment"># source /etc/profile</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">jdk</span>]<span class="comment"># java -version</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/qgejBipakQU394L.png" alt="img"></p><h3 id="3-3-安装RocketMQ">3.3.安装RocketMQ</h3><h4 id="3-3-1-将安装包上载到-app-rocketMQ目录下">3.3.1.将安装包上载到 /app/rocketMQ目录下</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先在app目录下创建rocketMQ文件夹</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">jdk</span>]<span class="comment"># cd ..</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># mkdir rocketMQ</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将bin上载到/app/rocketMQ目录然后解压（也可以先解压在上载，推荐先上载后解压）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># cd rocketMQ/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketMQ</span>]<span class="comment"># unzip rocketmq-all-5.1.0-bin-release.zip</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/aixCeq1ZldW6KQu.png" alt="img"></p><h4 id="3-3-2-配置rocketMQ环境变量">3.3.2.配置rocketMQ环境变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将ROCKETMQ_HOME变量加上，在path路径加上$ROCKETMQ_HOME/bin:</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketMQ</span>]<span class="comment"># vi /etc/profile</span></span><br><span class="line"><span class="comment">#rocketMQ路径</span></span><br><span class="line">export ROCKETMQ_HOME=/app/rocketMQ/rocketmq<span class="literal">-all-5</span>.<span class="number">1.0</span><span class="literal">-bin-release</span></span><br><span class="line">export PATH=<span class="variable">$ROCKETMQ_HOME</span>/bin:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH:</span><span class="variable">$HOME</span>/.local/bin:<span class="variable">$HOME</span>/bin</span><br><span class="line"><span class="comment">#namesrv后续broker会使用到,先加上</span></span><br><span class="line">export NAMESRV_ADDR=<span class="string">&#x27;worker1:9876;worker2:9876;worker3:9876&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/gu2UixL6bprC4hR.png" alt="img"></p><h4 id="3-3-3-更新配置">3.3.3.更新配置</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketMQ</span>]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure><p>ROCKETMQ_HOME的环境变量是必须要单独配置的，如果不配置的话，启动NameSever和Broker都会报错。这个环境变量的作用是用来加载$ROCKETMQ_HOME/conf下的除broker.conf以外的几个配置文件。所以实际情况中，可以不按这个配置，但是一定要能找到配置文件。这样RocketMQ就安装完成了。</p><h3 id="3-4-RocketMQ工作原理">3.4.RocketMQ工作原理</h3><p>官网5.0版本速览链接：<a href="https://rocketmq.apache.org/zh/version/">https://rocketmq.apache.org/zh/version/</a></p><p>RocketMQ5.0 引入了全新的弹性无状态代理模式，将当前的Broker职责进行拆分，对于客户端协议适配、权限管理、消费管理等计算逻辑进行抽离，独立无状态的代理角色提供服务，Broker则继续专注于存储能力的持续优化。值得注意的是RocketMQ 5.0的全新模式是和4.0的极简架构模式相容相通的，5.0的代理架构完全可以以Local模式运行，实现与4.0架构完全一致的效果。开发者可以根据自身的业务场景自由选择架构部署，本教程也是部署的Local模式。</p><p>RocketMQ启动流程如下：</p><ul><li>启动NameServer</li><li>启动Broker</li></ul><p><img src="https://s2.loli.net/2023/07/04/N4wYnhZJ53DzEfb.png" alt="img"></p><h3 id="3-5-NameServer服务搭建">3.5.NameServer服务搭建</h3><p>启动NameServer非常简单，在$ROCKETMQ_HOME/bin目录下有个mqnamesrv。直接执行这个脚本就可以启动RocketMQ的NameServer服务。</p><p>由于RocketMQ默认预设的JVM内存是4G，这是RocketMQ给我们的最佳配置。但是通常我们用虚拟机的话都是不够4G内存的，所以需要调整下JVM内存</p><p>大小。<a href="http://xn--runserver-z89na9857bcqmtlfda85rmzcf95l5zb.sh">修改的方式是直接修改runserver.sh</a>。</p><h4 id="3-5-1-修改NameServer启动配置">3.5.1.修改NameServer启动配置</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketMQ</span>]<span class="comment"># cd rocketmq-all-5.1.0-bin-release/bin/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># vi runserver.sh</span></span><br><span class="line"><span class="comment">#将JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g 修改为 -server -Xms512m -Xmx512m -Xmn256m</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/CJMtequZ2yQ4AaI.png" alt="img"></p><h4 id="3-5-2-启动NameServer">3.5.2.启动NameServer</h4><p>NameServer的配置修改完成，然后我们用静默启动的方式启动NameServer服务，启动完成后在nohup.out里看到这一条关键日志就是启动成功。并且使用jps指令可以看到有一个NamesrvStartup进程。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静默启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqnamesrv &amp;</span></span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># tail -f nohup.out </span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/wI36zR5SWGnF2sg.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/prfFy1hVANDxnJd.png" alt="img"></p><h3 id="3-6-Broker服务搭建">3.6.Broker服务搭建</h3><p><a href="http://xn--Brokerrunbroker-wy8y53qb44gl6dtn1h9p4b.sh">启动Broker的脚本是runbroker.sh</a>。Broker的默认预设内存是8G，启动前，如果内存不够，同样需要调整下JVM内存。<a href="http://xn--runbroker-z89na9857bcqmtlfda85rmzcf95l5zb.sh">修改的方式是直接修改runbroker.sh</a>。</p><h4 id="3-6-1-修改broker启动脚本配置">3.6.1.修改broker启动脚本配置</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># vi runbroker.sh</span></span><br><span class="line"><span class="comment">#将JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g&quot; 修改为 JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/ojqL8hQwJUX1y2d.png" alt="img"></p><h4 id="3-6-2-修改broker配置文件">3.6.2.修改broker配置文件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改broker资源配置文件，允许自动创建Topic</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># cd ../conf/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">conf</span>]<span class="comment"># vi broker.conf</span></span><br><span class="line"><span class="comment">#允许自动创建topic</span></span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"><span class="comment">#添加nameserver地址</span></span><br><span class="line">namesrvAddr=localhost:<span class="number">9876</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/O19dKxiGRZlzyom.png" alt="img"></p><h4 id="3-6-3-启动broker服务">3.6.3.启动broker服务</h4><p>Broker的配置修改完成，然后我们用静默启动的方式启动Broker服务，同样是检查nohup.out日志, 并且jps指令可以看到一个BrokerStartup进程。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.回到bin目录下，静默启动broker</span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">conf</span>]<span class="comment"># cd ../bin</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqbroker -c ../conf/broker.conf &amp;</span></span><br><span class="line"><span class="number">2</span>.查看日志,显示如下即显示成功*********每次启动broker时都要关注是否注册到目标nameserver上（name server is worker1:<span class="number">9876</span>）</span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># tail -f nohup.out </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># jps</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/A45DgVCStQpFnXv.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/cZK7zfaQX3r2jqA.png" alt="img"></p><h3 id="3-7-测试RocketMQ消息发送与消费">3.7.测试RocketMQ消息发送与消费</h3><p>在RocketMQ的安装包中，提供了一个tools.sh工具可以用来在命令行快速验证RocketMQ服务。</p><h4 id="1-我们在bin录下执行以下命令测试消息发送，默认会发1000条消息，发送完成自动关闭">1.我们在bin录下执行以下命令测试消息发送，默认会发1000条消息，发送完成自动关闭</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># export NAMESRV_ADDR=&#x27;localhost:9876&#x27;</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># ./tools.sh org.apache.rocketmq<span class="doctag">.example</span>.quickstart.Producer</span></span><br></pre></td></tr></table></figure><h4 id="2-出现以下提示则代表消息发送成功">2.出现以下提示则代表消息发送成功</h4><p><img src="https://s2.loli.net/2023/07/04/2Mjr3n9c4QXhIoT.png" alt="img"></p><h4 id="3-执行以下命令测试消息接收，Consumer执行不会自动关闭，会一直挂起等待新消息过来；">3.执行以下命令测试消息接收，Consumer执行不会自动关闭，会一直挂起等待新消息过来；</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># export NAMESRV_ADDR=&#x27;localhost:9876&#x27;</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># ./tools.sh org.apache.rocketmq<span class="doctag">.example</span>.quickstart.Consumer</span></span><br></pre></td></tr></table></figure><h4 id="4-出现以下提示则代表消息接收成功">4.出现以下提示则代表消息接收成功</h4><p><img src="https://s2.loli.net/2023/07/04/zGhuKksZfxw2P9g.png" alt="img"></p><h3 id="3-8-关闭RocketMQ服务">3.8.关闭RocketMQ服务</h3><p>在bin目录下通过脚本关闭服务：</p><h4 id="1-关闭Broker">1.关闭Broker</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./mqshutdown broker</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/iavEl1PQ5cOjzxr.png" alt="img"></p><h4 id="2-关闭NameServer">2.关闭NameServer</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./mqshutdown namesrv</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/du9Y7ZnjgOmL6bE.png" alt="img"></p><h4 id="3-查看服务">3.查看服务</h4><p><img src="https://s2.loli.net/2023/07/04/FbVB7MpahPTKtiv.png" alt="img"></p><p><strong>至此RockMQ单机测试成功，接下来搭建集群。</strong></p><h2 id="4-RocketMQ集群架构">4.RocketMQ集群架构</h2><p>刚才的演示中，我们已经体验到了RocketMQ是如何工作的。我们回头看RocketMQ的集群架构，就能够有更全面的理解了。<img src="https://s2.loli.net/2023/07/04/N4wYnhZJ53DzEfb.png" alt="img"></p><h3 id="4-1-RocketMQ集群架构解析">4.1.RocketMQ集群架构解析</h3><p>一个完整的RocketMQ集群中，有如下几种角色 ：</p><ul><li>Producer：消息的发送者；举例：发信者</li><li>Consumer：消息接收者；举例：收信者</li><li>Broker：暂存和传输消息；举例：邮局</li><li>NameServer：管理Broker；举例：各个邮局的管理机构</li><li>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息 。</li><li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息。</li></ul><h3 id="4-2-RocketMQ集群搭建">4.2.RocketMQ集群搭建</h3><p>准备三台虚机，并配置机器名。可以利用安装好的虚机通过克隆出另外两个机器。</p><p><img src="https://s2.loli.net/2023/07/04/8w3IBiTrOtHoshg.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/f1tDRescQUuVGz7.png" alt="img"></p><h4 id="4-2-1-系统配置">4.2.1.系统配置</h4><h5 id="1-使用vi-etc-hosts命令，配置机器名，在文件末尾加上以下配置">1.使用vi /etc/hosts命令，配置机器名，在文件末尾加上以下配置:</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># vi /etc/hosts</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">43.134</span> worker1</span><br><span class="line"><span class="number">192.168</span>.<span class="number">43.135</span> worker2</span><br><span class="line"><span class="number">192.168</span>.<span class="number">43.136</span> worker3</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/YwOVfFhINJBDqSv.png" alt="img"></p><h5 id="2-服务之间设置免密登陆，三个机器都使用ssh-keygen生成秘钥。提示录入直接回车即可">2.服务之间设置免密登陆，三个机器都使用ssh-keygen生成秘钥。提示录入直接回车即可</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># ssh-keygen</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/KQqpcHv6Sn7TYld.png" alt="img"></p><h5 id="3-三个机器都使用以下命令分发给其他机器，输入yes，然后输入密码；这样可以直接某个机器使用ssh或者scp到另外的机器。">3.三个机器都使用以下命令分发给其他机器，输入yes，然后输入密码；这样可以直接某个机器使用ssh或者scp到另外的机器。</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># ssh-copy-id worker1</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># ssh-copy-id worker2</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># ssh-copy-id worker3</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/YuSXFeAB5gmdnrT.png" alt="img"></p><h5 id="4-停止并禁用防火墙或者删除防火墙，我这边使用的是删除防火墙。">4.停止并禁用防火墙或者删除防火墙，我这边使用的是删除防火墙。</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查防火墙状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># firewall-cmd --state</span></span><br><span class="line"><span class="comment">#停止并禁用防火墙</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment">#删除防火墙</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># yum remove firewalld</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/axz1KEmqHGhYrTc.png" alt="img"></p><h4 id="4-2-2-配置RocketMQ主从集群">4.2.2.配置RocketMQ主从集群</h4><p>使用conf/2m-2s-async下的配置文件搭建一个2主2从异步刷盘的集群。设计的集群情况如下：</p><table><thead><tr><th>机器名</th><th>nemaeServer节点部署</th><th>broker节点部署</th></tr></thead><tbody><tr><td>worker1</td><td>nameserver</td><td></td></tr><tr><td>worker2</td><td>nameserver</td><td>broker-a,broker-b-s</td></tr><tr><td>worker3</td><td>nameserver</td><td>broker-b,broker-a-s</td></tr></tbody></table><h5 id="4-2-2-1-配置方式：conf目录下存在三种配置方式">4.2.2.1.配置方式：conf目录下存在三种配置方式</h5><ul><li>2m-2s-async：2主2从异步刷盘(吞吐量较大，但是消息可能丢失)</li><li>2m-2s-sync：2主2从同步刷盘(吞吐量会下降，但是消息更安全)</li><li>2m-noslave：2主无从(单点故障)，然后还可以直接配置broker.conf，进行单点环境配置</li></ul><p>而dleger就是用来实现主从切换的。集群中的节点会基于Raft协议随机选举出一个leader，其他的就都是follower。通常正式环境都会采用这种方式来搭建集群。</p><h5 id="4-2-2-2-搭建2主2从模式，配置2m-2s-async目录Broker文件：">4.2.2.2.搭建2主2从模式，配置2m-2s-async目录Broker文件：</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.进入conf/<span class="number">2</span>m<span class="literal">-2s-async</span>下:</span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> /]<span class="comment"># cd /app/rocketMQ/rocketmq-all-5.1.0-bin-release/conf/2m-2s-async/</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.配置worker2机器的主节点,将下方broker<span class="literal">-a</span>.properties内容配置到相应文件中，原有配置使用 <span class="comment">#号屏蔽</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="number">2</span><span class="type">m</span>-<span class="number">2</span><span class="type">s</span>-<span class="type">async</span>]<span class="comment"># vi broker-a.properties </span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.配置worker2机器的主节点,将下方broker<span class="literal">-b-s</span>.properties内容配置到相应文件中，原有配置使用 <span class="comment">#号屏蔽</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="number">2</span><span class="type">m</span>-<span class="number">2</span><span class="type">s</span>-<span class="type">async</span>]<span class="comment"># vi broker-b-s.properties </span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.配置worker3机器的主节点,将下方broker<span class="literal">-b</span>.properties内容配置到相应文件中，原有配置使用 <span class="comment">#号屏蔽</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="number">2</span><span class="type">m</span>-<span class="number">2</span><span class="type">s</span>-<span class="type">async</span>]<span class="comment"># vi broker-b.properties </span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.配置worker3机器的主节点,将下方broker<span class="literal">-a-s</span>.properties内容配置到相应文件中，原有配置使用 <span class="comment">#号屏蔽</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="number">2</span><span class="type">m</span>-<span class="number">2</span><span class="type">s</span>-<span class="type">async</span>]<span class="comment"># vi broker-a-s.properties </span></span><br><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line">brokerName=broker<span class="literal">-a</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示Slave</span></span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=worker1:<span class="number">9876</span>;worker2:<span class="number">9876</span>;worker3:<span class="number">9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line"><span class="comment">#是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"><span class="comment">#是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line"><span class="comment">#Broker对外服务的监听端口</span></span><br><span class="line">listenPort=<span class="number">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨4点</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=<span class="number">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/app/rocketMQ/store</span><br><span class="line"><span class="comment">#commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/app/rocketMQ/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/app/rocketMQ/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/app/rocketMQ/store/index</span><br><span class="line"><span class="comment">#checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/app/rocketMQ/store/checkpoint</span><br><span class="line"><span class="comment">#abort文件存储路径</span></span><br><span class="line">abortFile=/app/rocketMQ/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker的角色</span></span><br><span class="line"><span class="comment">#-ASYNC_MASTER异步复制Master</span></span><br><span class="line"><span class="comment">#-SYNC_MASTER同步双写Master</span></span><br><span class="line"><span class="comment">#-SLAVE</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#-ASYNC_FLUSH异步刷盘</span></span><br><span class="line"><span class="comment">#-SYNC_FLUSH同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#开启Sql过滤</span></span><br><span class="line">enablePropertyFilter=true</span><br><span class="line"><span class="comment">#重试支持过滤</span></span><br><span class="line">filterSupportRetry=true</span><br><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line">brokerName=broker<span class="literal">-b</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示Slave</span></span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=worker1:<span class="number">9876</span>;worker2:<span class="number">9876</span>;worker3:<span class="number">9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line"><span class="comment">#是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"><span class="comment">#是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line"><span class="comment">#Broker对外服务的监听端口</span></span><br><span class="line">listenPort=<span class="number">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨4点</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=<span class="number">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/app/rocketMQ/store</span><br><span class="line"><span class="comment">#commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/app/rocketMQ/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/app/rocketmQ/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/app/rocketMQ/store/index</span><br><span class="line"><span class="comment">#checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/app/rocketMQ/store/checkpoint</span><br><span class="line"><span class="comment">#abort文件存储路径</span></span><br><span class="line">abortFile=/app/rocketMQ/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker的角色</span></span><br><span class="line"><span class="comment">#-ASYNC_MASTER异步复制Master</span></span><br><span class="line"><span class="comment">#-SYNC_MASTER同步双写Master</span></span><br><span class="line"><span class="comment">#-SLAVE</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#-ASYNC_FLUSH异步刷盘</span></span><br><span class="line"><span class="comment">#-SYNC_FLUSH同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#开启Sql过滤</span></span><br><span class="line">enablePropertyFilter=true</span><br><span class="line"><span class="comment">#重试支持过滤</span></span><br><span class="line">filterSupportRetry=true</span><br><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line">brokerName=broker<span class="literal">-a</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示Slave</span></span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=worker1:<span class="number">9876</span>;worker2:<span class="number">9876</span>;worker3:<span class="number">9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line"><span class="comment">#是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"><span class="comment">#是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line"><span class="comment">#Broker对外服务的监听端口</span></span><br><span class="line">listenPort=<span class="number">11011</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨4点</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=<span class="number">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/app/rocketMQ/storeSlave</span><br><span class="line"><span class="comment">#commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/app/rocketMQ/storeSlave/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/app/rocketMQ/storeSlave/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/app/rocketMQ/storeSlave/index</span><br><span class="line"><span class="comment">#checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/app/rocketMQ/storeSlave/checkpoint</span><br><span class="line"><span class="comment">#abort文件存储路径</span></span><br><span class="line">abortFile=/app/rocketMQ/storeSlave/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line">  <span class="comment">#Broker的角色</span></span><br><span class="line"><span class="comment">#-ASYNC_MASTER异步复制Master</span></span><br><span class="line"><span class="comment">#-SYNC_MASTER同步双写Master</span></span><br><span class="line"><span class="comment">#-SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#-ASYNC_FLUSH异步刷盘</span></span><br><span class="line"><span class="comment">#-SYNC_FLUSH同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#开启Sql过滤</span></span><br><span class="line">enablePropertyFilter=true</span><br><span class="line"><span class="comment">#重试支持过滤</span></span><br><span class="line">filterSupportRetry=true</span><br><span class="line"><span class="comment">#所属集群名字，名字一样的节点就在同一个集群内</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"><span class="comment">#broker名字，名字一样的节点就是一组主从节点。</span></span><br><span class="line">brokerName=broker<span class="literal">-b</span></span><br><span class="line"><span class="comment">#brokerid,0就表示是Master，&gt;0的都是表示Slave</span></span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=worker1:<span class="number">9876</span>;worker2:<span class="number">9876</span>;worker3:<span class="number">9876</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=<span class="number">4</span></span><br><span class="line"><span class="comment">#是否允许Broker自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"><span class="comment">#是否允许Broker自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line"><span class="comment">#Broker对外服务的监听端口</span></span><br><span class="line">listenPort=<span class="number">11011</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨4点</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=<span class="number">120</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=<span class="number">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=<span class="number">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=<span class="number">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/app/rocketMQ/storeSlave</span><br><span class="line"><span class="comment">#commitLog存储路径</span></span><br><span class="line">storePathCommitLog=/app/rocketMQ/storeSlave/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/app/rocketMQ/storeSlave/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/app/rocketMQ/storeSlave/index</span><br><span class="line"><span class="comment">#checkpoint文件存储路径</span></span><br><span class="line">storeCheckpoint=/app/rocketMQ/storeSlave/checkpoint</span><br><span class="line"><span class="comment">#abort文件存储路径</span></span><br><span class="line">abortFile=/app/rocketMQ/storeSlave/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=<span class="number">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker的角色</span></span><br><span class="line"><span class="comment">#-ASYNC_MASTER异步复制Master</span></span><br><span class="line"><span class="comment">#-SYNC_MASTER同步双写Master</span></span><br><span class="line"><span class="comment">#-SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#-ASYNC_FLUSH异步刷盘</span></span><br><span class="line"><span class="comment">#-SYNC_FLUSH同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#开启Sql过滤</span></span><br><span class="line">enablePropertyFilter=true</span><br><span class="line"><span class="comment">#重试支持过滤</span></span><br><span class="line">filterSupportRetry=true</span><br></pre></td></tr></table></figure><p>这样2主2从的集群配置基本就完成了。搭建过程中需要注意的配置项：</p><ul><li>同一机器上两个实例的store目录不能相同，否则会报错 Lock failed,MQ already started</li><li>同一机器上两个实例的listenPort也不能相同。否则会报端口占用的错</li><li>如果是多网卡的机器，比如云服务器，那么需要在broker.conf中增加brokerIP1属性，指定所在机器的外网网卡地址。</li></ul><h4 id="4-2-3-启动集群">4.2.3.启动集群</h4><p>由于我们之前已经在worker1单机部署过，所以相关的启动jvm参数已经调整过，如果是新配置需要注意jvm参数根据实际的内存大小分配。其他两个机器是克隆过来的所以无需在进行调整，nameServer不需要进行配置，直接启动nameServer即可。这也看出nameserver是无状态的。</p><p>RocketMQ5.X版本兼容之前旧版本的启动方式，即如下部署方式：</p><h5 id="4-2-3-1-启动worker1、worker2、worker3的nameServer，并观察启动日志">4.2.3.1.启动worker1、worker2、worker3的nameServer，并观察启动日志</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="number">2</span><span class="type">m</span>-<span class="number">2</span><span class="type">s</span>-<span class="type">async</span>]<span class="comment"># cd ../../bin/</span></span><br><span class="line"><span class="comment">#启动之前使用jps命令查看下环境是否正常，有时候会出现环境变量异常，需要重新使用source ~/.bash_profile命令刷新配置</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqnamesrv &amp;</span></span><br><span class="line"><span class="comment">#观察日志查看是否启动成功，同样出现The Name Server boot success. serializeType=JSON 即成功启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># tail -f nohup.out</span></span><br><span class="line"><span class="comment">#也可以使用tail -f ~/logs/rocketmqlogs/namesrv.log 观察日志</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/nbB9NW1cpEeydZt.png" alt="img"></p><h5 id="4-2-3-2-worker2上启动broker-a节点与broker-b-s节点">4.2.3.2.worker2上启动broker-a节点与broker-b-s节点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqbroker -c ../conf/2m-2s-async/broker-a.properties &amp; </span></span><br><span class="line"><span class="comment">#出现以下日志即启动成功，观察注册的nameServer服务</span></span><br><span class="line"><span class="comment">#The broker[broker-a, 192.168.43.135:10911] boot success. serializeType=JSON and name server is worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqbroker -c ../conf/2m-2s-async/broker-b-s.properties &amp; </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># tail -f nohup.out </span></span><br><span class="line"><span class="comment">#出现以下日志即启动成功，观察注册的nameServer服务</span></span><br><span class="line"><span class="comment">#The broker[broker-b, 192.168.43.135:11011] boot success. serializeType=JSON and name server is worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"><span class="comment">#也可以使用tail -f ~/logs/rocketmqlogs/broker.log 观察日志</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/u3QGMFfzIJsEZvc.png" alt="img"></p><h5 id="4-2-3-3-worker3上启动broker-b节点与broker-a-s节点">4.2.3.3.worker3上启动broker-b节点与broker-a-s节点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqbroker -c ../conf/2m-2s-async/broker-b.properties &amp; </span></span><br><span class="line"><span class="comment">#出现以下日志即启动成功，观察注册的nameServer服务</span></span><br><span class="line"><span class="comment">#The broker[broker-b, 192.168.43.136:10911] boot success. serializeType=JSON and name server is worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqbroker -c ../conf/2m-2s-async/broker-a-s.properties &amp;</span></span><br><span class="line"><span class="comment">#出现以下日志即启动成功，观察注册的nameServer服务</span></span><br><span class="line"><span class="comment">#The broker[broker-b, 192.168.43.136:10911] boot success. serializeType=JSON and name server is worker1:9876;worker2:9876;worker3:9876</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/C2Fpc785kB1UDaK.png" alt="img"></p><h5 id="4-2-3-4-使用测试工具测试消息收发">4.2.3.4.使用测试工具测试消息收发</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># worker2发送消息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># ./tools.sh org.apache.rocketmq<span class="doctag">.example</span>.quickstart.Producer</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/8hEucPyKw3e9fzb.png" alt="img"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># worker3接受消息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># ./tools.sh org.apache.rocketmq<span class="doctag">.example</span>.quickstart.Consumer</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/QYAh4G8cPx6fwlZ.png" alt="img"></p><p>RocketMQ5.X版本兼容之前旧版本部署完成。在部署新版之前先通过maven安装一个rocketmq-dashboard可视化界面查看我们的集群。</p><h4 id="4-2-4-安装rocketmq-dashboard">4.2.4.安装rocketmq-dashboard</h4><h5 id="4-2-4-1-在1号机通过maven安装dashboard，所以要先安装maven服务">4.2.4.1.在1号机通过maven安装dashboard，所以要先安装maven服务</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.回到app目录，创建一个maven目录，将maven压缩包上载到该目录。</span><br><span class="line"><span class="comment">#maven包可以自行在官网下载，也可以使用课件资料中的maven包，官网下载地址：http://maven.apache.org/download.cgi</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># cd /app/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># mkdir maven</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># cd maven/</span></span><br><span class="line"><span class="comment">#上载完成后解压</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">maven</span>]<span class="comment"># tar zxvf apache-maven-3.9.1-bin.tar.gz</span></span><br><span class="line"><span class="comment">#创建jar包仓库目录，然后修改maven配置</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">maven</span>]<span class="comment"># mkdir repository</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/hnVOiGezm7NMob3.png" alt="img"></p><h5 id="4-2-4-2-配置maven环境变量">4.2.4.2.配置maven环境变量</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置MAVEN_HOME，并在path目录最前加上$MAVEN_HOME/bin:</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">maven</span>]<span class="comment"># vi /etc/profile</span></span><br><span class="line">export MAVEN_HOME=/app/maven/apache<span class="literal">-maven-3</span>.<span class="number">9.1</span></span><br><span class="line"><span class="variable">$MAVEN_HOME</span>/bin:</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/rJqOaBpS5lPFQLC.png" alt="img"></p><h5 id="4-2-4-3-更新环境配置，查看maven是否成功">4.2.4.3.更新环境配置，查看maven是否成功</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">maven</span>]<span class="comment"># source /etc/profile</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">maven</span>]<span class="comment"># mvn -v</span></span><br><span class="line"><span class="comment">#显示如下信息即安装成功</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/dTsn65hXDIiuZ3F.png" alt="img"></p><h5 id="4-2-4-4-修改maven仓库配置">4.2.4.4.修改maven仓库配置</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入maven配置目录</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">maven</span>]<span class="comment"># cd apache-maven-3.9.1/conf/</span></span><br><span class="line"><span class="comment">#修改配置文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">conf</span>]<span class="comment"># vi settings.xml</span></span><br><span class="line"><span class="comment">#找到&lt;localRepository&gt;节点，添加本地仓库目录，注意不要添加在注释的代码中，单独拷贝节点，然后修改路径。</span></span><br><span class="line">&lt;localRepository&gt;/app/maven/repository&lt;/localRepository&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#找到&lt;mirror&gt;节点，将节点内容更换成以下配置:</span></span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">  &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;https://maven.aliyun.com/repository/public/&lt;/url&gt;</span><br><span class="line">  &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/sWCGScDgmFBZIp2.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/URTSQeIO6H2NpXL.png" alt="img"></p><h5 id="4-2-4-5-安装dashboard">4.2.4.5.安装dashboard</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回app目录创建dashboard目录，将下好的压缩包上载到该目录，同样可以使用资料中的压缩包或者自行下载。</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">dashboard</span>]<span class="comment"># cd /app/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># mkdir dashboard</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">app</span>]<span class="comment"># cd dashboard/</span></span><br><span class="line"><span class="comment">#上载后解压</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">dashboard</span>]<span class="comment"># unzip rocketmq-dashboard-rocketmq-dashboard-1.0.0.zip</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/PrC43N12ud8hTye.png" alt="img"></p><h5 id="4-2-4-6-编译dashboard">4.2.4.6.编译dashboard</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入源码目录使用mvn打包，也可以使用资料包中已经编译好的jar包。</span></span><br><span class="line"><span class="comment">#因为rocketMQ5.1版本对应dashboard的一些类还没有升级，最后编译时会异常，所以还是使用4.9版本打包dashboard，使用中未发现明显bug。</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="number">1.0</span><span class="type">.0</span>]<span class="comment"># cd rocketmq-dashboard-rocketmq-dashboard-1.0.0/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="number">1.0</span><span class="type">.0</span>]<span class="comment"># mvn clean package -Dmaven.test.skip=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打包失败可以使用以下命令，清除编译结果，重新打包。（编译成功无需使用）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="number">1.0</span><span class="type">.0</span>]<span class="comment"># mvn clean install -U -Dmaven.test.skip=true</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/4G9Uqku2LxesYQ7.png" alt="img"></p><h5 id="4-2-4-7-启动dashboard">4.2.4.7.启动dashboard</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译成功后，进入target目录，静默启动dashboard</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="type">rocketmq</span>-<span class="type">dashboard</span>-<span class="number">1.0</span><span class="type">.0</span>]<span class="comment"># cd target/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">target</span>]<span class="comment"># nohup java -jar rocketmq-dashboard-1.0.0.jar &amp;</span></span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">worker1</span> <span class="type">target</span>]<span class="comment"># tail -f nohup.out</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/jCTUf8zeIQuG6dx.png" alt="img"></p><h5 id="4-2-4-8-启动成功后访问：http-192-168-43-134-8080-操作dashboard界面">4.2.4.8.启动成功后访问：<a href="http://192.168.43.134:8080/#/">http://192.168.43.134:8080/#/</a>  操作dashboard界面:</h5><p><img src="https://s2.loli.net/2023/07/04/LMXIEfaz9ysCu8d.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/Mwmgj2TqYD3uUp1.png" alt="img"></p><h4 id="4-2-5-部署5-x版本-Local模式">4.2.5.部署5.x版本-Local模式</h4><p>Apache RocketMQ 5.0 版本完成基本消息收发，包括 NameServer、Broker、Proxy 组件。 在 5.0 版本中 Proxy 和 Broker 根据实际诉求可以分为 Local 模式和 Cluster 模式，一般情况下如果没有特殊需求，或者遵循从早期版本平滑升级的思路，可以选用Local模式。</p><ul><li>在 Local 模式下，Broker 和 Proxy 是同进程部署，只是在原有 Broker 的配置基础上新增 Proxy 的简易配置就可以运行。</li><li>在 Cluster 模式下，Broker 和 Proxy 分别部署，即在原有的集群基础上，额外再部署 Proxy 即可。</li></ul><h5 id="4-2-5-1-关闭worker2-worker3的broker服务">4.2.5.1.关闭worker2,worker3的broker服务</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># sh ./mqshutdown broker</span></span><br></pre></td></tr></table></figure><h5 id="4-2-5-2-使用Local方式部署，每个机器只能部署一个broker，否则会出现端口占用的异常，这里启用worker2的broker-a与worker3的broker-b节点。">4.2.5.2.使用Local方式部署，每个机器只能部署一个broker，否则会出现端口占用的异常，这里启用worker2的broker-a与worker3的broker-b节点。</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># worker2机器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqbroker -c ../conf/2m-2s-async/broker-a.properties --enable-proxy &amp;</span></span><br><span class="line"><span class="comment"># worker3机器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># nohup ./mqbroker -c ../conf/2m-2s-async/broker-b.properties --enable-proxy &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用tail -f ~/logs/rocketmqlogs/proxy.log查看日志</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># tail -f ~/logs/rocketmqlogs/proxy.log</span></span><br><span class="line"><span class="comment"># 出现以下异常即成功启动</span></span><br><span class="line"><span class="comment"># 2023-04-23 15:09:33 INFO main - The broker[broker-a, 192.168.43.135:10911] boot success. serializeType=JSON and name server is worker1:9876;worker2:9876;worker3:9876</span></span><br><span class="line"><span class="comment"># 2023-04-23 15:09:34 INFO main - grpc server start successfully.</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/QPBmOZVteEIDqJ6.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/sqNa6Gf7c1h89YP.png" alt="img"></p><h5 id="4-2-5-3-测试消息收发">4.2.5.3.测试消息收发</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># ./tools.sh org.apache.rocketmq<span class="doctag">.example</span>.quickstart.Producer</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> <span class="type">bin</span>]<span class="comment"># ./tools.sh org.apache.rocketmq<span class="doctag">.example</span>.quickstart.Consumer</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/07/04/sw2OAXjgBnDtihq.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/KgvQDhmX9lp1cFj.png" alt="img"></p><h5 id="4-2-5-4-登录dashboard页面查看注册成功">4.2.5.4.登录dashboard页面查看注册成功</h5><p><img src="https://s2.loli.net/2023/07/04/l5jyXwqbNaMO1DQ.png" alt="img"></p><h5 id="4-2-5-5-其他部署模式">4.2.5.5.其他部署模式</h5><p>官网还提供了其他部署模式，有兴趣的小伙伴可以自行研究，官网部署方式：<a href="https://rocketmq.apache.org/zh/docs/deploymentOperations/01deploy%E3%80%82">https://rocketmq.apache.org/zh/docs/deploymentOperations/01deploy。</a></p><p><strong>集群部署搭建的过程我们到此结束，接下来我们使用官方提供的exmaple代码进行实战。</strong></p><h2 id="5-官方API实战">5.官方API实战</h2><p>实战之前，我们需要先搭建一个基于Maven的springboot项目，只需要加入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来使用IDEA搭建一个Maven项目:</p><p><img src="https://s2.loli.net/2023/07/04/LXxAiEugKGBCQYy.png" alt="img"></p><p>工程创建后，我们添加Pom依赖：</p><p><img src="https://s2.loli.net/2023/07/04/ApsHoyT1bnhCeiW.png" alt="img"></p><p>这样工程就搭建完成了，接下来我们进入API实战。</p><h3 id="5-1-基本样例">5.1.基本样例</h3><p>消息生产者分别通过三种方式发送消息：</p><ul><li><p>同步发送：等待消息返回后再继续进行下面的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 同步发送</span></span><br><span class="line"><span class="comment">* Created by BaiLi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;SyncProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Simple&quot;</span>, <span class="comment">//主题</span></span><br><span class="line">                                      <span class="string">&quot;TagA&quot;</span>,  <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">                                      <span class="string">&quot;Simple-Sync&quot;</span>.getBytes(StandardCharsets.UTF_8) <span class="comment">//消息体。</span></span><br><span class="line">                                     );</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            System.out.printf(i + <span class="string">&quot;.发送消息成功：%s%n&quot;</span>, send);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>异步发送：不等待消息返回直接进入后续流程。broker将结果返回后调用callback函数，并使用CountDownLatch计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 异步发送</span></span><br><span class="line"><span class="comment">* Created by BaiLi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;AsyncProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">100</span>);<span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Simple&quot;</span>, <span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;Simple-Async&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            producer.send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%d 消息发送成功%s%n&quot;</span>, index, sendResult);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%d 消息失败%s%n&quot;</span>, index, throwable);</span><br><span class="line">                    throwable.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                         );</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>单向发送：只负责发送，不管消息是否发送成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 单向发送</span></span><br><span class="line"><span class="comment">* Created by BaiLi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;AsyncProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Simple&quot;</span>,<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;Simple-Oneway&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            producer.sendOneway(message);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d 消息发送完成 %n&quot;</span> , i);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>消费者消费消息分两种：</p><ul><li><p>拉模式：消费者主动去Broker上拉取消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPullConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.PullResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.store.ReadOffsetType;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageQueue;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 拉模式</span></span><br><span class="line"><span class="comment">* Created by BaiLi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PullConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPullConsumer</span> <span class="variable">pullConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPullConsumer</span>(<span class="string">&quot;SimplePullConsumer&quot;</span>);</span><br><span class="line">        pullConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);<span class="comment">//执行nameserver地址</span></span><br><span class="line">        Set&lt;String&gt; topics = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        topics.add(<span class="string">&quot;Simple&quot;</span>);<span class="comment">//添加Topic</span></span><br><span class="line">        topics.add(<span class="string">&quot;TopicTest&quot;</span>);</span><br><span class="line">        pullConsumer.setRegisterTopics(topics);</span><br><span class="line">        pullConsumer.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">//循环拉取消息</span></span><br><span class="line">            pullConsumer.getRegisterTopics().forEach(n -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Set&lt;MessageQueue&gt; messageQueues = pullConsumer.fetchSubscribeMessageQueues(n);<span class="comment">//获取主题中的Queue</span></span><br><span class="line">                    messageQueues.forEach(l -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//获取Queue中的偏移量</span></span><br><span class="line">                            <span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> pullConsumer.getOffsetStore().readOffset(l, ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">                            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                offset = pullConsumer.getOffsetStore().readOffset(l, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                offset = pullConsumer.maxOffset(l);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                offset = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//拉取Queue中的消息。每次获取32条</span></span><br><span class="line">                            <span class="type">PullResult</span> <span class="variable">pullResult</span> <span class="operator">=</span> pullConsumer.pull(l, <span class="string">&quot;*&quot;</span>, offset, <span class="number">32</span>);</span><br><span class="line">                            System.out.printf(<span class="string">&quot;循环拉取消息ing %s%n&quot;</span>,pullResult);</span><br><span class="line">                            <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                                <span class="keyword">case</span> FOUND:</span><br><span class="line">                                    pullResult.getMsgFoundList().forEach(p -&gt; &#123;</span><br><span class="line">                                        System.out.printf(<span class="string">&quot;拉取消息成功%s%n&quot;</span>, p);</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                    <span class="comment">//更新偏移量</span></span><br><span class="line">                                    pullConsumer.updateConsumeOffset(l, pullResult.getNextBeginOffset());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>推模式：消费者等待Broker把消息推送过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 推模式</span></span><br><span class="line"><span class="comment">* Created by BaiLi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;SimplePushConsumer&quot;</span>);</span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Simple&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        pushConsumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;</span><br><span class="line">                list.forEach( n-&gt;&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;收到消息: %s%n&quot;</span> , n);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pushConsumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通常情况下，用推模式比较简单。需要注意DefaultMQPullConsumerImpl这个消费者类已标记为过期，但是还是可以使用的。替换的类是<code>DefaultLitePullConsumerImpl</code>。</p><ul><li><code>LitePullConsumerSubscribe</code>：随机获取一个queue消息</li><li><code>LitePullConsumerAssign</code>：指定一个queue消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 拉模式-随机获取一个queue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PullLiteConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultLitePullConsumer</span> <span class="variable">litePullConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultLitePullConsumer</span>(<span class="string">&quot;SimpleLitePullConsumer&quot;</span>);</span><br><span class="line">        litePullConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        litePullConsumer.subscribe(<span class="string">&quot;Simple&quot;</span>);</span><br><span class="line">        litePullConsumer.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            List&lt;MessageExt&gt; poll = litePullConsumer.poll();</span><br><span class="line">            System.out.printf(<span class="string">&quot;消息拉取成功 %s%n&quot;</span> , poll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 指定获取messageQueue消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PullLiteConsumerAssign</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultLitePullConsumer</span> <span class="variable">litePullConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultLitePullConsumer</span>(<span class="string">&quot;SimpleLitePullConsumer&quot;</span>);</span><br><span class="line">        litePullConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        litePullConsumer.start();</span><br><span class="line">        Collection&lt;MessageQueue&gt; messageQueues = litePullConsumer.fetchMessageQueues(<span class="string">&quot;TopicTest&quot;</span>);</span><br><span class="line">        List&lt;MessageQueue&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(messageQueues);</span><br><span class="line">        litePullConsumer.assign(list);</span><br><span class="line">        litePullConsumer.seek(list.get(<span class="number">0</span>), <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                List&lt;MessageExt&gt; messageExts = litePullConsumer.poll();</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s %n&quot;</span>, messageExts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            litePullConsumer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">官方样例</span><br><span class="line">生产者：</span><br><span class="line">  同步发送：org.apache.rocketmq.example.simple.Producer</span><br><span class="line">  异步发送：org.apache.rocketmq.example.simple.AsyncProducer</span><br><span class="line">  单向发送：org.apache.rocketmq.example.simple.OnewayProducer</span><br><span class="line">消费者：</span><br><span class="line">  拉模式：org.apache.rocketmq.example.simple.PullConsumer</span><br><span class="line">  推模式：org.apache.rocketmq.example.simple.PushConsumer</span><br><span class="line">  拉模式（随机获取一个queue）：org.apache.rocketmq.example.simple.LitePullConsumerSubscribe.java</span><br><span class="line">  拉模式（指定获取一个queue）：org.apache.rocketmq.example.simple.LitePullConsumerAssign.java</span><br></pre></td></tr></table></figure><h3 id="5-2-顺序消息">5.2.顺序消息</h3><p>顺序消息指生产者局部有序发送到一个queue，但多个queue之间是全局无序的。</p><ul><li>顺序消息生产者样例：通过MessageQueueSelector将消息有序发送到同一个queue中。</li><li>顺序消息消费者样例：通过MessageListenerOrderly消费者每次读取消息都只从一个queue中获取（通过加锁的方式实现）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.MessageQueueSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageQueue;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序消息生产者</span></span><br><span class="line"><span class="comment">* Created by BaiLi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;OrderProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;OrderTopic&quot;</span>,<span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                                              (<span class="string">&quot;order_&quot;</span> + j + <span class="string">&quot;_step_&quot;</span> + i).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(message, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; list, Message message, Object o)</span> &#123;</span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) o;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> id % list.size();</span><br><span class="line">                        <span class="keyword">return</span> list.get(index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, j);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序消息消费者</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;OrderConsumer&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;OrderTopic&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeOrderlyContext consumeOrderlyContext)</span> &#123;</span><br><span class="line">                list.forEach(n-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;QueueId:&quot;</span>+n.getQueueId() + <span class="string">&quot;收到消息内容 &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(n.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">官方样例</span><br><span class="line">生产者：</span><br><span class="line">  org.apache.rocketmq.example.order.Producer </span><br><span class="line">消费者：</span><br><span class="line">  org.apache.rocketmq.example.order.Consumer</span><br></pre></td></tr></table></figure><h3 id="5-3-广播消息">5.3.广播消息</h3><p>广播消息并没有特定的消息消费者样例，这是因为这涉及到消费者的集群消费模式。</p><ul><li>MessageModel.BROADCASTING：广播消息。一条消息会发给所有订阅了对应主题的消费者，不管消费者是不是同一个消费者组。</li><li>MessageModel.CLUSTERING：集群消息。每一条消息只会被同一个消费者组中的一个实例消费。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> broadcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广播消息消费模式</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BroadcastConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;BroadCastConsumer&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;simple&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING); <span class="comment">//广播模式</span></span><br><span class="line"><span class="comment">//        consumer.setMessageModel(MessageModel.CLUSTERING);//集群模式</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;</span><br><span class="line">                list.forEach(n-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;QueueId:&quot;</span>+n.getQueueId() + <span class="string">&quot;收到消息内容 &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(n.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Broadcast Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-延迟消息">5.4.延迟消息</h3><p>延迟消息实现的效果就是在调用producer.send方法后，消息并不会立即发送出去，而是会等一段时间再发送出去。这是RocketMQ特有的一个功能。</p><ul><li>message.setDelayTimeLevel(3)：预定日常定时发送。1到18分别对应messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h；可以在dashboard中broker配置查看。</li><li>msg.setDelayTimeMs(10L)：指定时间定时发送。默认支持最大延迟时间为3天，可以根据broker配置：timerMaxDelaySec修改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> schedule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预定日程定时发送</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ScheduleProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Schedule&quot;</span>, <span class="comment">//主题</span></span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>,  <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">                    <span class="string">&quot;ScheduleProducer&quot;</span>.getBytes(StandardCharsets.UTF_8) <span class="comment">//消息体。</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//1到18分别对应messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">            msg.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">            producer.send(msg);</span><br><span class="line">            System.out.printf(i + <span class="string">&quot;.发送消息成功：%s%n&quot;</span>, LocalTime.now());</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> schedule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预定日程消费者</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;SimplePushConsumer&quot;</span>);</span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Schedule&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        pushConsumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;</span><br><span class="line">                list.forEach( n-&gt;&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;接收时间：%s %n&quot;</span>, LocalTime.now());</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pushConsumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Simple Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> schedule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定时间发送</span></span><br><span class="line"><span class="comment"> * 默认支持最大延迟时间为3天，可以根据broker配置：timerMaxDelaySec 修改</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;TimeProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;Schedule&quot;</span>, <span class="comment">//主题</span></span><br><span class="line">                    <span class="string">&quot;TagA&quot;</span>,  <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">                    <span class="string">&quot;TimeProducer&quot;</span>.getBytes(StandardCharsets.UTF_8) <span class="comment">//消息体。</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 相对时间：延时消息。此消息将在 10 秒后传递给消费者。</span></span><br><span class="line">            msg.setDelayTimeMs(<span class="number">10000L</span>);</span><br><span class="line">            <span class="comment">// 绝对时间：定时消息。设置一个具体的时间，然后在这个时间之后多久在进行发送消息</span></span><br><span class="line"><span class="comment">//            msg.setDeliverTimeMs(System.currentTimeMillis() + 10000L);</span></span><br><span class="line">            producer.send(msg);</span><br><span class="line">            System.out.printf(i + <span class="string">&quot;.发送消息成功：%s%n&quot;</span>, LocalTime.now());</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> schedule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时发送消费者</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;TimeConsumer&quot;</span>);</span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;Schedule&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        pushConsumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;</span><br><span class="line">                list.forEach( n-&gt;&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;接收时间：%s %n&quot;</span>, LocalTime.now());</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pushConsumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Simple Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生产者：</span><br><span class="line">  预定日期发送：org.apache.rocketmq.example.schedule.ScheduledMessageProducer.java</span><br><span class="line">  指定时间发送：org.apache.rocketmq.example.schedule.TimerMessageProducer.java</span><br><span class="line">消费者：</span><br><span class="line">  预定日期消费：org.apache.rocketmq.example.schedule.ScheduledMessageConsumer.java</span><br><span class="line">    指定时间消费：org.apache.rocketmq.example.schedule.TimerMessageConsumer.java</span><br></pre></td></tr></table></figure><h3 id="5-5-批量消息">5.5.批量消息</h3><p>批量消息是指将多条消息合并成一个批量消息，一次发送出去。这样的好处是可以减少网络IO，提升吞吐量。</p><p>批量消息的使用限制：</p><ul><li>消息大小不能超过4M，虽然源码注释不能超1M，但是实际使用不超过4M即可。平衡整体的性能，建议保持1M左右。</li><li>相同的Topic，</li><li>相同的waitStoreMsgOK</li><li>不能是延迟消息、事务消息等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> batch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量发送消息</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;BatchProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        messages.add(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;simple&quot;</span>,<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;BatchProducer0&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        messages.add(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;simple&quot;</span>,<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;BatchProducer1&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        messages.add(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;simple&quot;</span>,<span class="string">&quot;TagA&quot;</span>, <span class="string">&quot;BatchProducer2&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(messages);</span><br><span class="line">        System.out.printf(<span class="string">&quot;.发送消息成功：%s%n&quot;</span>, send);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> batch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分批批量发送消息</span></span><br><span class="line"><span class="comment"> * 注意修改SIZE_LIMIT为 = 10 * 1000，不然发送消息时会提示消息体积过大</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SplitBatchProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;SplitBatchProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        ArrayList&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            messages.add(<span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;simple&quot;</span>,<span class="string">&quot;TagA&quot;</span>, (<span class="string">&quot;SplitBatchProducer&quot;</span>+i).getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListSplitter</span> <span class="variable">splitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListSplitter</span>(messages);</span><br><span class="line">        <span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">            List&lt;Message&gt; listItem = splitter.next();</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(listItem);</span><br><span class="line">            System.out.printf(<span class="string">&quot;.发送消息成功：%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListSplitter</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE_LIMIT</span> <span class="operator">=</span> <span class="number">10</span> * <span class="number">1000</span>;  <span class="comment">// 每个消息批次的最大大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;  <span class="comment">// 待发送的消息列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currIndex; <span class="comment">// 当前拆分到的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messages = messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextIndex</span> <span class="operator">=</span> currIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messages.get(nextIndex);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpSize</span> <span class="operator">=</span> message.getTopic().length() + message.getBody().length;</span><br><span class="line">            Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">            &#125;</span><br><span class="line">            tmpSize = tmpSize + <span class="number">20</span>;</span><br><span class="line">            <span class="comment">// 如果超过了单个批次所允许的大小，就将此消息之前的消息作为下一个子列表返回</span></span><br><span class="line">            <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="comment">// 如果是第一条消息就超出大小限制，就跳过这条消息再继续扫描</span></span><br><span class="line">                <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    nextIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前子列表大小已经超出所允许的单个批次大小，那么就暂停添加消息</span></span><br><span class="line">            <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                totalSize += tmpSize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回从currIndex到nextIndex之间的所有消息</span></span><br><span class="line">        List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">        currIndex = nextIndex;</span><br><span class="line">        <span class="keyword">return</span> subList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">生产者：</span><br><span class="line">  org.apache.rocketmq.example.batch.SimpleBatchProducer</span><br><span class="line">  org.apache.rocketmq.example.batch.SplitBatchProducer</span><br></pre></td></tr></table></figure><h3 id="5-6-过滤消息">5.6.过滤消息</h3><p>在大多数情况下，可以使用Message的Tag属性来简单快速的过滤信息。</p><h4 id="5-6-1-使用Tag方式过滤（通过consumer-subscribe-“TagFilterTest”-“TagA-TagC”-实现）">5.6.1.使用Tag方式过滤（通过consumer.subscribe(“TagFilterTest”, “TagA || TagC”)实现）</h4><ul><li><p>tag过滤生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤消息-tag过滤生产者</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TagFilterProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;SyncProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;TagA&quot;</span>,<span class="string">&quot;TagB&quot;</span>,<span class="string">&quot;TagC&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;FilterTopic&quot;</span>, <span class="comment">//主题</span></span><br><span class="line">                    tags[i % tags.length],  <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">                    (<span class="string">&quot;TagFilterProducer_&quot;</span>+tags[i % tags.length]).getBytes(StandardCharsets.UTF_8) <span class="comment">//消息体。</span></span><br><span class="line">            );</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            System.out.printf(i + <span class="string">&quot;.发送消息成功：%s%n&quot;</span>, send);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>tag过滤消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤消息-tag过滤消费者</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TagFilterConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;SimplePushConsumer&quot;</span>);</span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;FilterTopic&quot;</span>,<span class="string">&quot;TagA || TagC&quot;</span>);</span><br><span class="line">        pushConsumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;</span><br><span class="line">                list.forEach( n-&gt;&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;收到消息: %s%n&quot;</span> , <span class="keyword">new</span> <span class="title class_">String</span>(n.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pushConsumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;TagFilter Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tag是RocketMQ中特有的一个消息属性。</p><p>RocketMQ的最佳实践中就建议使用RocketMQ时，一个应用可以就用一个Topic，而应用中的不同业务就用Tag来区分。</p><p>Tag方式有一个很大的限制，就是一个消息只能有一个Tag，这在一些比较复杂的场景就有点不足了。 这时候可以使用SQL表达式来对消息进行过滤。</p></li></ul><h4 id="5-6-2-使用Sql方式过滤（通过MessageSelector-bySql-String-sql-参数实现）">5.6.2.使用Sql方式过滤（通过MessageSelector.bySql(String sql)参数实现）</h4><p>这里面的sql语句是按照SQL92标准来执行的。sql中可以使用的参数有默认的TAGS和一个在生产者中加入的自定义属性。</p><ul><li><p>sql过滤生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQBrokerException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.exception.RemotingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 过滤消息-SQL过滤生产者</span></span><br><span class="line"><span class="comment">* Created by BaiLi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlFilterProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, MQBrokerException, RemotingException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;SyncProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;TagA&quot;</span>,<span class="string">&quot;TagB&quot;</span>,<span class="string">&quot;TagC&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;FilterTopic&quot;</span>, <span class="comment">//主题</span></span><br><span class="line">                                      tags[i % tags.length],  <span class="comment">//设置消息Tag，用于消费端根据指定Tag过滤消息。</span></span><br><span class="line">                                      (<span class="string">&quot;TagFilterProducer_&quot;</span>+tags[i % tags.length] +  <span class="string">&quot;_i_&quot;</span> + i).getBytes(StandardCharsets.UTF_8) <span class="comment">//消息体。</span></span><br><span class="line">                                     );</span><br><span class="line">            msg.putUserProperty(<span class="string">&quot;baiLi&quot;</span>, String.valueOf(i));</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">send</span> <span class="operator">=</span> producer.send(msg);</span><br><span class="line">            System.out.printf(i + <span class="string">&quot;.发送消息成功：%s%n&quot;</span>, send);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>sql过滤消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.MessageSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤消息-SQL过滤消费者</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlFilterConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">pushConsumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;SimplePushConsumer&quot;</span>);</span><br><span class="line">        pushConsumer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        pushConsumer.subscribe(<span class="string">&quot;FilterTopic&quot;</span>, MessageSelector.bySql(<span class="string">&quot;(TAGS is not null And TAGS IN (&#x27;TagA&#x27;,&#x27;TagC&#x27;))&quot;</span></span><br><span class="line">        + <span class="string">&quot;and (baiLi is not null and baiLi between 0 and 3)&quot;</span>));</span><br><span class="line">        pushConsumer.setMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;</span><br><span class="line">                list.forEach( n-&gt;&#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;收到消息: %s%n&quot;</span> , <span class="keyword">new</span> <span class="title class_">String</span>(n.getBody()));</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        pushConsumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;SqlFilter Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>SQL92语法：</p><p>RocketMQ只定义了一些基本语法来支持这个特性。我们可以很容易地扩展它。</p><ul><li>数值比较，比如：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；</li><li>字符比较，比如：=，&lt;&gt;，IN；</li><li>IS NULL ，IS NOT NULL；</li><li>逻辑符号 AND，OR，NOT；</li></ul><p>常量支持类型为：</p><ul><li>数值，比如：123，3.1415；</li><li>字符，比如：‘abc’，必须用单引号包裹起来；</li><li>NULL，特殊的常量</li><li>布尔值，TRUE 或 FALSE</li></ul><p>使用注意：</p><ul><li>只有推模式的消费者可以使用SQL过滤。拉模式是用不了的；</li><li>另外消息过滤是在Broker端进行的，提升网络传输性能，但是broker服务会比较繁忙。（consumer将过滤条件推送给broker端）</li></ul><h3 id="5-7-事务消息">5.7.事务消息</h3><p>这个事务消息是RocketMQ提供的一个非常有特色的功能，需要着重理解。</p><h4 id="5-7-1-什么是事务消息">5.7.1.什么是事务消息</h4><p>事务消息是在分布式系统中保证最终一致性的两阶段提交的消息实现。他可以保证本地事务执行与消息发送两个操作的原子性，也就是这两个操作一起成功或者一起失败。</p><h4 id="5-7-2-事务消息的实现机制">5.7.2.事务消息的实现机制</h4><p><img src="https://s2.loli.net/2023/07/04/fH3BKoTR9XJ6lwv.png" alt="img"></p><p>事务消息机制的关键是在发送消息时会将消息转为一个half半消息，并存入RocketMQ内部的一个Topic(RMQ_SYS_TRANS_HALF_TOPIC)，这个Topic对消费者是不可见的。再经过一系列事务检查通过后，再将消息转存到目标Topic，这样对消费者就可见了。</p><h4 id="5-7-3-事务消息的编程模型">5.7.3.事务消息的编程模型</h4><p>事务消息只保证消息发送者的本地事务与发消息这两个操作的原子性，因此，事务消息的示例只涉及到消息发送者，对于消息消费者来说，并没有什么特别的。</p><p>事务消息的关键是在TransactionMQProducer中指定了一个TransactionListener事务监听器，这个事务监听器就是事务消息的关键控制器。</p><ul><li><p>事务消息生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionSendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务消息生产者</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException &#123;</span><br><span class="line">        <span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;TransProducer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.43.137:9876&quot;</span>);</span><br><span class="line">        <span class="comment">//使用executorService异步提交事务状态，从而提高系统的性能和可靠性</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本地事务监听器</span></span><br><span class="line">        <span class="type">TransactionListener</span> <span class="variable">transactionListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionListenerImpl</span>();</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;TagA&quot;</span>,<span class="string">&quot;TagB&quot;</span>,<span class="string">&quot;TagC&quot;</span>,<span class="string">&quot;TagD&quot;</span>,<span class="string">&quot;TagE&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TransactionTopic&quot;</span>,</span><br><span class="line">                    tags[ i % tags.length],</span><br><span class="line">                    (<span class="string">&quot;Transaction_&quot;</span>+ tags[ i % tags.length]).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="type">TransactionSendResult</span> <span class="variable">transactionSendResult</span> <span class="operator">=</span> producer.sendMessageInTransaction(message, <span class="literal">null</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, transactionSendResult);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">//延迟10毫秒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);<span class="comment">//等待broker端回调</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事务消息消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.LocalTransactionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.TransactionListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地事务监听器</span></span><br><span class="line"><span class="comment"> * Created by BaiLi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在提交完事务消息后执行。</span></span><br><span class="line"><span class="comment">     * 返回COMMIT_MESSAGE状态的消息会立即被消费者消费到。</span></span><br><span class="line"><span class="comment">     * 返回ROLLBACK_MESSAGE状态的消息会被丢弃。</span></span><br><span class="line"><span class="comment">     * 返回UNKNOWN状态的消息会由Broker过一段时间再来回查事务的状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message message, Object o)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> message.getTags();</span><br><span class="line">        <span class="comment">//TagA的消息会立即被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagA&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            <span class="comment">//TagB的消息会被丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagB&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            <span class="comment">//其他消息会等待Broker进行事务状态回查。</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在对UNKNOWN状态的消息进行状态回查时执行。</span></span><br><span class="line"><span class="comment">     * 返回COMMIT_MESSAGE状态的消息会立即被消费者消费到。</span></span><br><span class="line"><span class="comment">     * 返回ROLLBACK_MESSAGE状态的消息会被丢弃。</span></span><br><span class="line"><span class="comment">     * 返回UNKNOWN状态的消息会由Broker过一段时间再来回查事务的状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tags</span> <span class="operator">=</span> messageExt.getTags();</span><br><span class="line">        <span class="comment">//TagC的消息过一段时间会被消费者消费到</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagC&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">            <span class="comment">//TagD的消息也会在状态回查时被丢弃掉</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(StringUtils.contains(tags,<span class="string">&quot;TagD&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            <span class="comment">//剩下TagE的消息会在多次状态回查后最终丢弃</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-7-4-事务消息的使用限制">5.7.4.事务消息的使用限制</h4><ul><li>事务消息不支持延迟消息和批量消息。</li><li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的transactionCheckMax参数来修改此限制。如果已经检查某条消息超过N次的话（N = transactionCheckMax）则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。可以通过重写AbstractTransactionCheckListener类来修改这个行为。</li><li>事务性消息可能不止一次被检查或消费。</li></ul><h2 id="6-RocketMQ使用中常见的问题">6.RocketMQ使用中常见的问题</h2><h3 id="6-1-RocketMQ如何保证消息不丢失">6.1.RocketMQ如何保证消息不丢失</h3><p><img src="https://s2.loli.net/2023/07/04/tZrvfW7jOnEw3Do.png" alt="img"></p><p><img src="https://s2.loli.net/2023/07/04/6k3AvinbcmZuMYs.png" alt="img"></p><p>我们将消息流程分为三大部分，每一部分都有可能会丢失数据。</p><ul><li>生产阶段：Producer通过网络将消息发送给Broker，这个发送可能会发生丢失。比如网络延迟不可达等。</li><li>存储阶段：Broker肯定是先把消息放到内存的，然后根据刷盘策略持久化到硬盘中。刚收到Producer的消息，放入内存，但是异常宕机了，导致消息丢失。</li><li>消费阶段：消费失败。比如先提交ack再消费，处理过程中出现异常，该消息就出现了丢失。</li></ul><p>解决方案：</p><ul><li>生产阶段：使用同步发送失败重试机制；异步发送重写回调方法检查发送结果；Ack确认机制。</li><li>存储阶段：同步刷盘机制；集群模式采用同步复制。</li><li>消费阶段：正常消费处理完成才提交ACK；如果处理异常返回重试标识。</li></ul><p>除了上述，在生产阶段与消费者阶段部分消息还需要确保消息顺序消费。</p><h3 id="6-2-RocketMQ的消息持久化机制">6.2.RocketMQ的消息持久化机制</h3><p>RocketMQ的消息持久化机制是指将消息存储在磁盘上，以确保消息能够可靠地存储和检索。RocketMQ 的消息持久化机制涉及到以下三个角色：CommitLog、ConsumeQueue 和 IndexFile。</p><ul><li>CommitLog：消息真正的存储文件，<strong>所有的消息</strong>都存在 CommitLog文件中。</li></ul><p>RocketMQ默认会将消息数据先存储到内存中的一个缓冲区，每当缓冲区中积累了一定量的消息或者一定时间后，就会将缓冲区中的消息批量写入到磁盘上的 CommitLog 文件中。消息在写入 CommitLog 文件后就可以被消费者消费了。</p><p>Commitlog文件的大小固定1G，写满之后生成新的文件，并且采用的是<strong>顺序写</strong>的方式。</p><ul><li>ConsumeQueue：消息消费逻辑队列，类似数据库的索引文件。</li></ul><p>RocketMQ 中每个主题下的每个消息队列都会对应一个 ConsumeQueue。ConsumeQueue存储了消息的offset以及该offset对应的消息在CommitLog文件中的位置信息，便于消费者快速定位并消费消息。</p><p>每个ConsumeQueue文件固定由30万个固定大小20byte的数据块组成；据块的内容包括：msgPhyOffset(8byte，消息在文件中的起始位置)+msgSize(4byte，消息在文件中占用的长度)+msgTagCode(8byte，消息的tag的Hash值)。</p><ul><li>IndexFile：消息索引文件，主要存储消息Key与offset的对应关系，提升消息检索速度。</li></ul><p>如果生产者在发送消息时设置了消息Key，那么RocketMQ会将消息Key值和消息的物理偏移量（offset）存储在IndexFile文件中，这样当消费者需要根据消息Key查询消息时，就可以直接在IndexFile文件中查找对应的offset，然后通过 ConsumeQueue文件快速定位并消费消息。</p><p>IndexFile文件大小固定400M，可以保存2000W个索引。</p><p>三个角色构成的消息存储结构如下：</p><p><img src="https://s2.loli.net/2023/07/04/DA7kBWIJMdNalq4.png" alt="img"></p><p>消息存储过程：</p><p><img src="https://s2.loli.net/2023/07/04/Pi5DA78Zmj1sEML.png" alt="img"></p><h3 id="6-3-RocketMQ如何保证消息顺序">6.3.RocketMQ如何保证消息顺序</h3><p>RocketMQ架构本身是无法保证消息有序的，但是提供了相应的API保证消息有序消费。RocketMQ API利用FIFO先进先出的特性，保证生产者消息有序进入同一队列，消费者在同一队列消费就能达到消息的有序消费。</p><ul><li>使用MessageQueueSelector编写有序消息生产者</li></ul><p>有序消息生产者会按照一定的规则将消息发送到同一个队列中，从而保证同一个队列中的消息是有序的。RocketMQ 并不保证整个主题内所有队列的消息都是按照发送顺序排列的。</p><ul><li>使用MessageListenerOrderly进行顺序消费与之对应的MessageListenerConcurrently并行消费（push模式）</li></ul><p>MessageListenerOrderly是RocketMQ 专门提供的一种顺序消费的接口，它可以让消费者按照消息发送的顺序，一个一个地处理消息。这个接口支持按照消息的重试次数进行顺序消费、订单ID等作为消息键来实现顺序消费、批量消费等操作。</p><p>通过加锁的方式实现（有超时机制），一个队列同时只有一个消费者；并且存在一个定时任务，每隔一段时间就会延长锁的时间，直到整个消息队列全部消费结束。</p><ul><li>消费端自己保证消息顺序消费（pull模式）</li><li>消费者并发消费时设置消费线程为1</li></ul><p>RocketMQ 的消费者可以开启多个消费线程同时消费同一个队列中的消息，如果要保证消息的顺序，需要将消费线程数设置为1。这样，在同一个队列中，每个消息只会被单个消费者线程消费，从而保证消息的顺序性</p><p>rokectMQ消息模型：<img src="https://s2.loli.net/2023/07/04/O8BZnAv5tWyX2a3.png" alt="img"></p><h3 id="6-4-RocketMQ的事务消息原理">6.4.RocketMQ的事务消息原理</h3><p>RocketMQ 的事务消息是一种保证消息可靠性的机制。在RocketMQ中，事务消息的实现原理主要是通过两个发送阶段和一个确认阶段来实现的。</p><ul><li>发送消息的预处理阶段：在发送事务消息之前，RocketMQ 会将消息的状态设置为“Preparing”，并将消息存储到消息存储库中。</li><li>执行本地事务：当预处理阶段完成后，消息发送者需要执行本地事务，并返回执行结果（commit 或 rollback）。</li><li>消息的二次确认阶段：根据本地事务的执行结果，如果是 commit，则 RocketMQ 将消息的状态设置为“Committing”；否则将消息的状态设置为“Rollback”。</li><li>完成事务：最后在消息的消费者消费该消息时，RocketMQ 会根据消息的状态来决定是否提交该消息。如果消息的状态是“Committing”，则直接提交该消息；否则忽略该消息。</li></ul><p>需要注意的是，如果在消息发送的过程中出现异常或者网络故障等问题，RocketMQ 会触发消息回查机制。在回查过程中，RocketMQ 会调用消息发送方提供的回查接口来确认事务的提交状态，从而解决消息投递的不确定性。<br><img src="https://s2.loli.net/2023/07/04/fH3BKoTR9XJ6lwv.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件集合 </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> 图灵课堂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang编程思想2-函数式编程</title>
      <link href="/posts/491079987.html"/>
      <url>/posts/491079987.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数式编程与函数指针">函数式编程与函数指针</h2><ul><li>函数是一等公民：参数、变量、返回值都可以是函数</li><li>高阶函数。例如一个函数的入参还可以是一个函数，其中<strong>函数选项模式</strong>可以参考<a href="https://p2.itc.cn/q_70/images03/20210217/f2e520a8a4014112ab51a454d1bcef52.jpeg">深入浅出 Golang函数选项编程模式</a></li><li>函数→闭包</li></ul><div class="note info flat"><p><strong>扩展：“正统”函数式编程</strong></p><ul><li>不可变性：不能有状态，只有常量和函数</li><li>函数只能有一个参数</li><li>Go语言没有这种严格的规定</li></ul></div><img src="https://s2.loli.net/2022/07/25/fMlYTyJWbEzD6Br.png" alt="微信截图_20220725230821.png" style="zoom:50%;" /><p>代码示例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="comment">//自由变量</span></span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//v是局部变量</span></span><br><span class="line">    sum += v</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“正统”函数编程</span></span><br><span class="line"><span class="keyword">type</span> iAdder <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> (sum <span class="type">int</span>, a iAdder)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder2</span><span class="params">(base <span class="type">int</span>)</span></span> iAdder &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> (<span class="type">int</span>, iAdder) &#123;</span><br><span class="line">    <span class="keyword">return</span> base + v, adder2(base + v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a := adder()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i, <span class="string">&quot;=&gt;&quot;</span>, a(i))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//“正统”函数编程</span></span><br><span class="line">  a2 := adder2(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="type">int</span></span><br><span class="line">    s, a2 = a2(i)</span><br><span class="line">    fmt.Println(i, <span class="string">&quot;=&gt;&quot;</span>, s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go开发工程师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
            <tag> Golang编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang编程思想（一）——面向接口</title>
      <link href="/posts/2854471435.html"/>
      <url>/posts/2854471435.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><code>面向接口编程</code>和<code>面向对象编程</code>相似，但是<strong>侧重点不同</strong>。<code>面向接口编程</code>侧重于<strong>功能的抽象</strong>，<code>面向对象编程</code>侧重于把一个<strong>事物属性</strong>抽象一个合适的模型。譬如，</p><ul><li><p><code>生物</code>（<strong>Creature</strong>），我认为<code>马</code>(<strong>Horse</strong>)和<code>车</code>（<strong>Car</strong>）都能动（<strong>Move</strong>），即使马会呼吸，车子不会，我们都认为马和车是生物，这是<strong>面向接口</strong>。</p></li><li><p>我抽象出一个<code>水果</code>对象，有这么几个属性，<strong>是否硬皮，甜度，水分含量</strong>，那么<code>榴莲</code>（<em>硬壳，很甜，水分含量少，可以煲汤</em>）和<code>苹果</code>（<em>软皮，酸甜，水分含量一般，有果核</em>）都具有这几个属性，并且苹果多抽象出了一个是否有果核的属性，榴莲抽象出了一个可以煲汤的属性，这是苹果和榴莲的异化属性，我们可以通过这个区分水果或者榴莲，但是他们都是水果，这是<strong>面向对象</strong>。</p></li></ul></div><h2 id="面向接口编程">面向接口编程</h2><h3 id="接口的定义和实现">接口的定义和实现</h3><div class="note info flat"><p>Golang中只要实现了接口方法，就认为是实现了这个接口.</p></div><p>定义<code>生物</code>接口，给动力源，就能动(<strong>Move</strong>)。实现这个接口的分别是<code>马</code>（<strong>Horse</strong>）和<code>车</code>(<strong>Car</strong>)。那么我们认为马和车都是生物，我们可以用驱动生物（<strong>drive</strong>）的方法，去让他们动起来</p><div class="tabs" id="接口的定义"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#接口的定义-1">程序入口</button></li><li class="tab"><button type="button" data-href="#接口的定义-2">定义生物接口</button></li><li class="tab"><button type="button" data-href="#接口的定义-3">实现接口的马</button></li><li class="tab"><button type="button" data-href="#接口的定义-4">实现接口的车</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="接口的定义-1"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;learngo/interfaces&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动生物</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drive</span><span class="params">(c interfaces.Creature, powerSource <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(c.Move(powerSource))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  car := interfaces.Car&#123;Color: <span class="string">&quot;白&quot;</span>&#125;</span><br><span class="line">  horse := interfaces.Horse&#123;Color: <span class="string">&quot;黑&quot;</span>, Sound: <span class="string">&quot;咴咴&quot;</span>&#125;</span><br><span class="line">  drive(&amp;car, <span class="string">&quot;汽油&quot;</span>)</span><br><span class="line">  drive(horse, <span class="string">&quot;草&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印接口变量实际的类型</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;This is %T,%v.\n\r&quot;</span>, car, car)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;This is %T,%v.\n\r&quot;</span>, horse, horse)</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的定义-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creature 生物接口</span></span><br><span class="line"><span class="keyword">type</span> Creature <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Move 有能量就会动</span></span><br><span class="line">  Move(powerSource <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的定义-3"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Horse <span class="keyword">struct</span> &#123;</span><br><span class="line">  Color, Sound <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Horse)</span></span> Move(powerSource <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> powerSource != <span class="string">&quot;草&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;只有草才能转换成运动能量！&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;马儿用四条腿跑&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Horse)</span></span> Shout() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">`这匹%s的马在叫：%s`</span>, h.Color, h.Sound)</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的定义-4"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">  Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Car)</span></span> Move(powerSource <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> powerSource != <span class="string">&quot;汽油&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;只有汽油才能转换成运动能量！&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;车子用四个轮子跑&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Lighting() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">`这辆%s车有车头灯，能照明`</span>, c.Color)</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行结果</p><div class="note success flat"><p>车子用四个轮子跑<br>马儿用四条腿跑<br>This is interfaces.Car,{白}.<br>This is interfaces.Horse,{黑 咴咴}.</p></div><h3 id="接口变量的内部结构">接口变量的内部结构</h3><img src="https://s2.loli.net/2022/07/03/h5DaOQ3HLsflwrd.png" alt="微信截图_20220630225035.png" style="zoom:50%;" /><div class="note info flat"><p>接口变量的内部是<strong>实现者的值(或者指针)<strong>和</strong>实现者的类型</strong>。实际使用时，我们用<code>type switch</code>和<code>type assert</code>,区分实现者的实际类型，做出不同的动作。</p></div><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">程序入口</button></li><li class="tab"><button type="button" data-href="#-2">type switch</button></li><li class="tab"><button type="button" data-href="#-3">type assert</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;learngo/interfaces&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动生物</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drive</span><span class="params">(c interfaces.Creature, powerSource <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(c.Move(powerSource))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  car := interfaces.Car&#123;Color: <span class="string">&quot;白&quot;</span>&#125;</span><br><span class="line">  horse := interfaces.Horse&#123;Color: <span class="string">&quot;黑&quot;</span>, Sound: <span class="string">&quot;咴咴&quot;</span>&#125;</span><br><span class="line">  drive(&amp;car, <span class="string">&quot;汽油&quot;</span>)</span><br><span class="line">  drive(horse, <span class="string">&quot;草&quot;</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;============type switch============&quot;</span>)</span><br><span class="line">  inspect(horse)  <span class="comment">//可以传值类型</span></span><br><span class="line">  inspect(&amp;horse) <span class="comment">//也可以传指针</span></span><br><span class="line">  inspect(&amp;car)   <span class="comment">//因为Move方法定义的是指针，所以只能传指针</span></span><br><span class="line">  fmt.Println()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;============type assert============&quot;</span>)</span><br><span class="line">  assert(&amp;horse)</span><br><span class="line">  assert(&amp;car)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type switch</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inspect</span><span class="params">(c interfaces.Creature)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;%T,%v&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n\r&quot;</span>, c, c)</span><br><span class="line">  <span class="keyword">switch</span> v := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> interfaces.Horse: <span class="comment">//实现者的值</span></span><br><span class="line">    v.Shout()</span><br><span class="line">    fmt.Printf(<span class="string">`this is %T %s`</span>, v, v.Sound)</span><br><span class="line">    fmt.Println()</span><br><span class="line">  <span class="keyword">case</span> *interfaces.Horse: <span class="comment">//实现者的指针，如果传入方法的是&amp;horse,这个case不写，则不会有Shout和Sound</span></span><br><span class="line">    v.Shout()</span><br><span class="line">    fmt.Printf(<span class="string">`this is %T %s`</span>, v, v.Sound)</span><br><span class="line">    fmt.Println()</span><br><span class="line">  <span class="keyword">case</span> *interfaces.Car: <span class="comment">//实现者的指针</span></span><br><span class="line">    v.Lighting()</span><br><span class="line">    fmt.Printf(<span class="string">`this is %T %s `</span>, v, v.Color)</span><br><span class="line">    fmt.Println()</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type assert</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(c interfaces.Creature)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> car, ok := c.(*interfaces.Car); ok &#123;</span><br><span class="line">    car.Lighting()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> horse, ok := c.(*interfaces.Horse); ok &#123;</span><br><span class="line">    horse.Shout()</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">============type switch============          </span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;interfaces.Horse,&#123;黑 咴咴&#125;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">这匹黑的马在叫：咴咴</span><br><span class="line">this is interfaces.Horse 咴咴</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;*interfaces.Horse,&amp;&#123;黑 咴咴&#125;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">这匹黑的马在叫：咴咴</span><br><span class="line">this is *interfaces.Horse 咴咴</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;*interfaces.Car,&amp;&#123;白&#125;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">这辆白车有车头灯，能照明</span><br><span class="line">this is *interfaces.Car 白</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">============type assert============</span><br><span class="line">这匹黑的马在叫：咴咴</span><br><span class="line"></span><br><span class="line">这辆白车有车头灯，能照明</span><br></pre></td></tr></table></figure><h3 id="接口的组合">接口的组合</h3><div class="note info flat"><p>一个类型可以实现多个接口</p></div><div class="tabs" id="接口的组合"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#接口的组合-1">程序入口</button></li><li class="tab"><button type="button" data-href="#接口的组合-2">定义生物接口</button></li><li class="tab"><button type="button" data-href="#接口的组合-3">定义哺乳动物接口</button></li><li class="tab"><button type="button" data-href="#接口的组合-4">定义动物接口</button></li><li class="tab"><button type="button" data-href="#接口的组合-5">实现接口的马</button></li><li class="tab"><button type="button" data-href="#接口的组合-6">实现接口的车</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="接口的组合-1"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;learngo/interfaces&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动生物</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">drive</span><span class="params">(c interfaces.Creature, powerSource <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(c.Move(powerSource))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哺乳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">feed</span><span class="params">(m interfaces.Mammal)</span></span> &#123;</span><br><span class="line">  m.Suckle()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  car := interfaces.Car&#123;Color: <span class="string">&quot;白&quot;</span>&#125;</span><br><span class="line">  horse := interfaces.Horse&#123;Color: <span class="string">&quot;黑&quot;</span>, Sound: <span class="string">&quot;咴咴&quot;</span>&#125;</span><br><span class="line">  drive(&amp;car, <span class="string">&quot;汽油&quot;</span>)</span><br><span class="line">  drive(horse, <span class="string">&quot;草&quot;</span>)</span><br><span class="line">  <span class="comment">//哺乳动物行为</span></span><br><span class="line">  feed(&amp;horse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的组合-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creature 生物接口</span></span><br><span class="line"><span class="keyword">type</span> Creature <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Move 有能量就会动</span></span><br><span class="line">  Move(powerSource <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的组合-3"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mammal 哺乳动物接口</span></span><br><span class="line"><span class="keyword">type</span> Mammal <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Suckle 哺乳</span></span><br><span class="line">  Suckle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的组合-4"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合接口</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">  Creature</span><br><span class="line">  Mammal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的组合-5"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Horse <span class="keyword">struct</span> &#123;</span><br><span class="line">  Color, Sound <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Horse)</span></span> Move(powerSource <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> powerSource != <span class="string">&quot;草&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;只有草才能转换成运动能量！&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;马儿用四条腿跑&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Horse)</span></span> Shout() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">`这匹%s的马在叫：%s`</span>, h.Color, h.Sound)</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Horse)</span></span> Suckle() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;给小马喂奶...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="接口的组合-6"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaces</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">  Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Car)</span></span> Move(powerSource <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> powerSource != <span class="string">&quot;汽油&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;只有汽油才能转换成运动能量！&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;车子用四个轮子跑&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span></span> Lighting() &#123;</span><br><span class="line">  fmt.Printf(<span class="string">`这辆%s车有车头灯，能照明`</span>, c.Color)</span><br><span class="line">  fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>运行结果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">车子用四个轮子跑</span><br><span class="line">马儿用四条腿跑</span><br><span class="line">给小马喂奶... </span><br></pre></td></tr></table></figure><p>上面的Horse实现了Animal接口</p><p><img src="https://s2.loli.net/2022/07/05/5BXYxgFOuhU8RWb.png" alt="微信截图_20220705231918.png"></p>]]></content>
      
      
      <categories>
          
          <category> Go开发工程师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
            <tag> Golang编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang基础入门(四)——面向对象</title>
      <link href="/posts/3459106423.html"/>
      <url>/posts/3459106423.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p><code>Golang</code>仅支持封装，不支持继承和多态</p></div><h2 id="结构体的定义和变量声明">结构体的定义和变量声明</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TreeNode 结构体定义</span></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  Value       <span class="type">int</span></span><br><span class="line">  Left, Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print 成员方法，值传递，打印树节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node TreeNode)</span></span> Print() &#123;</span><br><span class="line">  fmt.Print(node.Value, <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetValue 成员方法，引用传递，能改变原有树节点的值。此处是设置值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span></span> SetValue(value <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="comment">//Go语言中，nil指针可以调用方法，根据需要判空</span></span><br><span class="line">  <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  node.Value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse 树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *TreeNode)</span></span> Traverse() &#123;</span><br><span class="line">  <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  node.Left.Traverse()</span><br><span class="line">  node.Print()</span><br><span class="line">  node.Right.Traverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GO语言没有构造函数，可以使用工厂函数代替</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createNode</span><span class="params">(value <span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;TreeNode&#123;Value: value&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//自定义结构体变量的声明</span></span><br><span class="line">  <span class="keyword">var</span> root TreeNode</span><br><span class="line">  root = TreeNode&#123;Value: <span class="number">3</span>&#125;</span><br><span class="line">  root.Left = &amp;TreeNode&#123;&#125;</span><br><span class="line">  <span class="comment">//省略字段名的写法</span></span><br><span class="line">  root.Right = &amp;TreeNode&#123;<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">  <span class="comment">//也可以使用new新建，一般不这么用</span></span><br><span class="line">  root.Right.Left = <span class="built_in">new</span>(TreeNode)</span><br><span class="line">  root.Left.Right = createNode(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Go语言中，指针可以调用方法</span></span><br><span class="line">  pRoot := &amp;root</span><br><span class="line">  pRoot.Print()</span><br><span class="line">  root.Left.Right.SetValue(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;\r\n&gt;&gt;&gt;树遍历开始...&quot;</span>)</span><br><span class="line">  root.Traverse()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行完之后我们就构建出了这样的树</p><img src="https://s2.loli.net/2022/06/20/kflyhJU7CVK12Oo.png" alt="微信截图_20220620210520.png" style="zoom: 50%;" /><p>运行结果</p><div class="note success flat"><p>3</p><p>&gt;&gt;&gt;树遍历开始…</p><p>0 2 3 4 5</p></div><p><strong>什么时候使用值接收者 / 指针接收者</strong></p><ul><li>值接收者是Golang`特有</li><li>要改变内容使用指针接收者</li><li>结构过大考虑使用指针接收者</li><li>一致性：如有指针接收者，最好都是指针接收者、</li></ul><h2 id="封装">封装</h2><ul><li><code>Golang</code>中名字一般使用<strong>驼峰命名</strong>(<em>CamelCase</em>)</li><li>首字母大写（大驼峰）：<code>public</code></li><li>首字母小写（小驼峰）：<code>private</code></li><li><code>public</code> / <code>private</code>都是针对<code>包</code>来说的</li></ul><h2 id="包">包</h2><ul><li>每个目录一个包</li><li>main包包含可执行入口</li><li>为结构定义的方法必须放在同一个包内</li><li>可以是不同的文件</li></ul><p>前面的代码重新分包后</p><div class="tabs" id="写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#写法-1">entry\entry.go</button></li><li class="tab"><button type="button" data-href="#写法-2">node.go</button></li><li class="tab"><button type="button" data-href="#写法-3">tranversal.go放树遍历的方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="写法-1"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;learngo/tree&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//自定义结构体变量的声明</span></span><br><span class="line">  <span class="keyword">var</span> root tree.Node</span><br><span class="line">  root = tree.Node&#123;Value: <span class="number">3</span>&#125;</span><br><span class="line">  root.Left = &amp;tree.Node&#123;&#125;</span><br><span class="line">  <span class="comment">//省略字段名的写法</span></span><br><span class="line">  root.Right = &amp;tree.Node&#123;<span class="number">5</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">  <span class="comment">//也可以使用new新建，一般不这么用</span></span><br><span class="line">  root.Right.Left = <span class="built_in">new</span>(tree.Node)</span><br><span class="line">  root.Left.Right = tree.CreateNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Go语言中，指针可以调用方法</span></span><br><span class="line">  pRoot := &amp;root</span><br><span class="line">  pRoot.Print()</span><br><span class="line">  root.Right.Left.SetValue(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;\r\n&gt;&gt;&gt;树遍历开始...&quot;</span>)</span><br><span class="line">  root.Traverse()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node 结构体定义</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  Value       <span class="type">int</span></span><br><span class="line">  Left, Right *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print 成员方法，值传递，打印树节点的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node Node)</span></span> Print() &#123;</span><br><span class="line">  fmt.Print(node.Value, <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetValue 成员方法，引用传递，能改变原有树节点的值。此处是设置值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span></span> SetValue(value <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="comment">//Go语言中，nil指针可以调用方法，根据需要判空</span></span><br><span class="line">  <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  node.Value = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateNode GO语言没有构造函数，可以使用工厂函数代替</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateNode</span><span class="params">(value <span class="type">int</span>)</span></span> *Node &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Node&#123;Value: value&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-3"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse 树的中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Node)</span></span> Traverse() &#123;</span><br><span class="line">  <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  node.Left.Traverse()</span><br><span class="line">  node.Print()</span><br><span class="line">  node.Right.Traverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="扩展已有类型">扩展已有类型</h2><div class="tabs" id="写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#写法-1">组合</button></li><li class="tab"><button type="button" data-href="#写法-2">内嵌（推荐）</button></li><li class="tab"><button type="button" data-href="#写法-3">别名（最简单）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="写法-1"><div class="note info flat"><p>使用<strong>组合</strong>的方式，扩展后续遍历的方法。可以发现，<code>MyTreeNode</code>并不能使用<code>tree.Node</code>的中序遍历方法</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;learngo/tree&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MyTreeNode 组合</span></span><br><span class="line"><span class="keyword">type</span> MyTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  node *tree.Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展:后序遍历,先左右，后根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *MyTreeNode)</span></span> postOrder() &#123;</span><br><span class="line">  <span class="keyword">if</span> myNode == <span class="literal">nil</span> || myNode.node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  left := MyTreeNode&#123;myNode.node.Left&#125;</span><br><span class="line">  left.postOrder()</span><br><span class="line">  right := MyTreeNode&#123;myNode.node.Right&#125;</span><br><span class="line">  right.postOrder()</span><br><span class="line">  myNode.node.Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  root := MyTreeNode&#123;&amp;tree.Node&#123;Value: <span class="number">3</span>&#125;&#125;</span><br><span class="line">  root.node.Left = tree.CreateNode(<span class="number">0</span>)</span><br><span class="line">  root.node.Right = tree.CreateNode(<span class="number">5</span>)</span><br><span class="line">  root.node.Left.Right = tree.CreateNode(<span class="number">2</span>)</span><br><span class="line">  root.node.Right.Left = tree.CreateNode(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  root.postOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>2 0 4 5 3</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-2"><div class="note info flat"><p><code>Golang</code>没有继承（后续代码会证明这一点），<code>内嵌</code>和<code>继承</code>效果相似，但是只能使用<strong>被扩展类型</strong>公有的字段和方法</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;learngo/tree&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyTreeNode 内嵌的方式，直接省略变量名，</span></span><br><span class="line"><span class="comment">//但实际还会有MyTreeNode.Node这个字段，</span></span><br><span class="line"><span class="comment">//而且可以直接使用tree.Node里的字段和方法名</span></span><br><span class="line"><span class="keyword">type</span> MyTreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  *tree.Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展:后序遍历,先左右，后根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNode *MyTreeNode)</span></span> postOrder() &#123;</span><br><span class="line">  <span class="comment">//省略变量名之后，实际还是会有MyTreeNode.Node这个字段</span></span><br><span class="line">  <span class="keyword">if</span> myNode == <span class="literal">nil</span> || myNode.Node == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//可以直接使用tree.Node里的方法和字段</span></span><br><span class="line">  left := MyTreeNode&#123;myNode.Left&#125;</span><br><span class="line">  left.postOrder()</span><br><span class="line">  right := MyTreeNode&#123;myNode.Right&#125;</span><br><span class="line">  right.postOrder()</span><br><span class="line">  <span class="comment">//调用tree.Node里的方法</span></span><br><span class="line">  myNode.Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShadowedMethod 遮蔽同名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*MyTreeNode)</span></span> ShadowedMethod() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;This is MyTreeNode&#x27;s method&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  root := MyTreeNode&#123;&amp;tree.Node&#123;Value: <span class="number">3</span>&#125;&#125;</span><br><span class="line">  root.Left = tree.CreateNode(<span class="number">0</span>)</span><br><span class="line">  root.Right = tree.CreateNode(<span class="number">5</span>)</span><br><span class="line">  root.Left.Right = tree.CreateNode(<span class="number">2</span>)</span><br><span class="line">  root.Right.Left = tree.CreateNode(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Print(<span class="string">&quot;MyTreeNode postOrder: &quot;</span>)</span><br><span class="line">  root.postOrder()</span><br><span class="line">  fmt.Println()</span><br><span class="line">  fmt.Print(<span class="string">&quot;MyTreeNode use tree.Node&#x27;s tranversal method: &quot;</span>)</span><br><span class="line">  root.Traverse()</span><br><span class="line">  fmt.Println()</span><br><span class="line"></span><br><span class="line">  fmt.Println()</span><br><span class="line">  fmt.Println(<span class="string">&quot;Shadows-method shows&quot;</span>)</span><br><span class="line">  root.ShadowedMethod()</span><br><span class="line">  root.Node.ShadowedMethod() <span class="comment">//tree.Node的方法没有被覆盖掉</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//没有子类的用法，下面的语句会有编译错误</span></span><br><span class="line">  <span class="comment">//var q tree.Node = root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note success flat"><p>MyTreeNode postOrder: 2 0 4 5 3<br>MyTreeNode use tree.Node’s tranversal method: 0 2 3 4 5</p><p>Shadows-method shows<br>This is MyTreeNode’s method<br>This is tree.Node’s method</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-3"><div class="note info flat"><p>别名实现<code>继承</code>效果，可以使用<strong>被扩展类的结构</strong>，不能使用它的<strong>方法</strong></p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue 使用别名的方法实现已有类型扩展</span></span><br><span class="line"><span class="keyword">type</span> Queue []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> push(val <span class="type">int</span>) &#123;</span><br><span class="line">  *q = <span class="built_in">append</span>(*q, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> pop() <span class="type">int</span> &#123;</span><br><span class="line">  head := (*q)[<span class="number">0</span>]</span><br><span class="line">  *q = (*q)[<span class="number">1</span>:]</span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> isEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  q := Queue&#123;&#125;</span><br><span class="line">  q.push(<span class="number">1</span>)</span><br><span class="line">  q.push(<span class="number">2</span>)</span><br><span class="line">  q.push(<span class="number">3</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;After push...&quot;</span>)</span><br><span class="line">  fmt.Println(q)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;Popping&quot;</span>)</span><br><span class="line">  fmt.Println(q.pop())</span><br><span class="line">  fmt.Println(q.pop())</span><br><span class="line">  fmt.Println(q.isEmpty())</span><br><span class="line">  fmt.Println(q.pop())</span><br><span class="line">  fmt.Println(q.isEmpty())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>After push…<br>[1 2 3]<br>Popping<br>1<br>2<br>false<br>3<br>true</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Go开发工程师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
            <tag> Golang基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang基础入门(三)——内建容器</title>
      <link href="/posts/1108898725.html"/>
      <url>/posts/1108898725.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组">数组</h2><h3 id="数组的定义">数组的定义</h3><p>数量写在类型之前</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="type">int</span>                 <span class="comment">//初始化数组</span></span><br><span class="line">  arr2 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;         <span class="comment">//初始化并给值</span></span><br><span class="line">  arr3 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>&#125; <span class="comment">//自动判断长度</span></span><br><span class="line">  <span class="keyword">var</span> grid [<span class="number">4</span>][<span class="number">5</span>]<span class="type">int</span>              <span class="comment">//二维数组，多维数组类似写法</span></span><br><span class="line">  fmt.Println(arr1, arr2, arr3)</span><br><span class="line">  fmt.Println(grid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>[0 0 0 0 0] [1 2 3] [1 2 3 4 6]<br>[[0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0] [0 0 0 0 0]]</p></div><h3 id="数组遍历">数组遍历</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr2 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;         <span class="comment">//初始化并给值</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//传统写法</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr2); i++ &#123;</span><br><span class="line">    fmt.Println(arr2[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//range,i为索引，v为值，range可以用在map</span></span><br><span class="line">  <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr2 &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>数组是<code>值类型</code>，作为函数入参时，也是<strong>值传递</strong>。<code>[10]int</code>和<code>[20]int</code>是不同的类型</p></div><h2 id="切片（Slice）">切片（Slice）</h2><h3 id="切片的定义和初始化">切片的定义和初始化</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//1.声明一个未定义大小的数组来定义切片</span></span><br><span class="line">  <span class="keyword">var</span> slice []<span class="type">int</span></span><br><span class="line">  <span class="comment">//[]</span></span><br><span class="line">  fmt.Println(slice)</span><br><span class="line">  <span class="comment">//2.使用make()函数定义切片</span></span><br><span class="line">  length := <span class="number">4</span></span><br><span class="line">  <span class="comment">//2.1.指定长度</span></span><br><span class="line">  slice1 := <span class="built_in">make</span>([]<span class="type">int</span>, length)</span><br><span class="line">  <span class="comment">//[0 0 0 0]</span></span><br><span class="line">  fmt.Println(slice1)</span><br><span class="line">  <span class="comment">//2.2.指定长度和容量</span></span><br><span class="line">  capacity := <span class="number">8</span></span><br><span class="line">  slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, length, capacity)</span><br><span class="line">  <span class="comment">//[0 0 0 0]</span></span><br><span class="line">  fmt.Println(slice2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化切片，切片是数组的抽象体现</span></span><br><span class="line">  arr := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">  <span class="comment">//全窗口</span></span><br><span class="line">  <span class="comment">//[1 2 3 4 5 6 8]</span></span><br><span class="line">  fmt.Println(arr[:])</span><br><span class="line">  <span class="comment">//前片段，切片是前闭后开的区间，索引从0开始</span></span><br><span class="line">  <span class="comment">//[1 2 3 4 5 6]</span></span><br><span class="line">  fmt.Println(arr[:<span class="built_in">len</span>(arr)<span class="number">-1</span>])</span><br><span class="line">  <span class="comment">//后片段</span></span><br><span class="line">  <span class="comment">//[3 4 5 6 8]</span></span><br><span class="line">  fmt.Println(arr[<span class="number">2</span>:])</span><br><span class="line">  <span class="comment">//中间截取</span></span><br><span class="line">  <span class="comment">//[3 4]</span></span><br><span class="line">  fmt.Println(arr[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p><strong>数组</strong> 和 **切片（Slice）**的区别在于，定义切片不需要指定长度size，如果给定了size，那么这个变量属于 <strong>数组</strong></p></div><h3 id="切片概念和原理">切片概念和原理</h3><div class="note info flat"><p><strong>切片（slice）<strong>是对</strong>数组</strong>的抽象。可以看成是在数组上滑动的窗口（view）</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Before update...&quot;</span>)</span><br><span class="line">  fmt.Println(arr)</span><br><span class="line">  fmt.Println(<span class="string">&quot;After update...&quot;</span>)</span><br><span class="line">  updateSlice(arr[<span class="number">2</span>:])</span><br><span class="line">  fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把切片首位改成0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(slice []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  slice[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note success flat"><p>Before update…<br>[0 1 2 3 4 5 6]<br>After update…<br>[0 1 100 3 4 5 6]</p></div><h3 id="切片的拓展">切片的拓展</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">  s1 := arr[<span class="number">2</span>:<span class="number">6</span>] <span class="comment">//[2 3 4 5]</span></span><br><span class="line">  fmt.Println(s1)</span><br><span class="line">  <span class="comment">//Reslice 子切片</span></span><br><span class="line">  s2 := s1[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">//[4 5]</span></span><br><span class="line">  fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>s1的值为[2 3 4 5]，s2的值为[4 5]</p></li><li><p>slice可以向后扩展，不可以向前扩展</p></li><li><p>s[i]不可以超越len(s)，所以s向后扩展不可以超越底层数组的cap(s)</p></li></ul><p><img src="https://s2.loli.net/2022/06/10/Z6Ivpign8kKAtoU.png" alt="微信截图_20220610232701.png"></p><h3 id="切面的操作">切面的操作</h3><h4 id="添加元素（append）">添加元素（append）</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  arr := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">  s1 := arr[<span class="number">2</span>:<span class="number">6</span>] <span class="comment">//[2 3 4 5]</span></span><br><span class="line">  s2 := s1[<span class="number">3</span>:<span class="number">5</span>]  <span class="comment">//[5 6]</span></span><br><span class="line">  s3 := <span class="built_in">append</span>(s2, <span class="number">10</span>)</span><br><span class="line">  s4 := <span class="built_in">append</span>(s3, <span class="number">11</span>)</span><br><span class="line">  s5 := <span class="built_in">append</span>(s4, <span class="number">12</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;s3,s4,s5 = &quot;</span>, s3, s4, s5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>s3,s4,s5 =  [5 6 10] [5 6 10 11] [5 6 10 11 12]</p><p>arr =  [0 1 2 3 4 5 6 10]</p></div><ul><li><code>append</code>在操作Slice时，如果没有超出原数组 <code>arr</code>的容量<code>cap</code>，则会覆盖后续的元素，<u><strong>反之，则会重新分配更大的底层数组。</strong></u></li><li><code>append</code>由于是值传递的关系，必须接收 <code>返回值</code></li></ul><h4 id="其他操作">其他操作</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s1 := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">  s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Copy Slice...&quot;</span>)</span><br><span class="line">  <span class="built_in">copy</span>(s2, s1)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;slice len=%v,cap=%v,s2=%v \n\r&quot;</span>, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;Deleting from slice...&quot;</span>)</span><br><span class="line">  s3 := <span class="built_in">append</span>(s2[:<span class="number">3</span>], s2[<span class="number">4</span>:]...) <span class="comment">//切片可变参数使用...</span></span><br><span class="line">  fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;Popping from front...&quot;</span>)</span><br><span class="line">  s4 := s3[<span class="number">1</span>:]</span><br><span class="line">  fmt.Println(s4)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;Popping from back...&quot;</span>)</span><br><span class="line">  s5 := s4[:<span class="built_in">len</span>(s4)<span class="number">-1</span>]</span><br><span class="line">  fmt.Println(s5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>Copy Slice…<br>slice len=8,cap=8,s2=[2 4 6 8 0 0 0 0]<br>Deleting from slice…<br>[2 4 6 0 0 0 0]<br>Popping from front…<br>[4 6 0 0 0 0]<br>Popping from back…<br>[4 6 0 0 0]</p></div><h2 id="Map容器">Map容器</h2><h3 id="Map基本操作">Map基本操作</h3><div class="note danger flat"><p>使用<code>var m2 map[string]int</code>定义的 <code>map</code>，不能进行 <u><strong>赋值</strong></u>操作</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//定义</span></span><br><span class="line">  m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Eury&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:  <span class="string">&quot;17&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(m)</span><br><span class="line">  m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">//有初始化[]</span></span><br><span class="line">  fmt.Println(m1)</span><br><span class="line">  <span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// nil</span></span><br><span class="line">  fmt.Println(m2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//操作</span></span><br><span class="line">  <span class="comment">//取值</span></span><br><span class="line">  fmt.Println(m[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  m1[<span class="string">&quot;age&quot;</span>] = <span class="number">19</span></span><br><span class="line">  <span class="comment">//m2[&quot;age&quot;] = 20 // nil的map不能赋值</span></span><br><span class="line">  fmt.Println(m1, m2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否存在</span></span><br><span class="line">  name, ok := m[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;value=%s，ok=%v\n&quot;</span>, name, ok)</span><br><span class="line">    <span class="comment">//存在则删除</span></span><br><span class="line">    <span class="built_in">delete</span>(m, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;after delete,%q\n&quot;</span>, m[<span class="string">&quot;name&quot;</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;nil value&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map例题">Map例题</h3><div class="note blue icon-padding flat"><i class="note-icon fa fa-question-circle"></i><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">&gt;&gt;&gt;LeetCode传送门</a></p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfNonRepeatingSubStr</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  lastOccurred := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>) <span class="comment">//存放每个字符最后出现的位置</span></span><br><span class="line">  <span class="keyword">var</span> start, maxLen <span class="type">int</span></span><br><span class="line">  <span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="type">rune</span>(s) &#123;</span><br><span class="line">    <span class="comment">//两种情况</span></span><br><span class="line">    <span class="comment">//1.lastOccurred[ch]&lt;start或者没有出现过，无需操作</span></span><br><span class="line">    <span class="comment">//2.lastOccrred[ch]&gt;=start，更新start为start=lastOccrred[ch]+1</span></span><br><span class="line">    <span class="comment">//注：这里必须判断map中是否有值，Golang中的zero value,在map中获取不到值时，lastI参与运算会变成0</span></span><br><span class="line">    <span class="keyword">if</span> lastI, ok := lastOccurred[ch]; ok &amp;&amp; lastI &gt;= start &#123;</span><br><span class="line">      start = lastI + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> currLen := i - start + <span class="number">1</span>; currLen &gt; maxLen &#123;</span><br><span class="line">      maxLen = currLen</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后更新lastOccurred[ch]位置</span></span><br><span class="line">    lastOccurred[ch] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(lengthOfNonRepeatingSubStr(<span class="string">&quot;我和我的祖国&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note success flat"><p>5</p></div>]]></content>
      
      
      <categories>
          
          <category> Go开发工程师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
            <tag> Golang基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang基础入门(二)</title>
      <link href="/posts/1578139801.html"/>
      <url>/posts/1578139801.html</url>
      
        <content type="html"><![CDATA[<h3 id="条件语句">条件语句</h3><h4 id="if语句（-swig￼16-）"><strong>if</strong>语句（<mark class="hl-label red">if后面不接括号</mark> ）</h4><div class="tabs" id="if写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#if写法-1">写法1</button></li><li class="tab"><button type="button" data-href="#if写法-2">写法2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="if写法-1"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile1</span><span class="params">(filename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//Go语言可以返回多个变量值</span></span><br><span class="line">  contents, err := ioutil.ReadFile(filename)</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="comment">//if不加括号</span></span><br><span class="line">    fmt.Println(contents)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println( err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="if写法-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile2</span><span class="params">(filename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//类似于for的写法，但是contents和err只能在if这个代码块里使用</span></span><br><span class="line">  <span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(contents)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="switch语句">switch语句</h4><div class="tabs" id="写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#写法-1">写法 1</button></li><li class="tab"><button type="button" data-href="#写法-2">写法 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="写法-1"><div class="note info flat"><p><code>switch</code>自动<code>break</code>，不想<code>break</code>需要使用<code>fallthrough</code></p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个整数的四则运算</span></span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, operator <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> result <span class="type">int</span></span><br><span class="line">     <span class="keyword">switch</span> operator &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">       result = a + b</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">       result = a - b</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">       result = a * b</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">       result = a / b</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">&quot;unrecognized operator &quot;</span> + operator)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Printf(<span class="string">&quot;final result is %d\n&quot;</span>, result)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-2"><div class="note info flat"><p><code>switch</code>可以没有表达式，<code>case</code>里面可以使用<mark class="hl-label red">判断条件</mark></p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grade</span><span class="params">(score <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">     grade := <span class="string">&quot;&quot;</span></span><br><span class="line">     <span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> score &lt; <span class="number">60</span> &amp;&amp; score &gt; <span class="number">0</span>: <span class="comment">//大于0小于60</span></span><br><span class="line">       grade = <span class="string">&quot;F&quot;</span></span><br><span class="line">     <span class="keyword">case</span> score &lt; <span class="number">70</span>: <span class="comment">//大于等于60小于70</span></span><br><span class="line">       grade = <span class="string">&quot;D&quot;</span></span><br><span class="line">     <span class="keyword">case</span> score &lt; <span class="number">80</span>: <span class="comment">//大于等于70小于80</span></span><br><span class="line">       grade = <span class="string">&quot;C&quot;</span></span><br><span class="line">     <span class="keyword">case</span> score &lt; <span class="number">90</span>: <span class="comment">//大于等于80小于90</span></span><br><span class="line">       grade = <span class="string">&quot;B&quot;</span></span><br><span class="line">     <span class="keyword">case</span> score &lt; <span class="number">100</span>: <span class="comment">//大于等于90小于100</span></span><br><span class="line">       grade = <span class="string">&quot;A&quot;</span></span><br><span class="line">     <span class="keyword">case</span> score == <span class="number">100</span>: <span class="comment">//满分</span></span><br><span class="line">    grade = <span class="string">&quot;S&quot;</span></span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">&quot;illegal score &quot;</span> + <span class="type">string</span>(score))</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> grade</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="for循环">for循环</h3><div class="note info flat"><p><code>Golang</code>只有<code>for</code>，没有<code>while</code>，<code>do-while</code>之类的语句</p></div><div class="tabs" id="写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#写法-1">写法 1</button></li><li class="tab"><button type="button" data-href="#写法-2">写法 2</button></li><li class="tab"><button type="button" data-href="#写法-3">写法 3</button></li><li class="tab"><button type="button" data-href="#写法-4">写法 4</button></li><li class="tab"><button type="button" data-href="#写法-5">for-range的写法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="写法-1"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulator</span><span class="params">()</span></span> &#123;</span><br><span class="line">  result := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">    result += i</span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(</span><br><span class="line">      convertToBin(<span class="number">5</span>),</span><br><span class="line">      convertToBin(<span class="number">13</span>),</span><br><span class="line">      convertToBin(<span class="number">8472819</span>),</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整数转换成二进制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToBin</span><span class="params">(n <span class="type">int</span>)</span></span> (result <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n = n / <span class="number">2</span> &#123;</span><br><span class="line">      result = strconv.Itoa(n%<span class="number">2</span>) + result</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><div class="note success simple"><p>101 1101 100000010100100011110011</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-3"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逐行打印文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFile</span><span class="params">(filename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  in, err := os.Open(filename)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  scanner := bufio.NewScanner(in)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    fmt.Println(scanner.Text())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-4"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//死循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forever</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-5"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumArgs</span><span class="params">(arr ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 第一个是索引，第二个是值</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    sum += v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="函数">函数</h3><h4 id="基础用法">基础用法</h4><p><code>Go</code>函数定义结构如下图所示</p><p><img src="https://s2.loli.net/2022/05/31/oL31afZ4Jtiuj7C.png" alt="image.png"></p><div class="note info flat"><p><code>Go</code>里面函数可以返回多个值</p></div><div class="tabs" id="写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#写法-1">写法 1</button></li><li class="tab"><button type="button" data-href="#写法-2">写法 2</button></li><li class="tab"><button type="button" data-href="#写法-3">抛出异常</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="写法-1"><div class="note warning modern"><p>函数返回多个值并声明变量名，只使用在简单的函数返回</p></div><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整数除法,可以直接定义函数返回变量名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="type">int</span>)</span></span> (q, r <span class="type">int</span>) &#123;</span><br><span class="line">  q = a / b</span><br><span class="line">  r = a % b</span><br><span class="line">  <span class="keyword">return</span> q, r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两数交换，值定义函数返回变量类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-3"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个整数的四则运算,返回整数和异常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval2</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>, operator <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> operator &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;unrecognized operator %s&quot;</span>, operator)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="高级用法">高级用法</h4><div class="note info flat"><p><code>Go</code>语言中，函数可以当成<strong>入参/返参</strong>，函数支持<strong>可变参数</strong>，没有~~<strong>默认参数</strong><s>，</s><strong>可选参数</strong><s>，</s><strong>函数重载</strong><s>，</s><strong>操作符重载</strong>~~的概念，也没有花哨的<code>lambda</code>用法</p></div><div class="tabs" id="函数用法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#函数用法-1">函数式编程</button></li><li class="tab"><button type="button" data-href="#函数用法-2">可变参数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="函数用法-1"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用函数调用函数</span></span><br><span class="line"><span class="comment">//函数是一等公民，可以作为入参，出参等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="type">int</span>, <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>), a, b <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    pointer := reflect.ValueOf(op).Pointer()</span><br><span class="line">    opName := runtime.FuncForPC(pointer).Name()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Calling function %s with args[%d,%d]\n&quot;</span>, opName, a, b)</span><br><span class="line">    <span class="comment">//对于不想获取的参数可以用下划线代替</span></span><br><span class="line">    _, res := op(a, b)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(apply(swap, <span class="number">11</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment">//匿名函数的写法</span></span><br><span class="line">    fmt.Println(apply(<span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> b, a</span><br><span class="line">    &#125;, <span class="number">11</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><div class="note success flat"><p>Calling function main.swap with args[11,2]</p><p>11</p><p>Calling function main.main.func1 with args[11,2]</p><p>11</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="函数用法-2"><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumArgs</span><span class="params">(arr ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 第一个是索引，第二个是值</span></span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    sum += v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="指针">指针</h3><div class="note info flat"><p>Golang的指针不能进行运算，所以Golang的指针相对简单</p></div><h4 id="指针示例">指针示例</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">2</span> <span class="comment">//初始化a</span></span><br><span class="line">  <span class="keyword">var</span> pa *<span class="type">int</span> = &amp;a <span class="comment">//取a的指针地址</span></span><br><span class="line">  *pa = <span class="number">3</span> <span class="comment">//修改a的值</span></span><br><span class="line">  fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><div class="note success flat"><p>3</p></div><h4 id="参数传递">参数传递</h4><div class="note orange icon-padding flat"><i class="note-icon fa fa-solid fa-circle-question"></i><p><code>值传递</code>还是<code>引用传递</code>？</p></div><p>Golang只有<code>值传递</code>，需要引用传递只能使用指针。验证代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  a, b = b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">  swap(a, b)</span><br><span class="line">  fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><div class="note success flat"><p>1 2</p></div><p>如果需要将<code>a</code>，<code>b</code>的值互换，可以参照<a href="#%E5%87%BD%E6%95%B0">函数</a>中的<code>swap</code>写法或使用<code>指针</code></p>]]></content>
      
      
      <categories>
          
          <category> Go开发工程师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
            <tag> Golang基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang基础入门(一)</title>
      <link href="/posts/4045530488.html"/>
      <url>/posts/4045530488.html</url>
      
        <content type="html"><![CDATA[<h3 id="变量定义">变量定义</h3><h4 id="变量一旦定义就有默认值">变量一旦定义就有<strong>默认值</strong></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableZeroValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="type">string</span></span><br><span class="line">  <span class="comment">//打印空字符串可以用%q</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d,%q&quot;</span>, a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><span id="more"></span><blockquote><p>0,“”</p></blockquote><h4 id="变量赋初值">变量赋初值</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableInitialValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">1</span>, <span class="number">3</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="type">string</span> = <span class="string">&quot;Hello Go!&quot;</span></span><br><span class="line">  fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>1 3 Hello Go!</p></blockquote><h4 id="自动检测变量类型">自动检测变量类型</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableTypeDeduction</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b, c, d = <span class="number">1</span>, <span class="number">3</span>, <span class="literal">true</span>, <span class="string">&quot;def&quot;</span></span><br><span class="line">  fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简洁写法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableShorter</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//首次出现可以使用冒号声明变量并赋值</span></span><br><span class="line">  a, b, c, d := <span class="number">1</span>, <span class="number">3</span>, <span class="literal">true</span>, <span class="string">&quot;def&quot;</span></span><br><span class="line">  <span class="comment">//之后赋值不可以再用冒号</span></span><br><span class="line">  b = <span class="number">5</span></span><br><span class="line">  fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>1 3 true def</p><p>1 5 true def</p></blockquote><h4 id="包变量">包变量</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  aa = <span class="number">11</span></span><br><span class="line">  bb = <span class="string">&quot;def&quot;</span></span><br><span class="line">  cc = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(aa,bb,cc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>11 def true</p></blockquote><h3 id="内建变量">内建变量</h3><ul><li><p><code>bool</code>, <code>string</code></p></li><li><p><code>(u)int</code>, <code>(u)int8</code>,<code> (u)int16</code>, <code>(u)int32</code>, <code>(u)int64</code>, <code>uintptr</code></p></li><li><p><code>byte</code>(8bit), <code>rune</code>(32bit)</p></li><li><p><code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code></p><ul><li><p><code>complex</code>小练习：验证欧拉公式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>π</mi><mi>i</mi></mrow></msup><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">e^{πi} + 1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.908em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">πi</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">euler</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%.3f \n\r&quot;</span>, cmplx.Exp(<span class="number">1i</span>*math.Pi)+<span class="number">1</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果：</p><blockquote><p>(0.000+0.000i)</p></blockquote></li></ul></li></ul><h3 id="类型强制转换">类型强制转换</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triangle</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line">  c = <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(a*a + b*b)))</span><br><span class="line">  fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>5</p></blockquote><h3 id="常量的定义">常量的定义</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以定义在包里</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  filename1 = <span class="string">&quot;efg.txt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consts</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    filename = <span class="string">&quot;abc.txt&quot;</span></span><br><span class="line">    <span class="comment">//常量不指定类型，可以作为各种类型使用</span></span><br><span class="line">    a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">var</span> c <span class="type">int</span></span><br><span class="line">  c = <span class="type">int</span>(math.Sqrt(a*a + b*b))</span><br><span class="line">  fmt.Println(filename, filename1, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>abc.txt efg.txt 5</p></blockquote><h3 id="枚举">枚举</h3><p>Golang中没有枚举类型关键字，使用常量定义枚举值</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enums</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">//iota是自增值，也可以直接赋值</span></span><br><span class="line">    cpp = <span class="literal">iota</span></span><br><span class="line">    <span class="comment">//下划线代表跳过这一个自增值</span></span><br><span class="line">    _</span><br><span class="line">    python</span><br><span class="line">    php</span><br><span class="line">    javascript</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> (</span><br><span class="line">    b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">    kb</span><br><span class="line">    mb</span><br><span class="line">    gb</span><br><span class="line">    tb</span><br><span class="line">    pb</span><br><span class="line">  )</span><br><span class="line">  fmt.Println(cpp, python, php, javascript)</span><br><span class="line">  fmt.Println(b, kb, mb, gb, tb, pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>0 2 3 4<br>1 1024 1048576 1073741824 1099511627776 1125899906842624</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Go开发工程师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言学习笔记 </tag>
            
            <tag> Golang基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB高手课笔记</title>
      <link href="/posts/ecf99c50.html"/>
      <url>/posts/ecf99c50.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote><p>这是极客时间的《MongoDB高手课》视频课程做的笔记。中间件会持续更新。视频课程可以自己搜一下，极客时间的山寨课很多，就是声画不同步看着有点不舒服而已，正版也不贵，新人首单是59。课程介绍说看完这个可以说自己精通MongoDB，欢迎大家在评论区反馈</p></blockquote><h2 id="MongoDB再入门">MongoDB再入门</h2><h3 id="关于MongoDB">关于MongoDB</h3><table><thead><tr><th>Question</th><th>Answer</th></tr></thead><tbody><tr><td>什么是 <strong>MongoDB</strong>？</td><td>一个以 <strong>JSON</strong> 为数据模型的 <strong>文档数据库</strong></td></tr><tr><td>为什么叫 <strong>文档数据库</strong>？</td><td>文档来自于 <code>JSON Document</code>，并非我们一般理解的 PDF，WORD文档</td></tr><tr><td>谁开发的 <strong>MongoDB</strong>？</td><td>上市公司 MongoDB Inc. ，总部位于美国纽约</td></tr><tr><td>主要用途</td><td>1. 应用数据库，类似于Oracle，MySQL<br />2. 海量数据处理，数据平台</td></tr><tr><td>主要特点</td><td>1. 建模为可选<br />2. JSON数据模型比较适合开发者<br />3. 支持横向扩展，支持大数据量和并发<br />4. 从4.0版本开始支持ACID事务</td></tr></tbody></table><p><img src="https://s2.loli.net/2023/07/08/VR3SJAXFDOLdpUT.png" alt="MongoDB版本变迁"></p><h3 id="MongoDB-VS-关系型数据库">MongoDB VS 关系型数据库</h3><table><thead><tr><th></th><th>MongoDB</th><th>RDBMS</th></tr></thead><tbody><tr><td>数据模型</td><td>文档类型</td><td>关系模型</td></tr><tr><td>数据库类型</td><td>OLTP（Online Transaction Processing，联机事务处理）</td><td>OLTP（Online Transaction Processing，联机事务处理）</td></tr><tr><td>CRUD操作</td><td>MQL/SQL</td><td>SQL</td></tr><tr><td>高可用</td><td>复制集</td><td>集群模式</td></tr><tr><td>横向扩展能力</td><td>通过原生分片完善支持</td><td>数据分区、应用侵入式（如分库分表）</td></tr><tr><td>索引支持</td><td>B树，全文索引，地理位置索引，多键索引，TTL索引</td><td>B树，B+树</td></tr><tr><td>开发难度</td><td>容易</td><td>困难</td></tr><tr><td>数据容量</td><td>没有理论上限</td><td>千万、亿</td></tr><tr><td>扩展方式</td><td>垂直扩展+水平扩展</td><td>垂直扩展</td></tr></tbody></table><h3 id="MongoDB的特色以及优势">MongoDB的特色以及优势</h3><ul><li><p>简单直观：以自然的方式来建模，以直观的方式来交互。如订单模块，需要用几张表来表示<code>订单-订单明细</code>，Mongo可以直接用一个集合来表示这个对象。通俗的讲复杂对象只需要用一个表（集合）</p></li><li><p>结构灵活：弹性模式，从容响应需求的频繁变化</p><ul><li>多形性：同一个集合可以包含不同字段（类型）的文档对象</li><li>动态性：线上修改数据模式，修改时应用和数据库无需下线重启</li><li>数据治理：支持使用JSON schema</li><li><img src="https://s2.loli.net/2023/07/08/yj1c93hPRKaFBJH.png" alt="image-20230708230507930" style="zoom: 67%;" /></li></ul></li><li><p>快速开发：做更多的事，写更少的代码</p><ul><li>数据库引擎只需要在一个存储区读写。数据库查询操作耗时最长的步骤在定位上，如果有这个一个对象，关系型数据需要6个表，至少需要定位6次，但是在MongoDB只需要一个查询语句定位一次。</li><li>反范式，无关联的组织极大的优化查询速度</li><li>程序API自然，快速开发</li></ul><img src="https://s2.loli.net/2023/07/08/DdA24MSWOvz5RsT.png" alt="image-20230708231755588" style="zoom:50%;" /></li><li><p>原生的高可用和横向扩展能力：多中心容灾，自动故障转移</p></li></ul><h3 id="MongoDB基本操作">MongoDB基本操作</h3><h4 id="使用-insert-完成插入操作">使用 <code>insert</code> 完成插入操作</h4><p>操作格式：</p><ul><li><code>db.&lt;集合&gt;.insertOne(&lt;JSON对象&gt;)</code></li><li><code>db.&lt;集合&gt;.insertMany([&lt;JSON 1&gt;, &lt;JSON 2&gt;, ..., &lt;JSON n&gt;])</code></li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.fruit.insertOne(&#123;name:&quot;apple&quot;&#125;)</span><br><span class="line">db.fruit.insertMany([&#123;name:&quot;apple&quot;&#125;,&#123;name:&quot;pear&quot;&#125;,&#123;name:&quot;orange&quot;&#125;])</span><br></pre></td></tr></table></figure><h4 id="使用-find-查询文档">使用 <code>find</code> 查询文档</h4><h5 id="关于find：">关于find：</h5><ul><li><code>find</code> 是 MongoDB 中查询数据的基本指令，相当于SQL中的 Select</li><li><code>find</code> 返回的是<strong>游标</strong></li></ul><h5 id="find示例：">find示例：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">movies</span>.<span class="title function_">find</span>(&#123;<span class="string">&quot;year&quot;</span>:<span class="number">1975</span>&#125;) <span class="comment">//单条件查询</span></span><br><span class="line">db.<span class="property">movies</span>.<span class="title function_">find</span>(&#123;<span class="string">&quot;year&quot;</span>:<span class="number">1989</span>,<span class="string">&quot;title&quot;</span>:<span class="string">&quot;Batman&quot;</span>&#125;) <span class="comment">//多条件查询</span></span><br><span class="line">db.<span class="property">movies</span>.<span class="title function_">find</span>(&#123;<span class="attr">$and</span>:[&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;Batman&quot;</span>&#125;],&#123;<span class="string">&quot;category&quot;</span>:<span class="string">&quot;action&quot;</span>&#125;&#125;) <span class="comment">//and的另一种形式</span></span><br><span class="line">db.<span class="property">movies</span>.<span class="title function_">find</span>(&#123;<span class="attr">$or</span>:[&#123;<span class="string">&quot;year&quot;</span>:<span class="number">1989</span>&#125;,&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;Batman&quot;</span>&#125;]&#125;) <span class="comment">//多条件or查询</span></span><br><span class="line">db.<span class="property">movies</span>.<span class="title function_">find</span>(&#123;<span class="string">&quot;title&quot;</span>:<span class="regexp">/^B/</span>&#125;) <span class="comment">//正则表达式查找,相当于模糊查询</span></span><br></pre></td></tr></table></figure><h5 id="SQL-和-MQL对照表">SQL 和 MQL对照表</h5><table><thead><tr><th style="text-align:center">SQL</th><th style="text-align:center">MQL</th></tr></thead><tbody><tr><td style="text-align:center">a=1</td><td style="text-align:center"><code>&#123; a: 1&#125;</code></td></tr><tr><td style="text-align:center">a&lt;&gt;1</td><td style="text-align:center"><code>&#123; a: &#123; $ne: 1&#125;&#125;</code></td></tr><tr><td style="text-align:center">a&gt;1</td><td style="text-align:center"><code>&#123; a: &#123; $gt: 1&#125;&#125;</code></td></tr><tr><td style="text-align:center">a&gt;=1</td><td style="text-align:center"><code>&#123; a: &#123; $gte: 1&#125;&#125;</code></td></tr><tr><td style="text-align:center">a&lt;1</td><td style="text-align:center"><code>&#123; a: &#123; $lt: 1&#125;&#125;</code></td></tr><tr><td style="text-align:center">a&lt;=1</td><td style="text-align:center"><code>&#123; a: &#123; $lte: 1&#125;&#125;</code></td></tr><tr><td style="text-align:center">a=1 AND b=1</td><td style="text-align:center"><code>&#123;a: 1,b: 1&#125;</code> 或  <code>&#123;$and:[&#123;a: 1&#125;, &#123;b: 1&#125;]&#125;</code></td></tr><tr><td style="text-align:center">a=1 OR b=1</td><td style="text-align:center"><code>&#123;$or:[&#123;a: 1&#125;, &#123;b: 1&#125;]&#125;</code></td></tr><tr><td style="text-align:center">a IS NULL</td><td style="text-align:center"><code>&#123;a:&#123;$exist: false&#125;&#125;</code></td></tr><tr><td style="text-align:center">a IN (1,2,3)</td><td style="text-align:center">{a: {$in: [1, 2, 3]}}</td></tr><tr><td style="text-align:center">a NOT IN(1,2,4)</td><td style="text-align:center">{a: {$nin: [1, 2, 3]}}</td></tr></tbody></table><h5 id="查询逻辑运算符">查询逻辑运算符</h5><ul><li><code>$lt</code>：存在并小于</li><li><code>$lte</code>：存在并小于等于$gt:存在并大于</li><li><code>$gte</code>：存在并大于等于</li><li><code>$ne</code>：不存在或存在但不等于</li><li><code>$in</code>：存在并在指定数组中</li><li><code>$nin</code>：不存在或不在指定数组中</li><li><code>$or</code>：匹配两个或多个条件中的一个</li><li><code>$and</code>：匹配全部条件</li></ul><h5 id="使用-find-查询">使用 find 查询</h5><p><code>find</code> 支持 <code>field.sub_field</code>的形式查询子文档。假设有一个文档：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">fruit</span>.<span class="title function_">insertOne</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;apple&quot;</span>,</span><br><span class="line">    <span class="attr">from</span>: &#123;</span><br><span class="line">        <span class="attr">country</span>: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">        <span class="attr">province</span>: <span class="string">&quot;Guangdon&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">fruit</span>.<span class="title function_">find</span>(&#123;<span class="string">&quot;from.country&quot;</span>:<span class="string">&quot;China&quot;</span>&#125;)</span><br><span class="line">db.<span class="property">fruit</span>.<span class="title function_">find</span>(&#123;<span class="string">&quot;from&quot;</span>:&#123;<span class="attr">country</span>:<span class="string">&quot;China&quot;</span>&#125;&#125;) <span class="comment">//这种是错误写法</span></span><br></pre></td></tr></table></figure><h5 id="使用find搜索数组中的对象">使用find搜索数组中的对象</h5><p>考虑以下文档，在其中搜索</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">movies</span>.<span class="title function_">insertOne</span>(&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>:<span class="string">&quot;Raiders of the Lost Ark&quot;</span>,</span><br><span class="line">    <span class="string">&quot;filming_location&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;Los Angels&quot;</span>,<span class="attr">state</span>:<span class="string">&quot;CA&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;USA&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="attr">state</span>:<span class="string">&quot;Lazio&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;Italy&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;Florence&quot;</span>,<span class="attr">state</span>:<span class="string">&quot;SC&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;USA&quot;</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 查找城市的记录</span></span><br><span class="line">db.<span class="property">movies</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="string">&quot;filming_location.city&quot;</span>:<span class="string">&quot;Rome&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 同一个子对象满足多个条件的查询，需要使用$elemMatch</span></span><br><span class="line">db.<span class="property">movies</span>.<span class="title function_">find</span>(&#123;</span><br><span class="line">    <span class="string">&quot;filming_location.city&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">$elemMatch</span>:&#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;Rome&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;USA&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="指定返回字段">指定返回字段</h5><ul><li>find可以指定只返回某些字段</li><li>_id字段必须明确指明不返回，默认返回</li><li>在 <code>MongoDB</code> 中我们称之为 <strong>投影</strong>(projection)</li><li><code>db.movies.find(&#123;&quot;category&quot;:&quot;action&quot;&#125;,&#123;_id:0,title:1&#125;)</code>中，第二个对象为 <strong>投影字段</strong>，为0表示不返回</li></ul><h4 id="使用-remove-删除文档">使用 <code>remove</code> 删除文档</h4><ul><li><p><code>remove</code> 需要配合查询条件来使用</p></li><li><p>匹配到的文档会被删除</p></li><li><p>指定一个空文档查询条件会删除所有数据</p></li><li><p>以下为示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">testcol</span>.<span class="title function_">remove</span>(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;) <span class="comment">// 删除a = 1的数据</span></span><br><span class="line">db.<span class="property">testcol</span>.<span class="title function_">remove</span>(&#123;<span class="attr">a</span>: &#123;<span class="attr">$lt</span>:<span class="number">1</span>&#125;&#125;) <span class="comment">// 删除a &lt; 1的数据</span></span><br><span class="line">db.<span class="property">testcol</span>.<span class="title function_">remove</span>(&#123;&#125;) <span class="comment">// 删除所有数据</span></span><br><span class="line">db.<span class="property">testcol</span>.<span class="title function_">remove</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用-update-更新文档">使用 <code>update</code> 更新文档</h4><ul><li><p><code>update</code> 操作格式： <code>db.&lt;集合&gt;.update(&lt;查询条件&gt;,&lt;更新字段&gt;)</code></p></li><li><p>以下数据为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">fruit</span>.<span class="title function_">insertMany</span>([&#123;<span class="attr">name</span>:<span class="string">&quot;apple&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;pear&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;orange&quot;</span>&#125;])</span><br><span class="line">db.<span class="property">fruit</span>.<span class="title function_">updateOne</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;apple&quot;</span>&#125;,&#123;<span class="attr">$set</span>: &#123;<span class="attr">from</span>: <span class="string">&quot;China&quot;</span>&#125;&#125;) <span class="comment">//$set指令可以修改原字段，也可以新增字段</span></span><br></pre></td></tr></table></figure></li><li><p><code>updateOne</code> 只会更新匹配到的第一条数据</p></li><li><p><code>updateMany</code> 表示匹配到多少条就更新多少条</p></li><li><p><code>updateOne/updateMany</code> 方法要求更新部分必须具备一下条件之一，否则报错：</p><ul><li><p><code>$set/$unset</code>：</p></li><li><p><code>$push/$pushAll/$pop</code>：增加一个对象到数组底部 / 增加多个对象到数组底部 / 从数组底部删除一个对象</p></li><li><p><code>$pull/$pullAll</code>：如果匹配到相应的值则从数组中删除相应的对象 / 如果匹配到任意的值，从数组中删除相应的对象</p></li><li><p><code>$addToSet</code>：如果不存在则新增一个值到数组</p></li><li><p><code>$inc</code>：预聚合，适合排行榜，点击率等场景。（在chatgpt中提问，说MongoDB中的预聚合是线程安全的，可以自行查证）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">inventory</span>.<span class="title function_">update</span>(</span><br><span class="line">    &#123;<span class="attr">_id</span>:<span class="number">123</span>&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">$inc</span>:&#123;</span><br><span class="line">            <span class="attr">quantity</span>: -<span class="number">1</span>,</span><br><span class="line">            <span class="attr">daily_sales</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">weekly_sales</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">monthly_sales</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="使用-Drop-删除一个集合">使用 <code>Drop</code> 删除一个集合</h4><ul><li>使用 <code>db.&lt;集合&gt;.drop()</code> 删除一个集合</li><li>集合中所有文档会被删除</li><li>集合相关的索引也会被删除</li></ul><h3 id="MongoDB的聚合查询">MongoDB的聚合查询</h3><h4 id="聚合运算的基本格式">聚合运算的基本格式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pipeline = [$stage1, $stage2, ..., $stage3]</span><br><span class="line">db.&lt;collection&gt;.<span class="title function_">aggregate</span>(</span><br><span class="line">    pipeline,</span><br><span class="line">    &#123; options &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="常见步骤">常见步骤</h4><table><thead><tr><th style="text-align:center">步骤</th><th style="text-align:center">作用</th><th style="text-align:center">SQL等价运算符</th></tr></thead><tbody><tr><td style="text-align:center">$match</td><td style="text-align:center">过滤</td><td style="text-align:center">WHERE</td></tr><tr><td style="text-align:center">$project</td><td style="text-align:center">投影</td><td style="text-align:center">AS</td></tr><tr><td style="text-align:center">$sort</td><td style="text-align:center">排序</td><td style="text-align:center">ORDER BY</td></tr><tr><td style="text-align:center">$group</td><td style="text-align:center">分组</td><td style="text-align:center">GROUP BY</td></tr><tr><td style="text-align:center">$skip 和 $limit</td><td style="text-align:center">结果集限制</td><td style="text-align:center">SKIP/LIMIT</td></tr><tr><td style="text-align:center">$lookup</td><td style="text-align:center">左外连接</td><td style="text-align:center">LEFT OUTER JOIN</td></tr><tr><td style="text-align:center">$unwind</td><td style="text-align:center">展开数组</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">$graphLookup</td><td style="text-align:center">图搜索</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">$facet 和 $bucket</td><td style="text-align:center">分面搜索</td><td style="text-align:center">–</td></tr></tbody></table><h4 id="常见步骤中的运算符">常见步骤中的运算符</h4><table><thead><tr><th>$match</th><th>$project</th><th>$group</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>q</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">eq/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord">/</span></span></span></span>gt/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">gte/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>lt<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>t</mi><mi>e</mi><mo>&lt;</mo><mi>b</mi><mi>r</mi><mi mathvariant="normal">/</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">lte&lt;br /&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">lt</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>and/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">or/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord">/</span></span></span></span>not/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mo>&lt;</mo><mi>b</mi><mi>r</mi><mi mathvariant="normal">/</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">in&lt;br /&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">in</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>geoWithin/$intersect<br />… …</td><td>选择需要的或不需要的字段<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">map/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">p</span><span class="mord">/</span></span></span></span>reduce/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>l</mi><mi>t</mi><mi>e</mi><mi>r</mi><mo>&lt;</mo><mi>b</mi><mi>r</mi><mi mathvariant="normal">/</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">filter&lt;br /&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">lt</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">/</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span>range<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>p</mi><mi>l</mi><mi>y</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">multiply/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">/</span></span></span></span>divide/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">substract/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord">/</span></span></span></span>add<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi>e</mi><mi>a</mi><mi>r</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">year/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ye</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord">/</span></span></span></span>month/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>a</mi><mi>y</mi><mi>O</mi><mi>f</mi><mi>M</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">dayOfMonth/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mord">/</span></span></span></span>hour/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">minute/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>second<br />… …</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">sum/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord">/</span></span></span></span>avg<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">push/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord">/</span></span></span></span>addToSet<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>i</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">first/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">i</span><span class="mord mathnormal">rs</span><span class="mord mathnormal">t</span><span class="mord">/</span></span></span></span>last/<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">max/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord">/</span></span></span></span>min<br />… …</td></tr></tbody></table><h4 id="聚合查询示例：">聚合查询示例：</h4><h5 id="分页查询男性用户名字">分页查询男性用户名字</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIRST_NAME <span class="keyword">AS</span> <span class="string">&#x27;名&#x27;</span>, LAST_NAME <span class="keyword">AS</span> <span class="string">&#x27;姓&#x27;</span> <span class="keyword">FROM</span> Users <span class="keyword">WHERE</span> GENDER <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">SKIP</span> <span class="number">100</span> LIMIT <span class="number">20</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">users</span>.<span class="title function_">aggregate</span>([</span><br><span class="line">    &#123;<span class="attr">$match</span>:&#123;<span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;&#125;,</span><br><span class="line">    &#123;<span class="attr">$skip</span>:<span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">$limit</span>:<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;名&quot;</span>:<span class="string">&quot;$first_name&quot;</span>,</span><br><span class="line">            <span class="string">&quot;姓&quot;</span>:<span class="string">&quot;$last_name&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h5 id="每个部门女员工的数量">每个部门女员工的数量</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DEPARTMENT, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> EMP_QTY</span><br><span class="line"><span class="keyword">FROM</span> Users</span><br><span class="line"><span class="keyword">WHERE</span> GENDER <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPARTMENT <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">users</span>.<span class="title function_">aggregate</span>([</span><br><span class="line">    &#123;<span class="attr">$match</span>:&#123;<span class="attr">gender</span>:<span class="string">&quot;女&quot;</span>&#125;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">$group</span>:&#123;</span><br><span class="line">            <span class="attr">_id</span>:<span class="string">&quot;$DEPARTMENT&quot;</span>,</span><br><span class="line">            <span class="attr">emp_qyt</span>:&#123;<span class="attr">$sum</span>: <span class="number">1</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="attr">$match</span>:&#123;<span class="attr">emp_qyt</span>:&#123;<span class="attr">$lt</span>:<span class="number">10</span>&#125;&#125;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h5 id="数组展开-unwind">数组展开 unwind</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元数据</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="string">&quot;score&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;subject&quot;</span>:<span class="string">&quot;语文&quot;</span>,</span><br><span class="line">            <span class="string">&quot;score&quot;</span>:<span class="number">84</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;subject&quot;</span>:<span class="string">&quot;数学&quot;</span>,</span><br><span class="line">            <span class="string">&quot;score&quot;</span>:<span class="number">90</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;subject&quot;</span>:<span class="string">&quot;英语&quot;</span>,</span><br><span class="line">            <span class="string">&quot;score&quot;</span>:<span class="number">60</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展开</span></span><br><span class="line">db.<span class="property">students</span>.<span class="title function_">aggregate</span>([</span><br><span class="line">    &#123;<span class="attr">$unwind</span>:<span class="string">&#x27;$score&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">//展开后数据</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="string">&quot;subject&quot;</span>:<span class="string">&quot;语文&quot;</span>,</span><br><span class="line">  <span class="string">&quot;score&quot;</span>:<span class="number">84</span></span><br><span class="line"> &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;subject&quot;</span>:<span class="string">&quot;数学&quot;</span>,</span><br><span class="line">  <span class="string">&quot;score&quot;</span>:<span class="number">90</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;subject&quot;</span>:<span class="string">&quot;英语&quot;</span>,</span><br><span class="line">  <span class="string">&quot;score&quot;</span>:<span class="number">60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="MQL特有步骤Bucket">MQL特有步骤Bucket</h5><img src="https://s2.loli.net/2023/07/10/2C4QtDOgN9obvu1.png" alt="image-20230710102234238" style="zoom:50%;" /><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">products</span>.<span class="title function_">aggregate</span>([</span><br><span class="line">    &#123;<span class="attr">$bucket</span>:&#123;</span><br><span class="line">        <span class="attr">groupBy</span>:<span class="string">&quot;$price&quot;</span>,</span><br><span class="line">        <span class="attr">boundaries</span>:[<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>],</span><br><span class="line">        <span class="attr">default</span>:<span class="string">&quot;Other&quot;</span>,</span><br><span class="line">        <span class="attr">output</span>:&#123;<span class="string">&quot;count&quot;</span>:&#123;<span class="attr">$sum</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/07/10/6xgdUJq1uMeAGnH.png" alt="image-20230710102609323" style="zoom:50%;" /><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组合bucket用facet</span></span><br><span class="line">db.<span class="property">products</span>.<span class="title function_">aggregate</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">$facet</span>:&#123;</span><br><span class="line">            <span class="attr">price</span>:&#123;</span><br><span class="line">                <span class="attr">$bucket</span>:&#123;...&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">year</span>:&#123;</span><br><span class="line">                <span class="attr">$bucket</span>:&#123;...&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h3 id="复制集机制与原理">复制集机制与原理</h3><h4 id="复制集的作用">复制集的作用</h4><ul><li>主要意义在于实现高可用</li><li>它的现实依赖与两个方面的功能<ul><li>数据写入时快速复制到另一个节点上</li><li>接受写入数据的节点发生故障时，自动选举出另一个节点替代。（故障自动转移）</li></ul></li><li>实现高可用的同时，复制集的其他几个作用<ul><li>数据分发：将数据从一个区域分发到另一个区域，减少另一个区域的读延迟</li><li>读写分离：不同类型的压力分到不同的节点上</li><li>异地容灾：在数据中心发生故障时，快速切换到异地</li></ul></li></ul><h4 id="典型的复制集结构">典型的复制集结构</h4><img src="https://s2.loli.net/2023/07/10/FUfwQ8LXMVKH5Re.png" alt="image-20230710143718517" style="zoom:50%;" /><p>一个典型的复制集结构至少由三个具有投票权的节点组成，包括：</p><ul><li>一个主节点（Primary）：接受写入操作和选举时投票</li><li>两个以上从节点（Secondary）：复制主节点的数据和选举时投票</li><li>不推荐使用Arbiter节点（投票节点，类似于Redis的Sentinel）</li></ul><h4 id="数据是如何复制的？">数据是如何复制的？</h4><ul><li>当一个写操作到达主节点时，它会被记录下来，这些称之为<code>oplog</code></li><li><strong>从节点</strong> 通过在 <strong>主节点</strong> 打开一个 <strong>tailable</strong> 游标不断获取新进入主节点的 <code>oplog</code> ，并在自己的数据上回放，来保持和主节点的数据一致</li></ul><img src="https://s2.loli.net/2023/07/10/W56ZueAGqjvVCza.png" alt="image-20230710144520057" style="zoom:40%;" /><h4 id="通过选举完成故障恢复">通过选举完成故障恢复</h4><img src="https://s2.loli.net/2023/07/10/SeJfcZy6px7u8wk.png" alt="image-20230710144922175" style="zoom:50%;" /><ul><li>具有投票权的节点相互发送心跳，<strong>5次心跳失联认为节点故障</strong>。</li><li>如果失联的是主节点，从节点会进行选举，选出新的主节点；如果是从节点，则不影响。</li><li>选举基于 <code>RAFT一致性算法</code> 实现，选举成功的条件是大多数投票节点存活。</li><li>复制集最多可以有50个节点，但<strong>具有投票权的最多有7个</strong>。</li></ul><h4 id="影响节点选举的因素">影响节点选举的因素</h4><ul><li>整个集群必须有大多数节点存活着</li><li>被选为主节点的节点必须：<ul><li>能够与多数的节点建立连接</li><li>拥有最新的oplog</li><li>具有较高的优先级（如果有配置的话）</li></ul></li></ul><div class="note danger flat"><p>增加从节点不会提高系统写入的性能</p></div><h2 id="从熟练到精通的开发之路">从熟练到精通的开发之路</h2><div class="note info flat"><p>只是开发达到精通哈，要想吊打面试官，起码把运维那部分也看了</p></div><h3 id="MongoDB-文档模型设计的三个误区">MongoDB 文档模型设计的三个误区</h3><p><img src="https://s2.loli.net/2023/07/10/b9k6ZCrt7lv5Dyi.png" alt="image-20230710160030804" style="zoom:50%;display:inline" /><img src="https://s2.loli.net/2023/07/10/CjHY3Z4tabVyzXh.png" alt="image-20230710155950666" style="zoom:50%;display:inline" /></p><ol><li><p>不需要模型设计 <mark class="hl-label blue">错误</mark> </p><div class="note info flat"><p>MongoDB同样需要概念/逻辑建模，只是和关系型数据库的建模不一样，没有主外键的部分。并且，<strong>文档模型设计的物理结构可以和逻辑层类似</strong>。所以物理模型这个步骤可以被省略</p></div></li><li><p><strong>MongoDB</strong> 用一个超大的文档来组织所有的数据 <mark class="hl-label blue">错误，不可能也不现实</mark> </p></li><li><p><strong>MongoDB</strong> 不支持事务 <mark class="hl-label blue">错误，4.0开始支持ACID事务</mark> </p></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">关系型数据库</th><th style="text-align:left">MongoDB</th></tr></thead><tbody><tr><td style="text-align:center">模型设计层次</td><td style="text-align:left">概念模型<br />逻辑建模<br />物理模型</td><td style="text-align:left">概念模型<br />逻辑建模<br /></td></tr><tr><td style="text-align:center">模型实体</td><td style="text-align:left">表</td><td style="text-align:left">集合</td></tr><tr><td style="text-align:center">模型属性</td><td style="text-align:left">列</td><td style="text-align:left">字段</td></tr><tr><td style="text-align:center">模型关系</td><td style="text-align:left">关联关系，主外键</td><td style="text-align:left">内嵌数组，引用字段</td></tr></tbody></table><h3 id="文档模型设计">文档模型设计</h3><img src="https://s2.loli.net/2023/07/10/TDReupVNi1AInFJ.png" alt="MongoDB模型设计三部曲" style="zoom:50%;" /><h4 id="第一步：建立基础文档模型">第一步：建立基础文档模型</h4><ol><li>根据概念模型或者业务需求推导出逻辑模型 - 找到对象</li><li>列出实体之间的关系 (及基数) - 明确关系（一对多，一对一，多对多）</li><li>套用逻辑设计原则来决定内嵌方式 - 进行建模</li><li>完成基础模型构建</li></ol><h4 id="第二步：根据读写工况细化">第二步：根据读写工况细化</h4><ul><li><p>最频繁的数据查询模式</p></li><li><p>最常用的查询参数</p></li><li><p>最频繁的数据写入模式</p></li><li><p>读写操作比例</p></li><li><p>数据量大小</p></li><li><p>基于内嵌文档的模型，根据业务需求：</p><ul><li>使用引用来避免性能瓶颈</li><li>使用冗余来优化访问性能</li></ul><img src="https://s2.loli.net/2023/07/10/AcdhXWMPbjpx16q.png" alt="image-20230710165444751" style="zoom:50%;" /></li></ul><div class="note info flat"><p>这个有点想mybatis里关联查询 <code>association </code>，这种在mysql中容易造成 N+1的问题，但是在 <code>MongoDB</code> 中，是相当于 <code>LEFT OUTER JOIN</code>。</p><p>MongoDB引用设计模式的一些限制</p><ul><li>MongoDB在使用引用的集合中并无主外键检查</li><li>MongoDB使用聚合查询的 <code>$lookup</code>来模仿关联查询</li><li><code>$lookup</code> 只支持 <code>Left Outer Join</code></li><li><code>$lookup</code>的关联目标（from）不能是分片表</li></ul></div><h4 id="第三步：套用设计模式">第三步：套用设计模式</h4><ul><li><p>文档模型：无范式，无思维定式，充分发挥想象力</p></li><li><p>设计模式：实战过屡试不爽的设计技巧，快速应用</p></li><li><p>举例：一个IoT场景的分桶设计模式，可以帮助把存储空间降低10倍，并且提高查询效率数十倍</p><img src="https://s2.loli.net/2023/07/10/Om9W1xrapKAs6NH.png" alt="image-20230710172952177" style="zoom:50%;" /></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每分钟一个文档</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016010105000:WG9943&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icao&quot;</span><span class="punctuation">:</span><span class="string">&quot;WG9943&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ts&quot;</span><span class="punctuation">:</span>ISODate(&#x27;<span class="number">2016</span><span class="number">-01</span><span class="number">-01</span>T05<span class="punctuation">:</span><span class="number">00</span><span class="punctuation">:</span><span class="number">00.000</span>+<span class="number">0000</span>&#x27;)<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="number">24943</span><span class="punctuation">,</span><span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="number">319</span><span class="punctuation">,</span><span class="attr">&quot;p&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">41</span><span class="punctuation">,</span><span class="number">70</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;s&quot;</span><span class="punctuation">:</span><span class="number">56</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">//每小时一个文档</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span><span class="string">&quot;2016010105000:WG9943&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;icao&quot;</span><span class="punctuation">:</span><span class="string">&quot;WG9943&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ts&quot;</span><span class="punctuation">:</span>ISODate(&#x27;<span class="number">2016</span><span class="number">-01</span><span class="number">-01</span>T05<span class="punctuation">:</span><span class="number">00</span><span class="punctuation">:</span><span class="number">00.000</span>+<span class="number">0000</span>&#x27;)<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;event&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span> <span class="comment">// 分桶设计，一小时60条数据</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="number">24943</span><span class="punctuation">,</span><span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="number">319</span><span class="punctuation">,</span><span class="attr">&quot;p&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">41</span><span class="punctuation">,</span><span class="number">70</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;s&quot;</span><span class="punctuation">:</span><span class="number">56</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;t&quot;</span><span class="punctuation">:</span>ISODate(&#x27;<span class="number">2016</span><span class="number">-01</span><span class="number">-01</span>T05<span class="punctuation">:</span><span class="number">00</span><span class="punctuation">:</span><span class="number">00.000</span>+<span class="number">0000</span>&#x27;)</span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="number">24943</span><span class="punctuation">,</span><span class="attr">&quot;b&quot;</span><span class="punctuation">:</span><span class="number">319</span><span class="punctuation">,</span><span class="attr">&quot;p&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="number">41</span><span class="punctuation">,</span><span class="number">70</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;s&quot;</span><span class="punctuation">:</span><span class="number">56</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;t&quot;</span><span class="punctuation">:</span>ISODate(&#x27;<span class="number">2016</span><span class="number">-01</span><span class="number">-01</span>T05<span class="punctuation">:</span><span class="number">00</span><span class="punctuation">:</span><span class="number">01.000</span>+<span class="number">0000</span>&#x27;)</span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="事务">事务</h3><h4 id="什么是-writeConcern？">什么是 writeConcern？</h4><p><code>writeConcern</code> 决定一个写操作落到多少个节点才算成功。<code>writeConcern</code>取值包括：</p><ul><li>0：发起写操作，不关心是否成功</li><li>1~集群最大数据节点数：写操作需要被复制到指定节点数才算成功。</li><li>majority：写操作落到大多数节点中才算成功</li></ul><p>发起写操作的程序将阻塞到写操作到达指定节点数为止。默认为主节点成功就成功。</p><h4 id="writeConcern-实验">writeConcern 实验</h4><ul><li><p>在复制集测试writeConcern参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">test</span>.<span class="title function_">insert</span>( &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;, &#123; <span class="attr">writeConcern</span>: &#123;<span class="attr">w</span>: <span class="string">&quot;majority&quot;</span> &#125;&#125;)</span><br><span class="line">db.<span class="property">test</span>.<span class="title function_">insert</span>( &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;, &#123; <span class="attr">writeConcern</span>: &#123;<span class="attr">w</span>: <span class="number">3</span> &#125;&#125;)</span><br><span class="line">db.<span class="property">test</span>.<span class="title function_">insert</span>( &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;, &#123; <span class="attr">writeConcern</span>: &#123;<span class="attr">w</span>: <span class="number">4</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>配置延迟节点，模拟网络延迟(复制延迟)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conf=rs.<span class="title function_">conf</span>()</span><br><span class="line">conf.<span class="property">members</span>[<span class="number">2</span>].<span class="property">slaveDelay</span> = <span class="number">5</span></span><br><span class="line">conf.<span class="property">members</span>[<span class="number">2</span>].<span class="property">priority</span> = <span class="number">0</span> <span class="comment">//配置成不可以参与选举的节点</span></span><br><span class="line">rs.<span class="title function_">reconfig</span>(conf)</span><br></pre></td></tr></table></figure></li><li><p>观察复制延迟下的写入，以及timeout参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="property">test</span>.<span class="title function_">insert</span>( &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;, &#123; <span class="attr">writeConcern</span>:&#123;<span class="attr">w</span>: <span class="number">3</span>&#125;&#125;)</span><br><span class="line">db.<span class="property">test</span>.<span class="title function_">insert</span>( &#123;<span class="attr">count</span>: <span class="number">1</span>&#125;,&#123; <span class="attr">writeConcern</span>: &#123;<span class="attr">w</span>: <span class="number">3</span>, <span class="attr">wtimeout</span>:<span class="number">3000</span> &#125;&#125;) <span class="comment">// 这里同步延迟时间为5s，但是等待3s会报错，数据实际上已经写进去了，实际业务场景中，最好做一个日志，方便回查</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="读操作事务">读操作事务</h3><div class="note info flat"><p>读数据操作中需要关注两个问题</p><ul><li>从哪里读？关注节点位置 （readReference）</li><li>什么样的数据可以读？关注数据的隔离性 （readConcern）</li></ul></div><h4 id="什么是readReference？">什么是readReference？</h4><p><code>readReference</code>决定使用哪一个节点来满足正在发起的读请求，可选值包括：</p><ul><li><strong>primary</strong>：只选择主节点；</li><li><strong>primaryPreferred</strong>：有限选择主节点，如果不可用则选择从节点</li><li><strong>secondary</strong>：只选择从节点</li><li><strong>secondaryPreferred</strong>：有限选择从节点，如果从节点不可用则选择主节点</li><li><strong>nearest</strong>：选择最近的节点</li></ul><p>场景举例：</p><ul><li>用户下订单后马上将用户转到订单详情页——primary/primaryPreferred。因为此时从节点可能还没复制到新订单</li><li>用户查询自己下过的订单——secondary/secondaryPreferred。查询历史订单时效性通常没有太高要求</li><li>生成报表——secondary。报表对时效性要求不高，但资源需求大，可以在从节点单独处理，避免对线上用户造成影响</li><li>将用户上传的图片分发到全世界，让各地用户能就近读取——nearest。每个地区的应用选择最近的节点读取数据</li></ul><p><strong>readReference</strong> 与 <strong>tag</strong></p><p>readReference只能控制使用一类节点，Tag可以更精准控制请求打到某几个节点。</p><img src="https://s2.loli.net/2023/07/10/o74BGX3CVStz6OR.png" alt="image-20230710214849255" style="zoom:50%;" /><h4 id="readReference-配置">readReference 配置</h4><ul><li>通过MongoDB的连接串参数：<code>mongodb://host1:27107,host2:27107,host3:27017/?replicaSet=rs&amp;readPreference=secondary</code></li><li>通过MongoDB驱动程序API：<code>MongoCollection.withReadPreference(ReadReference eadRef)</code></li><li>MongoShell：<code>db.collection.find(&#123;&#125;).readPref(&quot;sencondary&quot;)</code></li></ul><div class="note info flat"><p>可以使用 <code>db.fsyncLock()</code>来锁定写入，解除从节点锁定使用 <code>db.fsyncUnlock()</code></p></div><div class="note danger flat"><p>配置了readReference/tag时，如果对应的节点失效则读操作失败，如主节点，则发生故障转移期间没有节点可读。</p></div><h4 id="什么是readConcern">什么是readConcern</h4><p>readPreference选择了指定节点后，readConcern决定这个节点上的数据那些是可读的，类似于关系数据库的隔离级别。可选值包括：</p><ul><li><strong>available</strong>：读取所有可用数据</li><li><strong>local</strong>：读取所有可用且属于当前分片的数据</li><li><strong>majority</strong>：读取在大多数节点上提交完成的数据（mvcc实现，相当于RC）</li><li><strong>linearizable</strong>：可线性化读取文档</li><li><strong>snapshot</strong>：读取最近快照中的数据（相当于RR）</li></ul><h4 id="ACID多文档事务支持">ACID多文档事务支持</h4><table><thead><tr><th>事务属性</th><th>支持程度</th></tr></thead><tbody><tr><td>Atomicity 原子性</td><td>4.2开始支持分片集群多表多文档</td></tr><tr><td>Consistency 一致性</td><td>writeConcern，readConcern</td></tr><tr><td>Isolation 隔离性</td><td>readConcern</td></tr><tr><td>Durability 持久性</td><td>Journal and Replication</td></tr></tbody></table><p>使用示例（java）</p><p><img src="D:%5Cimgs%5Cimage-20230710223343805.png" alt="image-20230710223343805"></p><div class="note info flat"><p>其实也可以使用<code>@transactional</code>，配置好事务管理器就行</p></div><h2 id="分片集群与高级运维之道">分片集群与高级运维之道</h2><h3 id="MongoDB常见的部署架构">MongoDB常见的部署架构</h3><p><img src="https://s2.loli.net/2023/07/10/DsAWogZ9tiRVImH.png" alt="image-20230710230932630"></p><h3 id="为什么要使用分片集群">为什么要使用分片集群</h3><p>可能的场景</p><ul><li>数据容量日益增大，访问性能日渐降低</li><li>新品上线异常火爆，如何支持更多的并发用户</li><li>单库已有10TB数据，恢复需要1-2天</li><li>地理分布数据</li><li>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> 中间件集合 </tag>
            
            <tag> 极客时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper概念讲得最清楚的文章</title>
      <link href="/posts/417af937.html"/>
      <url>/posts/417af937.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本文转自公众号<a href="https://mp.weixin.qq.com/s/B2ngp0q5kdWsCNH8sw_5DA">月伴飞鱼</a></p></div><h1>基本介绍</h1><p>Apache ZooKeeper 是由Apache Hadoop的子项目发展而来，为分布式应用提供高效且可靠的分布式协调服务。</p><ul><li>在解决分布式数据一致性方面，ZK没有直接采用Paxos算法，而是采用了ZAB（ZooKeeper Atomic Broadcast）协议。</li></ul><p>ZK可以提供诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知，集群管理，Master选举，分布式锁，分布式队列等功能。</p><p><strong>「它具有以下特性：」</strong></p><ul><li><strong>「顺序一致性」</strong>：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；</li><li><strong>「原子性」</strong>：要么所有应用，要么不应用；不存在部分机器应用了该事务，而**「另一部分没有应用」**的情况；</li><li><strong>「单一视图」</strong>：所有客户端看到的服务端数据模型都是一致的，无论客户连接的是哪个ZK服务器；</li><li><strong>「可靠性」</strong>：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；</li><li><strong>「实时性」</strong>：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据（<strong>「一段时间」</strong>）。</li></ul><h1>数据模型</h1><p>ZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。</p><ul><li>ZooKeeper的数据模型也具有一个固定的根节点<code>（/）</code>，我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。</li><li>ZooKeeper 树中的每一层级用斜杠<code>（/）</code>分隔开，且只能用绝对路径（如<code>get /work/task</code>）的方式查询 ZooKeeper 节点，而不能使用相对路径。</li></ul><p><img src="https://s2.loli.net/2023/06/13/iVfKelyYuhaEQxD.png" alt="图片"></p><p><strong>「为什么 ZooKeeper 不能采用相对路径查找节点呢？」</strong></p><blockquote><p>❝</p><p>这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。</p><p>❞</p></blockquote><p>像这种查找与给定值相等的记录问题最适合用散列来解决。</p><p>因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 <code>hashtableConcurrentHashMap&lt;String, DataNode&gt; nodes</code>，用节点的完整路径来作为 key 存储节点数据。</p><p>这样就大大提高了 ZooKeeper 的性能。</p><p><strong>「节点类型」</strong></p><p>ZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：</p><blockquote><p>❝</p><p>1、持久节点</p><p>❞</p></blockquote><p>一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。</p><blockquote><p>❝</p><p>2、临时节点</p><p>❞</p></blockquote><p>如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。</p><p>当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除，同样，我们可以像删除持久节点一样主动删除临时节点。</p><p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为<code>/servers</code>节点，并为集群下的每台服务器创建一个临时节点<code>/servers/host</code>，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。</p><blockquote><p>❝</p><p>3、有序节点</p><p>❞</p></blockquote><p>节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。</p><p>例如一个客户端创建了一个路径为 <code>works/task-</code>的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为<code>works/task-1</code>。</p><ul><li>通过这种方式我们可以直观的查看到节点的创建顺序。</li></ul><p>ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组<code>（byte data[]）</code>，用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p><p><strong>「节点的状态结构」</strong></p><p>执行<code>stat /zk_test</code>，可以看到控制台输出了一些信息，这些就是节点状态信息。</p><p>每一个节点都有一个自己的状态属性，记录了节点本身的一些信息：</p><table><thead><tr><th style="text-align:left"><strong>「状态属性」</strong></th><th style="text-align:left"><strong>「说明」</strong></th></tr></thead><tbody><tr><td style="text-align:left">czxid</td><td style="text-align:left">数据节点创建时的事务 ID</td></tr><tr><td style="text-align:left">ctime</td><td style="text-align:left">数据节点创建时的时间</td></tr><tr><td style="text-align:left">mzxid</td><td style="text-align:left">数据节点最后一次更新时的事务 ID</td></tr><tr><td style="text-align:left">mtime</td><td style="text-align:left">数据节点最后一次更新时的时间</td></tr><tr><td style="text-align:left">pzxid</td><td style="text-align:left">数据节点的子节点最后一次被修改时的事务 ID</td></tr><tr><td style="text-align:left"><strong>「cversion」</strong></td><td style="text-align:left"><strong>「子节点的版本」</strong></td></tr><tr><td style="text-align:left"><strong>「version」</strong></td><td style="text-align:left"><strong>「当前节点数据的版本」</strong></td></tr><tr><td style="text-align:left"><strong>「aversion」</strong></td><td style="text-align:left"><strong>「节点的 ACL 的版本」</strong></td></tr><tr><td style="text-align:left">ephemeralOwner</td><td style="text-align:left">如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0</td></tr><tr><td style="text-align:left">dataLength</td><td style="text-align:left">数据内容的长度</td></tr><tr><td style="text-align:left">numChildren</td><td style="text-align:left">数据节点当前的子节点个数</td></tr></tbody></table><p><strong>「数据节点的版本」</strong></p><p>在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。</p><p>ZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。</p><h1>数据存储</h1><p>从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。</p><ul><li>事务日志数据主要用于记录本地事务性会话操作，用于 ZooKeeper 集群服务器之间的数据同步。</li><li>事务快照则是将内存数据持久化到本地磁盘。</li></ul><blockquote><p>❝</p><p>这里要注意的一点是，数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致。</p><p>❞</p></blockquote><p>在单台 ZooKeeper 服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。</p><p><strong>「内存数据」</strong></p><p>ZooKeeper 的数据模型可以看作一棵树形结构，而数据节点就是这棵树上的叶子节点。</p><p>从数据存储的角度看，ZooKeeper 的数据模型是存储在内存中的。</p><p>我们可以把 ZooKeeper 的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的 ACL 权限信息以及 stat 状态信息等。</p><ul><li>而在底层实现中，ZooKeeper 数据模型是通过 DataTree 类来定义的。</li></ul><p>DataTree 类定义了一个 ZooKeeper 数据的内存结构。</p><p>DataTree 的内部定义类 nodes 节点类型、root 根节点信息、子节点的 WatchManager 监控信息等数据模型中的相关信息。</p><p>可以说，一个 DataTree 类定义了 ZooKeeper 内存数据的逻辑结构。</p><p><strong>「事务日志」</strong></p><p>为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper 集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper 集群中的 Follow 和 Observer 服务器就会进行数据同步。</p><blockquote><p>❝</p><p>而这两种角色服务器所接收到的信息就是 Leader 服务器的事务日志。</p><p>❞</p></blockquote><p>在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个 ZooKeeper 集群的执行性能。</p><h1>Watch机制</h1><p>ZooKeeper 的客户端可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知；</p><p><strong>「如何实现：」</strong></p><p>我们可以通过向 ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)</span><br></pre></td></tr></table></figure><p>上面代码的意思是定义了一个了 ZooKeeper 客户端对象实例，并传入三个参数：</p><ul><li>connectString 服务端地址</li><li>sessionTimeout：超时时间</li><li>Watcher：监控事件</li></ul><p>这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文 ，一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中。</p><p>除此之外，ZooKeeper 客户端也可以通过 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getData(String path, Watcher watcher, Stat stat)</span><br></pre></td></tr></table></figure><p>触发通知的条件：</p><p><img src="https://s2.loli.net/2023/06/13/koi63Juc5RezhZE.png" alt="图片"></p><p>上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。</p><ul><li>例如在客户端连接服务端的时候，可以对数据节点的创建、删除、数据变更、子节点的更新等操作进行监控。</li></ul><p><strong>「当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？」</strong></p><p>答案是否定的，Watch 事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的 Watch 事件。</p><p><strong>「订阅发布场景实现」</strong></p><blockquote><p>❝</p><p>提到 ZooKeeper 的应用场景，你可能第一时间会想到最为典型的发布订阅功能。</p><p>❞</p></blockquote><p>发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。</p><p>一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。</p><p>ZooKeeper 采用了两种模式结合的方式实现订阅发布功能。</p><blockquote><p>❝</p><p>下面我们来分析一个具体案例：</p><p>❞</p></blockquote><p>在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。</p><p>通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper 的发布订阅功能就能解决这个问题。</p><p>我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper 数据节点中。</p><p>如<code>/confs/data_item1</code>。</p><ul><li>服务器集群客户端对该节点添加 Watch 事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。</li><li>而当该节点数据发生变化时，ZooKeeper 服务器会发送 Watch 事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。</li></ul><p>我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对 ZooKeeper 服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。</p><blockquote><p>❝</p><p>要注意一点是，我们提到 Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch 事件。</p><p>❞</p></blockquote><h1>会话机制</h1><p>ZooKeeper 的工作方式一般是通过客户端向服务端发送请求而实现的。</p><p>而在一个请求的发送过程中，首先，客户端要与服务端进行连接，而一个连接就是一个会话。</p><blockquote><p>❝</p><p>在 ZooKeeper 中，一个会话可以看作是一个用于表示客户端与服务器端连接的数据结构 Session。</p><p>❞</p></blockquote><p>这个数据结构由三个部分组成：分别是会话 ID（sessionID）、会话超时时间（TimeOut）、会话关闭状态（isClosing）</p><ul><li>会话 ID：会话 ID 作为一个会话的标识符，当我们创建一次会话的时候，ZooKeeper 会自动为其分配一个唯一的 ID 编码。</li><li>会话超时时间：一般来说，一个会话的超时时间就是指一次会话从发起后到被服务器关闭的时长。而设置会话超时时间后，服务器会参考设置的超时时间，最终计算一个服务端自己的超时时间。而这个超时时间则是最终真正用于 ZooKeeper 中服务端用户会话管理的超时时间。</li><li>会话关闭状态：会话关闭 isClosing 状态属性字段表示一个会话是否已经关闭。如果服务器检查到一个会话已经因为超时等原因失效时， ZooKeeper 会在该会话的 isClosing 属性值标记为关闭，再之后就不对该会话进行操作了。</li></ul><p><strong>「会话状态」</strong></p><p>在 ZooKeeper 服务的运行过程中，会话会经历不同的状态变化。</p><p>这些状态包括：</p><blockquote><p>❝</p><p>正在连接（CONNECTING）、已经连接（CONNECTIED）、正在重新连接（RECONNECTING）、已经重新连接（RECONNECTED）、会话关闭（CLOSE）等。</p><p>❞</p></blockquote><p>当客户端开始创建一个与服务端的会话操作时，它的会话状态就会变成 CONNECTING，之后客户端会根据服务器地址列表中的服务器 IP 地址分别尝试进行连接。如果遇到一个 IP 地址可以连接到服务器，那么客户端会话状态将变为 CONNECTIED。</p><p>如果因为网络原因造成已经连接的客户端会话断开时，客户端会重新尝试连接服务端。而对应的客户端会话状态又变成 CONNECTING ，直到该会话连接到服务端最终又变成 CONNECTIED。</p><blockquote><p>❝</p><p>在 ZooKeeper 服务的整个运行过程中，会话状态经常会在 CONNECTING 与 CONNECTIED 之间进行切换。</p><p>❞</p></blockquote><p>最后，当出现超时或者客户端主动退出程序等情况时，客户端会话状态则会变为 CLOSE 状态。</p><p><strong>「会话异常」</strong></p><p>在 ZooKeeper 中，会话的超时异常包括客户端 readtimeout 异常和服务器端 sessionTimeout 异常。</p><ul><li>在我们平时的开发中，要明确这两个异常的不同之处在于一个是发生在客户端，而另一个是发生在服务端。</li></ul><p>而对于那些对 ZooKeeper 接触不深的开发人员来说，他们常常踩坑的地方在于，虽然设置了超时间，但是在实际服务运行的时候 ZooKeeper 并没有按照设置的超时时间来管理会话。</p><ul><li>这是因为 ZooKeeper 实际起作用的超时时间是通过客户端和服务端协商决定。</li></ul><p>ZooKeeper 客户端在和服务端建立连接的时候，会提交一个客户端设置的会话超时时间，而该超时时间会和服务端设置的最大超时时间和最小超时时间进行比对，如果正好在其允许的范围内，则采用客户端的超时时间管理会话。</p><p>如果大于或者小于服务端设置的超时时间，则采用服务端设置的值管理会话。</p><p><strong>「分桶策略」</strong></p><p>我们知道在 ZooKeeper 中为了保证一个会话的存活状态，客户端需要向服务器周期性地发送心跳信息。</p><ul><li>而客户端所发送的心跳信息可以是一个 ping 请求，也可以是一个普通的业务请求。</li></ul><p>ZooKeeper 服务端接收请求后，会更新会话的过期时间，来保证会话的存活状态。</p><ul><li>所以在 ZooKeeper 的会话管理中，最主要的工作就是管理会话的过期时间。</li></ul><blockquote><p>❝</p><p>ZooKeeper 中采用了独特的会话管理方式来管理会话的过期时间。</p><p>❞</p></blockquote><p>在 ZooKeeper 中，会话将按照不同的时间间隔进行划分，超时时间相近的会话将被放在同一个间隔区间中，这种方式避免了 ZooKeeper 对每一个会话进行检查，而是采用分批次的方式管理会话。</p><p>这就降低了会话管理的难度，因为每次小批量的处理会话过期也提高了会话处理的效率。</p><p><strong>「ZooKeeper 这种会话管理的好处？」</strong></p><p>ZooKeeper 这种分段的会话管理策略大大提高了计算会话过期的效率，如果是在一个实际生产环境中，一个大型的分布式系统往往具有很高的访问量。</p><p>而 ZooKeeper 作为其中的组件，对外提供服务往往要承担数千个客户端的访问，这其中就要对这几千个会话进行管理。</p><p>在这种场景下，要想通过对每一个会话进行管理和检查并不合适，所以采用将同一个时间段的会话进行统一管理，这样就大大提高了服务的运行效率。</p><p><strong>「底层实现」</strong></p><p>ZooKeeper 底层实现的原理，核心的一点就是过期队列这个数据结构。所有会话过期的相关操作都是围绕这个队列进行的。</p><ul><li>可以说 ZooKeeper 底层就是采用这个队列结构来管理会话过期的。</li></ul><p><strong>「一个会话过期队列是由若干个 bucket 组成的。」</strong></p><ul><li>bucket 是一个按照时间划分的区间。</li><li>在 ZooKeeper 中，通常以 expirationInterval 为单位进行时间区间的划分，它是 ZooKeeper 分桶策略中用于划分时间区间的最小单位。</li><li>在 ZooKeeper 中，一个过期队列由不同的 bucket 组成。</li><li>每个 bucket 中存放了在某一时间内过期的会话。</li></ul><p>将会话按照不同的过期时间段分别维护到过期队列之后，在 ZooKeeper 服务运行的过程中，具体的执行过程如下图所示。</p><p><img src="https://s2.loli.net/2023/06/13/DMg83XqOcEr1UTu.png" alt="图片"></p><p>首先，ZooKeeper 服务会开启一个线程专门用来检索过期队列，找出要过期的 bucket，而 ZooKeeper 每次只会让一个 bucket 的会话过期，每当要进行会话过期操作时，ZooKeeper 会唤醒一个处于休眠状态的线程进行会话过期操作，之后会按照上面介绍的操作检索过期队列，取出过期的会话后会执行过期操作。</p><h1>ACL权限</h1><p>ZooKeeper的ACL可针对znodes设置相应的权限信息。</p><p>一个 ACL 权限设置通常可以分为 3 部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。</p><ul><li>最终组成一条例如<code>scheme:id:permission</code>格式的 ACL 请求信息。</li></ul><p><strong>「权限模式：Scheme」</strong></p><p>ZooKeeper 的权限验证方式大体分为两种类型，一种是范围验证，另外一种是口令验证。</p><blockquote><p>❝</p><p>范围验证</p><p>❞</p></blockquote><p>所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。</p><p>比如我们可以让一个 IP 地址为<code>ip：192.168.0.11</code>的机器对服务器上的某个数据节点具有写入的权限。</p><p>或者也可以通过<code>ip:192.168.0.11/22</code>给一段 IP 地址的机器赋权。</p><blockquote><p>❝</p><p>口令验证</p><p>❞</p></blockquote><p>可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。</p><p>在 ZooKeeper 中这种验证方式是 Digest 认证，我们知道通过网络传输相对来说并不安全，所以绝不通过明文在网络发送密码也是程序设计中很重要的原则之一，而 Digest 这种认证方式首先在客户端传送<code>username:password</code>这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。</p><blockquote><p>❝</p><p>Super 权限模式</p><p>❞</p></blockquote><p>权限模式 Super 可以认为是一种特殊的 Digest 认证。</p><p>具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</p><p>下面这段代码给出了 Digest 模式下客户端的调用方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建节点</span><br><span class="line">create /digest_node1</span><br><span class="line">//设置digest权限验证</span><br><span class="line">setAcl /digest_node1 digest:用户名:base64格式密码:rwadc </span><br><span class="line">//查询节点Acl权限</span><br><span class="line">getAcl /digest_node1 </span><br><span class="line">//授权操作</span><br><span class="line">addauth digest user:passwd</span><br></pre></td></tr></table></figure><blockquote><p>❝</p><p>如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。</p><p>❞</p></blockquote><p>对其创建的节点要想进行修改应该怎么做呢？</p><p>我们可以通过**「super 模式」**即超级管理员的方式删除该节点或变更该节点的权限验证方式。</p><p>正因为**「super 模式」**有如此大的权限，我们在平时使用时也应该更加谨慎。</p><blockquote><p>❝</p><p>world 模式</p><p>❞</p></blockquote><p>这种授权模式对应于系统中的所有用户，本质上起不到任何作用。</p><p>设置了 world 权限模式系统中的所有用户操作都可以不进行权限验证。</p><p><strong>「授权对象（ID）」</strong></p><p>所谓的授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。</p><p>如果是 World 模式，是授权系统中所有的用户。</p><p><strong>「权限信息（Permission）」</strong></p><p>权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：</p><ul><li>数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；</li><li>数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；</li><li>数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；</li><li>数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</li><li>数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</li></ul><blockquote><p>❝</p><p>需要注意的一点是，每个节点都有维护自身的 ACL 权限数据，即使是该节点的子节点也是有自己的 ACL 权限而不是直接继承其父节点的权限。</p><p>❞</p></blockquote><p><strong>「实现自己的权限口控制」</strong></p><p>虽然 ZooKeeper 自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。</p><p>官方文档中对这种机制的定义是 <code>Pluggable ZooKeeper Authenication</code>，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。那么这种机制是如何实现的呢？</p><blockquote><p>❝</p><p>要想实现自定义的权限控制机制，最核心的一点是实现 ZooKeeper 提供的权限控制器接口 AuthenticationProvider。</p><p>❞</p></blockquote><p>实现了自定义权限后，如何才能让 ZooKeeper 服务端使用自定义的权限验证方式呢？</p><p>接下来就需要将自定义的权限控制注册到 ZooKeeper 服务器中，而注册的方式通常有两种。</p><ul><li>第一种是通过设置系统属性来注册自定义的权限控制器：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dzookeeper.authProvider.x=CustomAuthenticationProvider</span><br></pre></td></tr></table></figure><ul><li>另一种是在配置文件<code>zoo.cfg</code>中进行配置：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authProvider.x=CustomAuthenticationProvider</span><br></pre></td></tr></table></figure><p><strong>「实现原理」</strong></p><p>首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。</p><p>在授权接口中，值得注意的是会话的授权信息存储在 ZooKeeper 服务端的内存中，如果客户端会话关闭，授权信息会被删除。</p><p>下次连接服务器后，需要重新调用授权接口进行授权。</p><h1>序列化方式</h1><p>在 ZooKeeper 中并没有采用和 Java 一样的序列化方式，而是采用了一个 Jute 的序列解决方案作为 ZooKeeper 框架自身的序列化方式。</p><blockquote><p>❝</p><p>ZooKeeper 从最开始就采用 Jute 作为其序列化解决方案，直到其最新的版本依然没有更改。</p><p>❞</p></blockquote><p>虽然 ZooKeeper 一直将 Jute 框架作为序列化解决方案，但这并不意味着 Jute 相对其他框架性能更好，反倒是 Apache Avro、Thrift 等框架在性能上优于前者。</p><p>之所以 ZooKeeper 一直采用 Jute 作为序列化解决方案，主要是新老版本的兼容等问题。</p><p><strong>「如何 使用 Jute 实现序列化」</strong></p><p>如果我们要想将某个定义的类进行序列化，首先需要该类实现 Record 接口的 serilize 和 deserialize 方法，这两个方法分别是序列化和反序列化方法。</p><blockquote><p>❝</p><p>下边这段代码给出了我们一般在 ZooKeeper 中进行序列化的具体实现：</p><p>❞</p></blockquote><p>首先，我们定义了一个<code>test_jute</code>类，为了能够对它进行序列化，需要该<code>test_jute</code>类实现 Record 接口，并在对应的 serialize 序列化方法和 deserialize 反序列化方法中编辑具体的实现逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class test_jute implements Record&#123;</span><br><span class="line">  private long ids；</span><br><span class="line">  private String name;</span><br><span class="line">  ...</span><br><span class="line">  public void serialize(OutpurArchive a_,String tag)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  public void deserialize(INputArchive a_,String tag)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在序列化方法 serialize 中，我们要实现的逻辑是，首先通过字符类型参数 tag 传递标记序列化标识符，之后使用 writeLong 和 writeString 等方法分别将对象属性字段进行序列化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void serialize(OutpurArchive a_,String tag) throws ...&#123;</span><br><span class="line">  a_.startRecord(this.tag);</span><br><span class="line">  a_.writeLong(ids,&quot;ids&quot;);</span><br><span class="line">  a_.writeString(type,&quot;name&quot;);</span><br><span class="line">  a_.endRecord(this,tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 derseralize 在实现反序列化的过程则与我们上边说的序列化过程正好相反。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void deserialize(INputArchive a_,String tag) throws &#123;</span><br><span class="line">  a_.startRecord(tag);</span><br><span class="line">  ids = a_.readLong(&quot;ids&quot;);</span><br><span class="line">  name = a_.readString(&quot;name&quot;);</span><br><span class="line">  a_.endRecord(tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化和反序列化的实现逻辑编码方式相对固定，首先通过 startRecord 开启一段序列化操作，之后通过 writeLong、writeString 或 readLong、 readString 等方法执行序列化或反序列化。</p><p>本例中只是实现了长整型和字符型的序列化和反序列化操作，除此之外 ZooKeeper 中的 Jute 框架还支持整数类型（Int）、布尔类型（Bool）、双精度类型（Double）以及 Byte/Buffer 类型。</p><h1>集群</h1><p><strong>「ZooKeeper集群模式的特点」</strong></p><p>在 ZooKeeper 集群中将服务器分成 **「Leader 、Follow 、Observer 三」**种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p><ul><li>Leader 角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者，既可以为客户端提供写服务又能提供读服务。</li><li>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader 服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个 Follow 服务器作为新的 Leader 服务器，只能提供读服务。</li><li>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与 Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器，只能提供读服务。</li></ul><p>在 ZooKeeper 集群接收到来自客户端的会话请求操作后，首先会判断该条请求是否是事务性的会话请求。</p><blockquote><p>❝</p><p>对于事务性的会话请求，ZooKeeper 集群服务端会将该请求统一转发给 Leader 服务器进行操作。</p><p>所谓事务性请求，是指 ZooKeeper 服务器执行完该条会话请求后，是否会导致执行该条会话请求的服务器的数据或状态发生改变，进而导致与其他集群中的服务器出现数据不一致的情况。</p><p>❞</p></blockquote><p>Leader 服务器内部执行该条事务性的会话请求后，再将数据同步给其他角色服务器，从而保证事务性会话请求的执行顺序，进而保证整个 ZooKeeper 集群的数据一致性。</p><blockquote><p>❝</p><p>在 ZooKeeper 集群的内部实现中，是通过什么方法保证所有 ZooKeeper 集群接收到的事务性会话请求都能交给 Leader 服务器进行处理的呢？</p><p>❞</p></blockquote><p>在 ZooKeeper 集群内部，集群中除 Leader 服务器外的其他角色服务器接收到来自客户端的事务性会话请求后，必须将该条会话请求转发给 Leader 服务器进行处理。</p><p>ZooKeeper 集群中的 Follow 和 Observer 服务器，都会检查当前接收到的会话请求是否是事务性的请求，如果是事务性的请求，那么就将该请求以 REQUEST 消息类型转发给 Leader 服务器。</p><p>在 ZooKeeper集群中的服务器接收到该条消息后，会对该条消息进行解析。</p><ul><li>分析出该条消息所包含的原始客户端会话请求。</li><li>之后将该条消息提交到自己的 Leader 服务器请求处理链中，开始进行事务性的会话请求操作。</li><li>如果不是事务性请求，ZooKeeper 集群则交由 Follow 和 Observer 角色服务器处理该条会话请求，如查询数据节点信息。</li></ul><p>当一个业务场景在查询操作多而创建删除等事务性操作少的情况下，ZooKeeper 集群的性能表现的就会很好。</p><blockquote><p>❝</p><p>如果是在极端情况下，ZooKeeper 集群只有事务性的会话请求而没有查询操作，那么 Follow 和 Observer 服务器就只能充当一个请求转发服务器的角色， 所有的会话的处理压力都在 Leader 服务器。</p><p>❞</p></blockquote><p>在处理性能上整个集群服务器的瓶颈取决于 Leader 服务器的性能。</p><blockquote><p>❝</p><p>ZooKeeper 集群的作用只能保证在 Leader 节点崩溃的时候，重新选举出 Leader 服务器保证系统的稳定性。</p><p>❞</p></blockquote><p>这也是 ZooKeeper 设计的一个缺点。</p><p><strong>「Leader选举」</strong></p><p>Leader 服务器的选举操作主要发生在两种情况下。</p><p>第一种就是 ZooKeeper 集群服务启动的时候，第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时，这时 ZooKeeper 集群需要选举出新的 Leader 服务器。</p><blockquote><p>❝</p><p>ZooKeeper 集群重新选举 Leader 的过程只有 Follow 服务器参与工作。</p><p>❞</p></blockquote><blockquote><p>❝</p><p>服务器状态</p><p>❞</p></blockquote><p>服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。</p><ul><li><strong>「LOOKING」</strong>：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</li><li><strong>「FOLLOWING」</strong>：跟随者状态。表明当前服务器角色是Follower。</li><li><strong>「LEADING」</strong>：领导者状态。表明当前服务器角色是Leader。</li><li><strong>「OBSERVING」</strong>：观察者状态。表明当前服务器角色是Observer。</li></ul><p><strong>「事务ID（zxid）」</strong></p><p>Zookeeper的状态变化，都会由一个Zookeeper事务ID（ZXID）标识。</p><blockquote><p>❝</p><p>写入Zookeeper，会导致状态变化，每次写入都会导致ZXID发生变化。</p><p>❞</p></blockquote><p>ZXID由Leader统一分配，全局唯一，长度64位，递增。</p><p>ZXID展示了所有的Zookeeper转台变更顺序，每次变更都有一个唯一ZXID，如果zxid1小于zxid2，则说明zxid1的事务在zxid2的事务之前发生。</p><p><strong>「选举过程」</strong></p><p>在 ZooKeeper 集群重新选举 Leader 节点的过程中，主要可以分为 Leader 失效发现、重新选举 Leader 、Follow 服务器角色变更、集群同步这几个步骤。</p><blockquote><p>❝</p><p>Leader 失效发现</p><p>❞</p></blockquote><p>在 ZooKeeper 集群中，当 Leader 服务器失效时，ZooKeeper 集群会重新选举出新的 Leader 服务器。</p><ul><li>在 ZooKeeper 集群中，探测 Leader 服务器是否存活的方式与保持客户端活跃性的方法非常相似。</li></ul><p>首先，Follow 服务器会定期向 Leader 服务器发送 网络请求，在接收到请求后，Leader 服务器会返回响应数据包给 Follow 服务器，而在 Follow 服务器接收到 Leader 服务器的响应后，如果判断 Leader 服务器运行正常，则继续进行数据同步和服务转发等工作，反之，则进行 Leader 服务器的重新选举操作。</p><blockquote><p>❝</p><p>Leader重新选举</p><p>❞</p></blockquote><p>当 Follow 服务器向 Leader 服务器发送状态请求包后，如果没有得到 Leader 服务器的返回信息，这时，如果是集群中个别的 Follow 服务器发现返回错误，并不会导致 ZooKeeper 集群立刻重新选举 Leader 服务器，而是将该 Follow 服务器的状态变更为 LOOKING 状态，并向网络中发起投票，当 ZooKeeper 集群中有更多的机器发起投票，最后当投票结果满足多数原则的情况下。</p><p>ZooKeeper 会重新选举出 Leader 服务器。</p><blockquote><p>❝</p><p>Follow 角色变更</p><p>❞</p></blockquote><p>在 ZooKeeper 集群中，Follow 服务器作为 Leader 服务器的候选者，当被选举为 Leader 服务器之后，其在 ZooKeeper 集群中的 Follow 角色，也随之发生改变。也就是要转变为 Leader 服务器，并作为 ZooKeeper 集群中的 Leader 角色服务器对外提供服务。</p><blockquote><p>❝</p><p>集群同步数据</p><p>❞</p></blockquote><p>在 ZooKeeper 集群成功选举 Leader 服务器，并且候选 Follow 服务器的角色变更后。</p><p>为避免在这期间导致的数据不一致问题，ZooKeeper 集群在对外提供服务之前，会通过 Leader 角色服务器管理同步其他角色服务器。</p><p><strong>「底层实现」</strong></p><p>首先，ZooKeeper 集群会先判断 Leader 服务器是否失效，而判断的方式就是 Follow 服务器向 Leader 服务器发送请求包，之后 Follow 服务器接收到响应数据后，进行解析，Follow 服务器会根据返回的数据，判断 Leader 服务器的运行状态，如果返回的是 LOOKING 关键字，表明与集群中 Leader 服务器无法正常通信。</p><ul><li>之后，在 ZooKeeper 集群选举 Leader 服务器时，是通过 <strong>「FastLeaderElection」</strong> 类实现的。</li></ul><p>该类实现了 TCP 方式的通信连接，用于在 ZooKeeper 集群中与其他 Follow 服务器进行协调沟通。</p><p>FastLeaderElection 类继承了 Election 接口，定义其是用来进行选举的实现类。</p><ul><li>而在其内部，又定义了选举通信相关的一些配置参数，比如 finalizeWait 最终等待时间、最大通知间隔时间 maxNotificationInterval 等。</li></ul><p>在选举的过程中，首先调用 ToSend 函数向 ZooKeeper 集群中的其他角色服务器发送本机的投票信息，其他服务器在接收投票信息后，会对投票信息进行有效性验证等操作，之后 ZooKeeper 集群统计投票信息，如果过半数的机器投票信息一致，则集群就重新选出新的 Leader 服务器。</p><blockquote><p>❝</p><p>这里我们要注意一个问题，那就是在重新选举 Leader 服务器的过程中，ZooKeeper 集群理论上是无法进行事务性的请求处理的。</p><p>❞</p></blockquote><p>因此，发送到 ZooKeeper 集群中的事务性会话会被挂起，暂时不执行，等到选举出新的 Leader 服务器后再进行操作。</p><p><strong>「Observer」</strong></p><p>在 ZooKeeper 集群服务运行的过程中，Observer 服务器与 Follow 服务器具有一个相同的功能，那就是负责处理来自客户端的诸如查询数据节点等非事务性的会话请求操作。</p><ul><li>但与 Follow 服务器不同的是，Observer 不参与 Leader 服务器的选举工作，也不会被选举为 Leader 服务器。</li></ul><p>在早期的 ZooKeeper 集群服务运行过程中，只有 Leader 服务器和 Follow 服务器。</p><p>不过随着 ZooKeeper 在分布式环境下的广泛应用，早期模式的设计缺点也随之产生，主要带来的问题有如下几点：</p><ul><li>随着集群规模的变大，集群处理写入的性能反而下降。</li><li>ZooKeeper 集群无法做到跨域部署。</li></ul><p>其中最主要的问题在于，当 ZooKeeper 集群的规模变大，集群中 Follow 服务器数量逐渐增多的时候，ZooKeeper 处理创建数据节点等事务性请求操作的性能就会逐渐下降。</p><p>这是因为 ZooKeeper 集群在处理事务性请求操作时，要在 ZooKeeper 集群中对该事务性的请求发起投票，只有超过半数的 Follow 服务器投票一致，才会执行该条写入操作。</p><p>正因如此，随着集群中 Follow 服务器的数量越来越多，一次写入等相关操作的投票也就变得越来越复杂，并且 Follow 服务器之间彼此的网络通信也变得越来越耗时，导致随着 Follow 服务器数量的逐步增加，事务性的处理性能反而变得越来越低。</p><ul><li>为了解决这一问题，在 ZooKeeper 3.6 版本后，ZooKeeper 集群中创建了一种新的服务器角色，即 Observer——观察者角色服务器。</li></ul><p>Observer 可以处理 ZooKeeper 集群中的非事务性请求，并且不参与 Leader 节点等投票相关的操作。</p><p>这样既保证了 ZooKeeper 集群性能的扩展性，又避免了因为过多的服务器参与投票相关的操作而影响 ZooKeeper 集群处理事务性会话请求的能力。</p><ul><li>在实际部署的时候，因为 Observer 不参与 Leader 节点等操作，并不会像 Follow 服务器那样频繁的与 Leader 服务器进行通信。</li></ul><p>因此，可以将 Observer 服务器部署在不同的网络区间中，这样也不会影响整个 ZooKeeper 集群的性能，也就是所谓的跨域部署。</p><p><strong>「在我们日常使用 ZooKeeper 集群服务器的时候，集群中的机器个数应该选择奇数个？」</strong></p><p>两个原因：</p><blockquote><p>❝</p><p>在容错能力相同的情况下，奇数台更节省资源</p><p>❞</p></blockquote><p>Zookeeper中 Leader 选举算法采用了Zab协议。</p><p>Zab核心思想是当多数 Server 写成功，则写成功。</p><p>举两个例子：</p><ul><li>假如zookeeper集群1 ，有3个节点，3/2=1.5 ,  即zookeeper想要正常对外提供服务（即leader选举成功），至少需要2个节点是正常的。换句话说，3个节点的zookeeper集群，允许有一个节点宕机。</li><li>假如zookeeper集群2，有4个节点，4/2=2 , 即zookeeper想要正常对外提供服务（即leader选举成功），至少需要3个节点是正常的。换句话说，4个节点的zookeeper集群，也允许有一个节点宕机。</li></ul><p>集群1与集群2都有 允许1个节点宕机 的容错能力，但是集群2比集群1多了1个节点。在相同容错能力的情况下，本着节约资源的原则，zookeeper集群的节点数维持奇数个更好一些。</p><blockquote><p>❝</p><p>防止由脑裂造成的集群不可用。</p><p>❞</p></blockquote><p>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。</p><p>下面举例说一下为什么采用奇数台节点，就可以防止由于脑裂造成的服务不可用：</p><p>假如zookeeper集群有 5 个节点，发生了脑裂，脑裂成了A、B两个小集群：</p><ul><li>A ：1个节点 ，B ：4个节点</li><li>A ：2个节点， B ：3个节点</li></ul><p>可以看出，上面这两种情况下，A、B中总会有一个小集群满足 可用节点数量 &gt; 总节点数量/2 。</p><p>所以zookeeper集群仍然能够选举出leader ， 仍然能对外提供服务，只不过是有一部分节点失效了而已。</p><p>假如zookeeper集群有4个节点，同样发生脑裂，脑裂成了A、B两个小集群：</p><ul><li>A：1个节点 ，  B：3个节点</li><li>A：2个节点 ， B：2个节点</li></ul><p>因为A和B都是2个节点，都不满足 可用节点数量 &gt; 总节点数量/2 的选举条件， 所以此时zookeeper就彻底不能提供服务了。</p><h1>ZAB协议</h1><p><strong>「ZAB 协议算法」</strong></p><p>ZooKeeper 最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。</p><blockquote><p>❝</p><p>为了解决这个问题，ZooKeeper 采用了 ZAB 协议算法。</p><p>❞</p></blockquote><p>ZAB 协议算法（Zookeeper Atomic Broadcast  ，Zookeeper 原子广播协议）是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是崩溃恢复和原子广播协议。</p><ul><li>在整个 ZAB 协议的底层实现中，ZooKeeper 集群主要采用主从模式的系统架构方式来保证 ZooKeeper 集群系统的一致性。</li></ul><p>当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。</p><blockquote><p>❝</p><p>以 ZooKeeper 集群为例，这个操作过程可以概括为：</p><p>❞</p></blockquote><p>当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。</p><p>当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。</p><p>然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。</p><p><strong>「崩溃恢复」</strong></p><p>当集群中的 Leader 发生故障的时候，整个集群就会因为缺少 Leader 服务器而无法处理来自客户端的事务性的会话请求。</p><blockquote><p>❝</p><p>因此，为了解决这个问题。在 ZAB 协议中也设置了处理该问题的崩溃恢复机制。</p><p>❞</p></blockquote><p>崩溃恢复机制是保证 ZooKeeper 集群服务高可用的关键。触发 ZooKeeper 集群执行崩溃恢复的事件是集群中的 Leader 节点服务器发生了异常而无法工作，于是 Follow 服务器会通过投票来决定是否选出新的 Leader 节点服务器。</p><blockquote><p>❝</p><p>投票过程如下：</p><p>❞</p></blockquote><p>当崩溃恢复机制开始的时候，整个 ZooKeeper 集群的每台 Follow 服务器会发起投票，并同步给集群中的其他 Follow 服务器。</p><p>在接收到来自集群中的其他 Follow 服务器的投票信息后，集群中的每个 Follow 服务器都会与自身的投票信息进行对比，如果判断新的投票信息更合适，则采用新的投票信息作为自己的投票信息。在集群中的投票信息还没有达到超过半数原则的情况下，再进行新一轮的投票，最终当整个 ZooKeeper 集群中的 Follow 服务器超过半数投出的结果相同的时候，就会产生新的 Leader 服务器。</p><blockquote><p>❝</p><p>选票结构：</p><p>❞</p></blockquote><p>以 Fast Leader Election 选举的实现方式来讲，如下图所示，一个选票的整体结果可以分为一下六个部分：</p><p><img src="https://s2.loli.net/2023/06/13/yLmI3OM9GSClnrt.png" alt="图片"></p><ul><li>logicClock：用来记录服务器的投票轮次。logicClock 会从 1 开始计数，每当该台服务经过一轮投票后，logicClock 的数值就会加 1 。</li><li>state：用来标记当前服务器的状态。在 ZooKeeper 集群中一台服务器具有 LOOKING、FOLLOWING、LEADERING、OBSERVING 这四种状态。</li><li><code>self_id</code>：用来表示当前服务器的 ID 信息，该字段在 ZooKeeper 集群中主要用来作为服务器的身份标识符。</li><li><code>self_zxid</code>：当前服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</li><li><code>vote_id</code>：投票要被推举的服务器的唯一 ID 。</li><li><code>vote_zxid</code>：被推举的服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</li></ul><p>当 ZooKeeper 集群需要重新选举出新的 Leader 服务器的时候，就会根据上面介绍的投票信息内容进行对比，以找出最适合的服务器。</p><blockquote><p>❝</p><p>选票筛选</p><p>❞</p></blockquote><p>当一台 Follow 服务器接收到网络中的其他 Follow 服务器的投票信息后，是如何进行对比来更新自己的投票信息的。</p><p>Follow 服务器进行选票对比的过程，如下图所示。</p><p><img src="https://s2.loli.net/2023/06/13/Rs7WZUaop3LH8mb.png" alt="图片"></p><p>首先，会对比 logicClock 服务器的投票轮次，当 logicClock 相同时，表明两张选票处于相同的投票阶段，并进入下一阶段，否则跳过。</p><p>接下来再对比<code>vote_zxid</code>被选举的服务器 ID 信息，若接收到的外部投票信息中的 <code>vote_zxid</code>字段较大，则将自己的票中的<code>vote_zxid</code>与<code>vote_myid</code>更新为收到的票中的<code>vote_zxid</code>与<code>vote_myid</code> ，并广播出去。</p><p>要是对比的结果相同，则继续对比<code>vote_myid</code>被选举服务器上所保存的最大事务 ID ，若外部投票的<code>vote_myid</code> 比较大，则将自己的票中的 <code>vote_myid</code>更新为收到的票中的<code>vote_myid</code> 。</p><p>经过这些对比和替换后，最终该台 Follow 服务器会产生新的投票信息，并在下一轮的投票中发送到 ZooKeeper 集群中。</p><p><strong>「消息广播」</strong></p><p>在 Leader 节点服务器处理请求后，需要通知集群中的其他角色服务器进行数据同步。ZooKeeper 集群采用消息广播的方式发送通知。</p><p>ZooKeeper 集群使用原子广播协议进行消息发送，该协议的底层实现过程与二阶段提交过程非常相似，如下图所示。</p><p><img src="https://s2.loli.net/2023/06/13/cAHa28YZrejkpbx.png" alt="图片"></p><p>当要在集群中的其他角色服务器进行数据同步的时候，Leader 服务器将该操作过程封装成一个 Proposal 提交事务，并将其发送给集群中其他需要进行数据同步的服务器。</p><p>当这些服务器接收到 Leader 服务器的数据同步事务后，会将该条事务能否在本地正常执行的结果反馈给 Leader 服务器，Leader 服务器在接收到其他 Follow 服务器的反馈信息后进行统计，判断是否在集群中执行本次事务操作。</p><p>这里请注意 ，与二阶段提交过程不同（即需要集群中所有服务器都反馈可以执行事务操作后，主服务器再次发送 commit 提交请求执行数据变更） ，ZAB 协议算法省去了中断的逻辑，当 ZooKeeper 集群中有超过一半的 Follow 服务器能够正常执行事务操作后，整个 ZooKeeper 集群就可以提交 Proposal 事务了。</p><h1>日志清理</h1><p><strong>「日志类型」</strong></p><p>在 ZooKeeper 服务运行的时候，一般会产生数据快照和日志文件，数据快照用于集群服务中的数据同步，而数据日志则记录了 ZooKeeper 服务运行的相关状态信息。</p><blockquote><p>❝</p><p>其中，数据日志是我们在生产环境中需要定期维护和管理的文件。</p><p>❞</p></blockquote><p><strong>「清理方案」</strong></p><p>如上面所介绍的，面对生产系统中产生的日志，一般的维护操作是备份和清理。</p><p>备份是为了之后对系统的运行情况进行排查和优化，而清理主要因为随着系统日志的增加，日志会逐渐占用系统的存储空间，如果一直不进行清理，可能耗尽系统的磁盘存储空间，并最终影响服务的运行。</p><p><strong>「清理工具」</strong></p><blockquote><p>❝</p><p>Corntab</p><p>❞</p></blockquote><p>首先，我们介绍的是 Linux corntab ，它是 Linux 系统下的软件，可以自动地按照我们设定的时间，周期性地执行我们编写的相关脚本。</p><p>crontab 定时脚本的方式相对灵活，可以按照我们的业务需求来设置处理日志的维护方式，比如这里我们希望定期清除 ZooKeeper 服务运行的日志，而不想清除数据快照的文件，则可以通过脚本设置，达到只对数据日志文件进行清理的目的。</p><blockquote><p>❝</p><p>PurgeTxnLog</p><p>❞</p></blockquote><p>ZooKeeper 自身还提供了 PurgeTxnLog 工具类，用来清理 snapshot 数据快照文件和系统日志。</p><p>PurgeTxnLog 清理方式和我们上面介绍的方式十分相似，也是通过定时脚本执行任务，唯一的不同是，上面提到在编写日志清除 logsCleanWeek 的时候 ，我们使用的是原生 shell 脚本自己手动编写的数据日志清理逻辑，而使用 PurgeTxnLog 则可以在编写清除脚本的时候调用 ZooKeeper 为我们提供的工具类完成日志清理工作。</p><p>如下面的代码所示，首先，我们在<code>/usr/bin</code>目录下创建一个 PurgeLogsClean 脚本。注意这里的脚本也是一个 shell 文件。</p><p>在脚本中我们只需要编写 PurgeTxnLog 类的调用程序，系统就会自动通过 PurgeTxnLog 工具类为我们完成对应日志文件的清理工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh  </span><br><span class="line">java -cp &quot;$CLASSPATH&quot; org.apache.zookeeper.server.PurgeTxnLog </span><br><span class="line">echo &quot;清理完成&quot; </span><br></pre></td></tr></table></figure><p>PurgeTxnLog 方式与 crontab 相比，使用起来更加容易而且也更加稳定安全，不过 crontab 方式更加灵活，我们可以根据不同的业务需求编写自己的清理逻辑。</p><h1>实现分布式锁</h1><p>分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</p><blockquote><p>❝</p><p>实现分布式锁目前有三种流行方案，即基于数据库、Redis、ZooKeeper 的方案</p><p>❞</p></blockquote><p><strong>「方案一：」</strong></p><p>使用节点中的存储数据区域，ZK中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识</p><p><strong>「方案二：」</strong></p><p>使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可</p><p><img src="https://s2.loli.net/2023/06/13/wGeuXEgJdYFrOA6.png" alt="图片"></p><p><strong>「死锁风险:」</strong></p><p>两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁</p><ul><li>方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行</li><li>方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与ZK的连接，ZK检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的</li></ul><p><strong>「避免羊群效应」</strong></p><p>把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。</p><p>如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。</p><blockquote><p>❝</p><p>为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。</p><p>❞</p></blockquote><p>每次锁被释放，只会有一个锁请求者 会被通知到。</p><p>这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。</p><p><img src="https://s2.loli.net/2023/06/13/ioWOQeqBP3fZ7Gs.png" alt="图片"></p><p><strong>「用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：」</strong></p><ul><li>客户端连接 ZooKeeper，并<code>在/lock</code>下创建临时有序子节点，第一个客户端对应的子节点为<code>/lock/lock01/00000001</code>，第二个为 <code>/lock/lock01/00000002</code>；</li><li>其他客户端获取<code>/lock01</code>下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</li><li>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听<code>/lock01</code>的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</li><li>完成业务流程后，删除对应的子节点，释放分布式锁；</li></ul><p>在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。</p><h1>实现分布式ID</h1><p>我们可以通过 ZooKeeper 自身的客户端和服务器运行模式，来实现一个分布式网络环境下的 ID 请求和分发过程。</p><blockquote><p>❝</p><p>每个需要 ID 编码的业务服务器可以看作是 ZooKeeper 的客户端。ID 编码生成器可以作为 ZooKeeper 的服务端。</p><p>❞</p></blockquote><p>客户端通过发送请求到 ZooKeeper 服务器，来获取编码信息，服务端接收到请求后，发送 ID 编码给客户端。</p><p><strong>「实现原理：」</strong></p><p>可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。</p><ul><li>客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。</li><li>客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。</li></ul><p>利用 ZooKeeper 中的顺序节点特性，很容易使我们创建的 ID 编码具有有序的特性。并且我们也可以通过客户端传递节点的名称，根据不同的业务编码区分不同的业务系统，从而使编码的扩展能力更强。</p><blockquote><p>❝</p><p>虽然使用 ZooKeeper 的实现方式有这么多优点，但也会有一些潜在的问题。</p><p>❞</p></blockquote><p>其中最主要的是，在定义编码的规则上还是强烈依赖于程序员自身的能力和对业务的深入理解。</p><p>很容易出现因为考虑不周，造成设置的规则在运行一段时间后，无法满足业务要求或者安全性不够等问题。</p><h1>实现负载均衡</h1><p><strong>「常见负载均衡算法」</strong></p><blockquote><p>❝</p><p>轮询法</p><p>❞</p></blockquote><p>轮询法是最为简单的负载均衡算法，当接收到来自网络中的客户端请求后，负载均衡服务器会按顺序逐个分配给后端服务。</p><p>比如集群中有 3 台服务器，分别是 server1、server2、server3，轮询法会按照 sever1、server2、server3 这个顺序依次分发会话请求给每个服务器。当第一次轮询结束后，会重新开始下一轮的循环。</p><blockquote><p>❝</p><p>随机法</p><p>❞</p></blockquote><p>随机算法是指负载均衡服务器在接收到来自客户端的请求后，会根据一定的随机算法选中后台集群中的一台服务器来处理这次会话请求。</p><p>不过，当集群中备选机器变的越来越多时，通过统计学我们可以知道每台机器被抽中的概率基本相等，因此随机算法的实际效果越来越趋近轮询算法。</p><blockquote><p>❝</p><p>原地址哈希法</p><p>❞</p></blockquote><p>原地址哈希算法的核心思想是根据客户端的 IP 地址进行哈希计算，用计算结果进行取模后，根据最终结果选择服务器地址列表中的一台机器，处理该条会话请求。</p><p>采用这种算法后，当同一 IP 的客户端再次访问服务端后，负载均衡服务器最终选举的还是上次处理该台机器会话请求的服务器，也就是每次都会分配同一台服务器给客户端。</p><blockquote><p>❝</p><p>加权轮询法</p><p>❞</p></blockquote><p>加权轮询的方式与轮询算法的方式很相似，唯一的不同在于选择机器的时候，不只是单纯按照顺序的方式选择，还根据机器的配置和性能高低有所侧重，配置性能好的机器往往首先分配。</p><blockquote><p>❝</p><p>加权随机法</p><p>❞</p></blockquote><p>加权随机法和我们上面提到的随机算法一样，在采用随机算法选举服务器的时候，会考虑系统性能作为权值条件。</p><blockquote><p>❝</p><p>最小连接数法</p><p>❞</p></blockquote><p>最小连接数算法是指，根据后台处理客户端的连接会话条数，计算应该把新会话分配给哪一台服务器。</p><p>一般认为，连接数越少的机器，在网络带宽和计算性能上都有很大优势，会作为最优先分配的对象。</p><p><strong>「利用 ZooKeeper 实现 负载均衡 算法」</strong></p><blockquote><p>❝</p><p>这里我们通过采用最小连接数算法，来确定究竟如何均衡地分配网络会话请求给后台客户端。</p><p>❞</p></blockquote><p>如下图所示，建立的 ZooKeeper 数据模型中 Severs 节点可以作为存储服务器列表的父节点。</p><p>在它下面创建 servers_host1、servers_host2、servers_host3等临时节点来存储集群中的服务器运行状态信息。</p><p><img src="https://s2.loli.net/2023/06/13/MNyiTKv8G39m1qw.png" alt="图片"></p><p>整个实现的过程如下图所示。</p><p><img src="https://s2.loli.net/2023/06/13/xSkpjaoV78LbrYh.png" alt="图片"></p><ul><li>首先，在接收到客户端的请求后，通过 getData 方法获取服务端 Severs 节点下的服务器列表，其中每个节点信息都存储有当前服务器的连接数。</li><li>通过判断选择最少的连接数作为当前会话的处理服务器，并通过 setData 方法将该节点连接数加 1。</li><li>最后，当客户端执行完毕，再调用 setData 方法将该节点信息减 1。</li><li>我们定义当服务器接收到会话请求后。在 ZooKeeper 服务端增加连接数的 addBlance 方法。</li><li>我们通过 readData 方法获取服务器最新的连接数，之后将该连接数加 1，再通过 writeData 方法将新的连接数信息写入到服务端对应节点信息中。</li><li>当服务器处理完该会话请求后，需要更新服务端相关节点的连接数。</li><li>具体的操作与 addBlance 方法基本一样，只是对获取的连接信息进行减一操作。</li></ul><p><strong>「这里注意：」</strong></p><p>我们日常用到的负载均衡器主要是选择后台处理的服务器，并给其分发请求。</p><blockquote><p>❝</p><p>而通过 ZooKeeper 实现的服务器，只提供了服务器的筛选工作。</p><p>❞</p></blockquote><p>在请求分发的过程中，还是通过负载算法计算出要访问的服务器，之后客户端自己连接该服务器，完成请求操作。</p><h1>开源框架使用案例</h1><p><strong>「Dubbo与ZooKeeper」</strong></p><p>Dubbo 是阿里巴巴开发的一套开源的技术框架，是一款高性能、轻量级的开源 Java RPC 框架。</p><p><strong>「用ZooKeeper做注册中心」</strong></p><p>在整个 Dubbo 框架的实现过程中，注册中心是其中最为关键的一点，它保证了整个 PRC 过程中服务对外的透明性。</p><p>而 Dubbo 的注册中心也是通过 ZooKeeper 来实现的。</p><p>如下图所示，在整个 Dubbo 服务的启动过程中，服务提供者会在启动时向 <code>/dubbo/com.foo.BarService/providers</code>目录写入自己的 URL 地址，这个操作可以看作是一个 ZooKeeper 客户端在 ZooKeeper 服务器的数据模型上创建一个数据节点。</p><p>服务消费者在启动时订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址，并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录写入自己的 URL 地址。</p><p>该操作是通过 ZooKeeper 服务器在 /consumers 节点路径下创建一个子数据节点，然后再在请求会话中发起对 /providers 节点的 watch 监控</p><p><img src="https://s2.loli.net/2023/06/13/1wcuq4bsxhfRNPM.png" alt="图片"></p><p><strong>「Kafka与ZooKeeper」</strong></p><p><strong>「Zookeeper的作用」</strong></p><p>由于 Broker 服务器采用分布式集群的方式工作，那么在服务的运行过程中，难免出现某台机器因异常而关闭的状况。</p><p>为了保证整个 Kafka 集群的可用性，需要在系统中监控整个机器的运行情况。而 Kafka 可以通过 ZooKeeper 中的数据节点，将网络中机器的运行统计存储在数据模型中的 brokers 节点下。</p><p>在 Kafka 的 Topic 信息注册中也需要使用到 ZooKeeper ，在 Kafka 中同一个Topic 消息容器可以分成多个不同片，而这些分区既可以存在于一台 Broker 服务器中，也可以存在于不同的 Broker 服务器中。</p><p>而在 Kafka 集群中，每台 Broker 服务器又相对独立。</p><p>为了能够读取这些以分布式方式存储的分区信息，Kafka 会将这些分区信息在 Broker 服务器中的对应关系存储在 ZooKeeper 数据模型的 topic 节点上，每一个 topic 在 ZooKeeper 数据节点上都会以 <code>/brokers/topics/[topic]</code> 的形式存在。</p><p><img src="https://s2.loli.net/2023/06/13/E4QwZ9xHRTFvtIp.png" alt="图片"></p><h1>参考资料</h1><p>《从Paxos到Zookeeper 分布式一致性原理与实践》</p>]]></content>
      
      
      <categories>
          
          <category> 中间件集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件集合 </tag>
            
            <tag> zookeeper </tag>
            
            <tag> 微信公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch篇</title>
      <link href="/posts/64613c36.html"/>
      <url>/posts/64613c36.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：麒麟改bug<br>链接：<a href="https://juejin.cn/post/6958408979235995655">https://juejin.cn/post/6958408979235995655</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="1、elasticsearch-了解多少，说说你们公司-es-的集群架构，索引数据大小，分片有多少，以及一些调优手段-。">1、elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段 。</h2><ul><li>面试官：想了解应聘者之前公司接触的 ES 使用场景、规模，有没有做过比较大规模的索引设计、规划、调优。</li><li>解答：如实结合自己的实践场景回答即可。</li><li>比如：ES 集群架构 13 个节点，索引根据通道不同共 20+索引，根据日期，每日递增 20+，索引：10分片，每日递增 1 亿+数据，每个通道每天索引大小控制：150GB 之内。</li><li>仅索引层面调优手段：</li></ul><h3 id="1-1、设计阶段调优">1.1、设计阶段调优</h3><p>（1）根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索引；</p><p>（2）使用别名进行索引管理；</p><p>（3）每天凌晨定时对索引做 force_merge 操作，以释放空间；</p><p>（4）采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink操作，以缩减存储；</p><p>（5）采取 curator 进行索引的生命周期管理；</p><p>（6）仅针对需要分词的字段，合理的设置分词器；</p><p>（7）Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</p><h3 id="1-2、写入调优">1.2、写入调优</h3><p>（1）写入前副本数设置为 0；</p><p>（2）写入前关闭 refresh_interval 设置为-1，禁用刷新机制；</p><p>（3）写入过程中：采取 bulk 批量写入；</p><p>（4）写入后恢复副本数和刷新间隔；</p><p>（5）尽量使用自动生成的 id。</p><h3 id="1-3、查询调优">1.3、查询调优</h3><p>（1）禁用 wildcard；</p><p>（2）禁用批量 terms（成百上千的场景）；</p><p>（3）充分利用倒排索引机制，能 keyword 类型尽量 keyword；</p><p>（4）数据量大时候，可以先基于时间敲定索引再检索；</p><p>（5）设置合理的路由机制。</p><h3 id="1-4、其他调优">1.4、其他调优</h3><ul><li>部署调优，业务调优等。</li><li>上面的提及一部分，面试者就基本对你之前的实践或者运维经验有所评估了。</li></ul><h2 id="2、elasticsearch-的倒排索引是什么">2、elasticsearch 的倒排索引是什么</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b118b379fcc45e6ba7768e318a141b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>lucene 从 4+版本后开始大量使用的数据结构是 FST。FST 有两个优点：</p><p>（1）空间占用小。通过对词典中单词前缀和后缀的重复利用，压缩了存储空间；</p><p>（2）查询速度快。O(len(str))的查询时间复杂度。</p><h2 id="3、elasticsearch-索引数据多了怎么办，如何调优，部署">3、elasticsearch 索引数据多了怎么办，如何调优，部署</h2><p>面试官：想了解大数据量的运维能力。</p><p>解答：索引数据的规划，应在前期做好规划，正所谓“设计先行，编码在后”，这样才能有效的避免突如其来的数据激增导致集群处理能力不足引发的线上客户检索或者其他业务受到影响。</p><p>如何调优，正如问题 1 所说，这里细化一下：</p><h3 id="3-1-动态索引层面">3.1 动态索引层面</h3><p>基于模板+时间+rollover api 滚动创建索引，举例：设计阶段定义：blog 索引的模板格式为： blog_index_时间戳的形式，每天递增数据。这样做的好处：不至于数据量激增导致单个索引数据量非 常大，接近于上线 2 的32 次幂-1，索引存储达到了 TB+甚至更大。</p><p>一旦单个索引很大，存储等各种风险也随之而来，所以要提前考虑+及早避免。</p><h3 id="3-2-存储层面">3.2 存储层面</h3><p>冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。</p><p>对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，节省存储空间和检索效率。</p><h3 id="3-3-部署层面">3.3 部署层面</h3><ul><li>一旦之前没有规划，这里就属于应急策略。</li><li>结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力，注意：如果之前主节点等规划合理，不需要重启集群也能完成动态新增的。</li></ul><h2 id="4、elasticsearch-是如何实现-master-选举的">4、elasticsearch 是如何实现 master 选举的</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be891153575f418f9cf6552f4fe2f2d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码1GET /_cat/nodes?v&amp;h=ip,port,heapPercent,heapMax,<span class="built_in">id</span>,name</span><br><span class="line">2ip port heapPercent heapMax <span class="built_in">id</span> name复制代码</span><br></pre></td></tr></table></figure><h2 id="5、详细描述一下-Elasticsearch-索引文档的过程">5、详细描述一下 Elasticsearch 索引文档的过程</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a08bec544c2c49e3a8663dd030c6d26b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h2 id="6、详细描述一下-Elasticsearch-搜索的过程？">6、详细描述一下 Elasticsearch 搜索的过程？</h2><p>面试官：想了解 ES 搜索的底层原理，不再只关注业务层面了。</p><p>解答：</p><p>搜索拆解为“query then fetch” 两个阶段。</p><p>query 阶段的目的：定位到位置，但不取。</p><p>步骤拆解如下：</p><p>（1）假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本分片中）的一个。</p><p>（2）每个分片在本地进行查询，结果返回到本地有序的优先队列中。</p><p>（3）第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。</p><p>fetch 阶段的目的：取数据。</p><p>路由节点获取所有文档，返回给客户端。</p><h2 id="7、Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法">7、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法</h2><p>面试官：想了解对 ES 集群的运维能力。</p><p>解答：</p><p>（1）关闭缓存 swap;</p><p>（2）堆内存设置为：Min（节点内存/2, 32GB）;</p><p>（3）设置最大文件句柄数；</p><p>（4）线程池+队列大小根据业务需要做调整；</p><p>（5）磁盘存储 raid 方式——存储有条件使用 RAID10，增加单节点性能以及避免单节点存储故障。</p><h2 id="8、lucence-内部结构是什么？">8、lucence 内部结构是什么？</h2><p>面试官：想了解你的知识面的广度和深度。</p><p>解答：</p><p>Lucene 是有索引和搜索的两个过程，包含索引创建，索引，搜索三个要点。可以基于这个脉络展开一些。</p><h2 id="9、Elasticsearch-是如何实现-Master-选举的？">9、Elasticsearch 是如何实现 Master 选举的？</h2><p>（1）Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个 RPC 来发 现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分；</p><p>（2）对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排序，每次选举每个节 点都把自己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</p><p>（3）如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n/2+1）并且该节点自己也选 举自己，那这个节点就是 master。否则重新选举一直到满足上述条件。</p><p>（4）补充：master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data 节点可以关闭 http 功能*。</p><h2 id="10、Elasticsearch-中的节点（比如共-20-个），其中的-10-个">10、Elasticsearch 中的节点（比如共 20 个），其中的 10 个</h2><p>选了一个 master，另外 10 个选了另一个 master，怎么办？</p><p>（1）当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题；</p><p>（3）当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data节点，避免脑裂问题。</p><h2 id="11、客户端在和集群连接时，如何选择特定的节点执行请求的？">11、客户端在和集群连接时，如何选择特定的节点执行请求的？</h2><p>TransportClient 利用 transport 模块远程连接一个 elasticsearch 集群。它并不加入到集群中，只是简单的获得一个或者多个初始化的 transport 地址，并以 轮询 的方式与这些地址进行通信。</p><h2 id="12、详细描述一下-Elasticsearch-索引文档的过程。">12、详细描述一下 Elasticsearch 索引文档的过程。</h2><p>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scss</span><br><span class="line">复制代码shard = <span class="built_in">hash</span>(document_id) % (num_of_primary_shards)复制代码</span><br></pre></td></tr></table></figure><p>（1）当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 MemoryBuffffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 MomeryBuffffer 到 Filesystem Cache 的过程就叫做 refresh；</p><p>（2）当然在某些情况下，存在 Momery Buffffer 和 Filesystem Cache 的数据可能会丢失，ES 是通过translog 的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中 ， 当 Filesystem cache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flflush；</p><p>（3）在 flflush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</p><p>（4）flflush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；补充：关于 Lucene 的 Segement：</p><p>（1）Lucene 索引是由多个段组成，段本身是一个功能齐全的倒排索引。</p><p>（2）段是不可变的，允许 Lucene 将新的文档增量地添加到索引中，而不用从头重建索引。</p><p>（3）对于每一个搜索请求而言，索引中的所有段都会被搜索，并且每个段会消耗CPU 的时钟周、文件句柄和内存。这意味着段的数量越多，搜索性能会越低。</p><p>（4）为了解决这个问题，Elasticsearch 会合并小段到一个较大的段，提交新的合并段到磁盘，并删除那些旧的小段。</p><h2 id="13、Elasticsearch-是一个分布式的-RESTful-风格的搜索和数据分析引擎。">13、Elasticsearch 是一个分布式的 RESTful 风格的搜索和数据分析引擎。</h2><p>（1）查询 ： Elasticsearch 允许执行和合并多种类型的搜索 — 结构化、非结构化、地理位置、度量指标 — 搜索方式随心而变。</p><p>（2）分析 ： 找到与查询最匹配的十个文档是一回事。但是如果面对的是十亿行日志，又该如何解读呢？Elasticsearch 聚合让您能够从大处着眼，探索数据的趋势和模式。</p><p>（3）速度 ： Elasticsearch 很快。真的，真的很快。</p><p>（4）可扩展性 ： 可以在笔记本电脑上运行。 也可以在承载了 PB 级数据的成百上千台服务器上运行。</p><p>（5）弹性 ： Elasticsearch 运行在一个分布式的环境中，从设计之初就考虑到了这一点。</p><p>（6）灵活性 ： 具备多个案例场景。数字、文本、地理位置、结构化、非结构化。所有的数据类型都欢迎。</p><p>（7）HADOOP &amp; SPARK ： Elasticsearch + Hadoop</p><h2 id="14、Elasticsearch是一个高度可伸缩的开源全文搜索和分析引擎。它允许您快速和接近实时地存储、搜索和分析大量数据。">14、Elasticsearch是一个高度可伸缩的开源全文搜索和分析引擎。它允许您快速和接近实时地存储、搜索和分析大量数据。</h2><p>这里有一些使用Elasticsearch的用例：</p><p>（1）你经营一个网上商店，你允许你的顾客搜索你卖的产品。在这种情况下，您可以使用Elasticsearch来存储整个产品目录和库存，并为它们提供搜索和自动完成建议。</p><p>（2）你希望收集日志或事务数据，并希望分析和挖掘这些数据，以查找趋势、统计、汇总或异常。在这种情况下，你可以使用loghide (Elasticsearch/ loghide /Kibana堆栈的一部分)来收集、聚合和解析数据，然后让loghide将这些数据输入到Elasticsearch中。一旦数据在Elasticsearch中，你就可以运行搜索和聚合来挖掘你感兴趣的任何信息。</p><p>（3）你运行一个价格警报平台，允许精通价格的客户指定如下规则:“我有兴趣购买特定的电子设备，如果下个月任何供应商的产品价格低于X美元，我希望得到通知”。在这种情况下，你可以抓取供应商的价格，将它们推入到Elasticsearch中，并使用其反向搜索(Percolator)功能来匹配价格走势与客户查询，并最终在找到匹配后将警报推送给客户。</p><p>（4）你有分析/业务智能需求，并希望快速调查、分析、可视化，并对大量数据提出特别问题(想想数百万或数十亿的记录)。在这种情况下，你可以使用Elasticsearch来存储数据，然后使用Kibana (Elasticsearch/ loghide /Kibana堆栈的一部分)来构建自定义仪表板，以可视化对您来说很重要的数据的各个方面。此外，还可以使用Elasticsearch聚合功能对数据执行复杂的业务智能查询。</p><h2 id="15、详细描述一下-Elasticsearch-更新和删除文档的过程。">15、详细描述一下 Elasticsearch 更新和删除文档的过程。</h2><p>（1）删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</p><p>（2）磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del 文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</p><p>（3）在新的文档被创建时，Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del 文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉</p><h2 id="16、详细描述一下-Elasticsearch-搜索的过程。">16、详细描述一下 Elasticsearch 搜索的过程。</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b99b31d22d954939a2d1cb8edd4e0cd7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image"></p><h2 id="17、在-Elasticsearch-中，是怎么根据一个词找到对应的倒排索引的？">17、在 Elasticsearch 中，是怎么根据一个词找到对应的倒排索引的？</h2><p>（1）Lucene的索引过程，就是按照全文检索的基本过程，将倒排表写成此文件格式的过程。</p><p>（2）Lucene的搜索过程，就是按照此文件格式将索引进去的信息读出来，然后计算每篇文档打分(score)的过程。</p><h2 id="18、Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？">18、Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</h2><p>（1）64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反。</p><p>（2）如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</p><p>（3）如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。</p><p>（4）即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</p><p>（5）请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在Elasticsearch 的几个地方，使用 Java 的本地序列化。</p><p>（6）通过设置 gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个</p><p>小时缩短为几秒钟。</p><p>（7）Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。</p><p>（8）不要随意修改垃圾回收器（CMS）和各个线程池的大小。</p><p>（9）把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过ES_HEAP_SIZE 环境变量设置。</p><p>（10）内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</p><p>（11）Lucene 使用了大 量 的文件。同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。</p><h2 id="19、对于-GC-方面，在使用-Elasticsearch-时要注意什么？">19、对于 GC 方面，在使用 Elasticsearch 时要注意什么？</h2><p>（1）倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segmentmemory 增长趋势。</p><p>（2）各类缓存，fifield cache, fifilter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache等“自欺欺人”的方式来释放内存。</p><p>（3）避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用scan &amp; scroll api来实现。</p><p>（4）cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node连接。</p><p>（5）想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。</p><p>（6）根据监控数据理解内存需求，合理配置各类circuit breaker，将内存溢出风险降低到最低</p><h2 id="20、Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？">20、Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h2><p>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算 的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p><h2 id="21、在并发情况下，Elasticsearch-如果保证读写一致？">21、在并发情况下，Elasticsearch 如果保证读写一致？</h2><p>（1）可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p><p>（2）另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p><p>（3）对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查</p><p>询主分片，确保文档是最新版本。</p><h2 id="22、如何监控-Elasticsearch-集群状态？">22、如何监控 Elasticsearch 集群状态？</h2><p>Marvel 让你可以很简单的通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性 能，也可以分析过去的集群、索引和节点指标。</p><p>23、介绍下你们电商搜索的整体技术架构。</p><h2 id="24、介绍一下你们的个性化搜索方案？">24、介绍一下你们的个性化搜索方案？</h2><p>基于word2vec和Elasticsearch实现个性化搜索</p><p>（1）基于word2vec、Elasticsearch和自定义的脚本插件，我们就实现了一个个性化的搜索服务，相对于原有的实现，新版的点击率和转化率都有大幅的提升；</p><p>（2）基于word2vec的商品向量还有一个可用之处，就是可以用来实现相似商品的推荐；</p><p>（3）使用word2vec来实现个性化搜索或个性化推荐是有一定局限性的，因为它只能处理用户点击历史这样的时序数据，而无法全面的去考虑用户偏好，这个还是有很大的改进和提升的空间；</p><h2 id="25、是否了解字典树？">25、是否了解字典树？</h2><p>常用字典数据结构如下所示：</p><p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><p>它有 3 个基本性质：</p><p>1）根节点不包含字符，除根节点外每一个节点都只包含一个字符。</p><p>2）从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</p><p>3）每个节点的所有子节点包含的字符都不相同。</p><p>或者用数组来模拟动态。而空间的花费，不会超过单词数×单词长度。</p><p>（2）实现：对每个结点开一个字母集大小的数组，每个结点挂一个链表，使用左儿子右兄弟表示法记</p><p>录这棵树；</p><p>（3）对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查</p><p>询速度上可以保留哈希的复杂度 O(1)</p><h2 id="26、拼写纠错是如何实现的？">26、拼写纠错是如何实现的？</h2><p>（1）拼写纠错是基于编辑距离来实现；编辑距离是一种标准的方法，它用来表示经过插入、删除和替换操作从一个字符串转换到另外一个字符串的最小操作步数；</p><p>（2）编辑距离的计算过程：比如要计算 batyu 和 beauty 的编辑距离，先创建一个7×8 的表（batyu长度为 5，coffffee 长度为 6，各加 2），接着，在如下位置填入黑色数字。其他格的计算过程是取以下</p><p>三个值的最小值：</p><p>如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于 3,3 来说为0）</p><p>左方数字+1（对于 3,3 格来说为 2）</p><p>上方数字+1（对于 3,3 格来说为 2）</p><p>最终取右下角的值即为编辑距离的值 3。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4583e9041b6340f885b3c6001ba27ce2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d3031f047643e582b3c5f8e79b3614~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> elasticsearch篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo篇</title>
      <link href="/posts/bcb6930d.html"/>
      <url>/posts/bcb6930d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Dubbo-是什么？RPC-又是什么？">1.Dubbo 是什么？RPC 又是什么？</h2><p><strong>Dubbo 是一个分布式服务框架</strong>，致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案。</p><p><strong>RPC是远程调用，就是本地机器调用远程机器的一个方法，远程机器返回结果的过程</strong>。</p><p>主要原因是由于单台服务的性能已经无法满足我们了，在这个流量剧增的时代，只有<strong>多台服务器</strong>才能支撑起来现有的用户体系，</p><p>而在这种体系下，服务越来越多，逐渐演化出了现在这种微服务化的 RPC 框架。</p><h2 id="2-Dubbo-能做什么？">2. Dubbo 能做什么？</h2><p>Dubbo 的核心功能主要包含:</p><p><img src="https://s2.loli.net/2023/05/13/WMCYq9ZfHJ2AGOw.png" alt="img"></p><ol><li><strong>远程通讯: dubbo-remoting</strong>模块， 提供对多种基于长连接的 NIO 框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li><li><strong>集群容错</strong>: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>自动发现</strong>: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ol><h2 id="3-能说下-Dubbo-的总体的调用过程吗？">3.能说下 Dubbo 的总体的调用过程吗？</h2><p>调用过程图：</p><img src="https://s2.loli.net/2023/05/13/L1OqJvK7yZU2gFW.png" alt="img" style="zoom:67%;" /><ol><li><p>Proxy 持有一个 Invoker 对象，<strong>使用 Invoker 调用</strong></p></li><li><p>之后通过<strong>Cluster 进行负载容错</strong>，失败重试</p></li><li><p>调用 Directory<strong>获取远程服务的 Invoker</strong>列表</p></li><li><p>负载均衡</p><ul><li><p>用户<strong>配置了路由规则</strong>，则根据路由规则过滤获取到的 Invoker 列表</p></li><li><p>用户没<strong>有配置路由规则或配置路由后还有很多节点</strong>，则使用 <strong>LoadBalance</strong> 方法做负载均衡，选用一个可以调用的 Invoker</p></li></ul></li><li><p><strong>经过一个一个过滤器链</strong>，通常是处理上下文、限流、计数等。</p></li><li><p>会<strong>使用 Client 做数据传输</strong></p></li><li><p><strong>私有化协议的构造</strong>(Codec)</p></li><li><p>进行<strong>序列化</strong></p></li><li><p>服务端收到这个 Request 请求，将其<strong>分配到 ThreadPool</strong>中进行处理</p></li><li><p><strong>Server 来处理这些 Request</strong></p></li><li><p>根据<strong>请求查找对应的 Exporter</strong></p></li><li><p>之后经过一个服务提供者端的<strong>过滤器链</strong></p></li><li><p>然后找到接口实现并<strong>真正的调用</strong>，将请求结果返回</p></li></ol><h2 id="4-说说-Dubbo-支持哪些协议，每种协议的应用场景和优缺点">4.说说 Dubbo 支持哪些协议，每种协议的应用场景和优缺点</h2><p><img src="https://s2.loli.net/2023/05/13/VkyxXRdl5DYbBWC.png" alt="img"></p><ul><li><strong>dubbo</strong>：单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化</li><li><strong>rmi</strong>：采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互 操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏洞</li><li><strong>webservice</strong>：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；</li><li><strong>http</strong>：基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实 现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消 费者，需要给应用程序和浏览器 JS 调用</li><li><strong>hessian</strong>：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；</li><li><strong>memcache</strong>：基于 memcached 实现的 RPC 协议</li><li><strong>redis</strong>：基于 redis 实现的 RPC 协议</li></ul><h2 id="5-Dubbo-中都用到哪些设计模式？">5.Dubbo 中都用到哪些设计模式？</h2><p><img src="https://s2.loli.net/2023/05/13/Rl7Jq69dTEzjChO.png" alt="img"></p><p><strong>责任链模式</strong>:</p><p>责任链模式在 Dubbo 中发挥的作用举足轻重，就像是 Dubbo 框架的骨架。Dubbo 的调用链组织是用责任链模式串连起来的。责任链中的每个节点实现 Filter 接口，然后由 ProtocolFilterWrapper，将所有 Filter 串连起来。Dubbo 的许多功能都是通过 Filter 扩展实现的，比如监控、日志、缓存、安全、telnet 以及 RPC 本身都是。</p><p><strong>观察者模式</strong>:</p><p>Dubbo 中使用观察者模式最典型的例子是 RegistryService。消费者在初始化的时候回调用 subscribe 方法，注册一个观察者，如果观察者引用的服务地址列表发生改变，就会通过 NotifyListener 通知消费者。此外，Dubbo 的 InvokerListener、ExporterListener 也实现了观察者模式，只要实现该接口，并注册，就可以接收到 consumer 端调用 refer 和 provider 端调用 export 的通知。</p><p><strong>修饰器模式</strong>:</p><p>Dubbo 中还大量用到了修饰器模式。比如 ProtocolFilterWrapper 类是对 Protocol 类的修饰。在 export 和 refer 方法中，配合责任链模式，把 Filter 组装成责任链，实现对 Protocol 功能的修饰。其他还有 ProtocolListenerWrapper、 ListenerInvokerWrapper、InvokerWrapper 等。</p><p><strong>工厂方法模式</strong>:</p><p>CacheFactory 的实现采用的是工厂方法模式。CacheFactory 接口定义 getCache 方法，然后定义一个 AbstractCacheFactory 抽象类实现 CacheFactory，并将实际创建 cache 的 createCache 方法分离出来，并设置为抽象方法。这样具体 cache 的创建工作就留给具体的子类去完成。</p><p><strong>抽象工厂模式</strong>:</p><p>ProxyFactory 及其子类是 Dubbo 中使用抽象工厂模式的典型例子。ProxyFactory 提供两个方法，分别用来生产 Proxy 和 Invoker（这两个方法签名看起来有些矛盾，因为 getProxy 方法需要传入一个 Invoker 对象，而 getInvoker 方法需要传入一个 Proxy 对象，看起来会形成循环依赖，但其实两个方式使用的场景不一样）。AbstractProxyFactory 实现了 ProxyFactory 接口，作为具体实现类的抽象父类。然后定义了 JdkProxyFactory 和 JavassistProxyFactory 两个具体类，分别用来生产基于 jdk 代理机制和基于 javassist 代理机制的 Proxy 和 Invoker。</p><p><strong>适配器模式</strong>:</p><p>为了让用户根据自己的需求选择日志组件，Dubbo 自定义了自己的 Logger 接口，并为常见的日志组件（包括 jcl, jdk, log4j, slf4j）提供相应的适配器。并且利用简单工厂模式提供一个 LoggerFactory，客户可以创建抽象的 Dubbo 自定义 Logger，而无需关心实际使用的日志组件类型。在 LoggerFactory 初始化时，客户通过设置系统变量的方式选择自己所用的日志组件，这样提供了很大的灵活性。</p><p><strong>代理模式</strong>:</p><p>Dubbo consumer 使用 Proxy 类创建远程服务的本地代理，本地代理实现和远程服务一样的接口，并且屏蔽了网络通信的细节，使得用户在使用本地代理的时候，感觉和使用本地服务一样。</p><h2 id="6-如果-Dubbo-中-provider-提供的服务由多个版本怎么办？">6.如果 Dubbo 中 provider 提供的服务由多个版本怎么办？</h2><p>可以直接通过 Dubbo 配置中的 version 版本来控制多个版本即可。</p><p>比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.xxxx.rent.service.IDemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;iDemoServiceFirst&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">&quot;com.xxxx.rent.service.IDemoService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;iDemoServiceSecond&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0.1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-服务暴露的流程是怎么样的？">7.服务暴露的流程是怎么样的？</h2><p><img src="https://s2.loli.net/2023/05/13/qZQAueKgNiG72zp.png" alt="img"></p><p>1.通过 ServiceConfig 解析标签，创建 dubbo 标签解析器来<strong>解析 dubbo 的标签</strong>，容器创建完成之后，<strong>触发 ContextRefreshEvent 事件回调开始暴露服务</strong></p><p>2.通过 proxyFactory.getInvoker 方法，并利用<strong>javassist 或 DdkProxyFactory 来进行动态代理</strong>，将服务暴露接口<strong>封装成 invoke</strong>r 对象，里面包含了需要执行的方法的对象信息和具体的 URL 地址。</p><p>3.再通过 DubboProtocol 的实现把包装后的<strong>invoker 转换成 exporter</strong>，</p><p>4.然后<strong>启动服务器 server</strong>，监听端口</p><p>5.最后 RegistryProtocol 保存 URL 地址和 invoker 的映射关系，同时<strong>注册到服务中心</strong></p><p><img src="https://s2.loli.net/2023/05/13/jYcesW1RDPILu6N.png" alt="img"></p><h2 id="8-服务引用的流程是怎么样的？">8.服务引用的流程是怎么样的？</h2><p>1.首先客户端根据 config 文件信息从注册中心<strong>订阅服务</strong>，首次会全量<strong>缓存到本地</strong>，后续的更新会监听动态更新到本地。</p><p>2.之后 DubboProtocol<strong>根据 provider</strong>的地址和接口信息<strong>连接到服务端</strong>server，<strong>开启客户端 clien</strong>t，然后创建 invoker</p><p>3.之后通过 invoker 为服务接口<strong>生成代理对象</strong>，这个代理对象用于远程调用 provider，至此完成了服务引用</p><p><img src="https://s2.loli.net/2023/05/13/NYzF5MoehnP8y4k.png" alt="img"></p><h2 id="9-Dubbo-的注册中心有哪些？">9.Dubbo 的注册中心有哪些？</h2><p><img src="https://s2.loli.net/2023/05/13/bFtgNT5S48uxsAz.png" alt="img"></p><p>Zookeeper、Redis、Multicast、Simple 等都可以作为 Dubbo 的注册中心</p><h2 id="10-聊聊-Dubbo-SPI-机制？">10.聊聊 Dubbo SPI 机制？</h2><p>SPI(Service Provider Interface)，是一种<strong>服务发现机制</strong>，其实就是将结构的实现类写入配置当中，在服务加载的时候将配置文件独处，加载实现类，这样就可以在运行的时候，<strong>动态的帮助接口替换实现类</strong>。</p><p>Dubbo 的 SPI 其实是对 java 的 SPI 进行了一种增强,可以按需加载实现类之外，增加了 IOC 和 AOP 的特性，还有<strong>自适应扩展</strong>机制。</p><p>SPI 在 dubbo 应用很多，包括协议扩展、集群扩展、路由扩展、序列化扩展等等。</p><p>Dubbo 对于文件目录的配置分为了<strong>三类</strong>。</p><ul><li>1.META-INF/services/ 目录：该目录下的 SPI 配置文件是为了用来兼容 Java SPI 。</li><li>2.META-INF/dubbo/ 目录：该目录存放用户自定义的 SPI 配置文件。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key=com.xxx.xxx</span><br></pre></td></tr></table></figure><ul><li>3.META-INF/dubbo/internal/ 目录：该目录存放 Dubbo 内部使用的 SPI 配置文件。</li></ul><h2 id="11-Dubbo-的-SPi-和-Java-的-SPI-有什么区别？">11.Dubbo 的 SPi 和 Java 的 SPI 有什么区别？</h2><p><img src="https://s2.loli.net/2023/05/13/4JPH67o1nbZcTED.png" alt="img"></p><p><strong>Java Spi</strong></p><ul><li>Java SPI 在查找扩展实现类的时候遍历 SPI 的配置文件并且将实现类<strong>全部实例化</strong></li></ul><p><strong>Dubbo Spi</strong></p><ul><li>1，对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</li><li>2，延迟加载，可以一次<strong>只加载自己想要加载的</strong>扩展实现。</li><li>3，增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li><li>4，Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</li></ul><h2 id="12-有哪些负载均衡策略？">12.有哪些负载均衡策略？</h2><p><strong>1.加权随机</strong>：比如我们有三台服务器[A, B, C]，给他们设置权重为[4, 5, 6]，然后讲这三个数平铺在水平线上，和为 15。</p><p>然后在 15 以内生成一个随机数，0 ～ 4 是服务器 A，4 ～ 9 是服务器 B，9 ～ 15 是服务器 C</p><p><img src="https://s2.loli.net/2023/05/13/yrWaBwqGJiYdQC4.png" alt="img"></p><p><strong>2.最小活跃数</strong>：每个服务提供者对应一个活跃数 active，初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。</p><p><img src="https://s2.loli.net/2023/05/13/VzhiAxbLKqITZft.png" alt="img"></p><p><strong>3.一致性 hash</strong>：</p><ul><li>首先求出 memcached 服务器（节点）的哈希值，并将其配置到 0 ～ 2 的 32 次方的圆（continuum）上。</li><li>然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</li><li>然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过 2 的 32 次方仍然找不到服务器，就会保存到第一台 memcached 服务器上。</li></ul><p><img src="https://s2.loli.net/2023/05/13/7bThr29fXj8tHzO.png" alt="img"></p><p><strong>4.加权轮询</strong>：比如我们有三台服务器[A, B, C]，给他们设置权重为[4, 5, 6]，那么假如总共有 15 次请求，那么会有 4 次落在 A 服务器，5 次落在 B 服务器，6 次落在 C 服务器。</p><p><img src="https://s2.loli.net/2023/05/13/59Kx2py7SBzJg8h.png" alt="img"></p><h2 id="13-集群容错方式有哪些？">13.集群容错方式有哪些？</h2><p>1.<strong>Failover Cluster 失败自动切换</strong>：dubbo 的默认容错方案，当调用失败时自动切换到其他可用的节点，具体的重试次数和间隔时间可用通过引用服务的时候配置，默认重试次数为 1 是只调用一次。</p><p>2.<strong>Failback Cluster 失败自动恢复</strong>：在调用失败，记录日志和调用信息，然后返回空结果给 consumer，并且通过定时任务每隔 5 秒对失败的调用进行重试</p><p>3.<strong>Failfast Cluster 快速失败</strong>：只会调用一次，失败后立刻抛出异常</p><p>4.<strong>Failsafe Cluster 失败安全</strong>：调用出现异常，记录日志不抛出，返回空结果</p><p>5.<strong>Forking Cluster 并行调用多个服务提供者</strong>：通过线程池创建多个线程，并发调用多个 provider，结果保存到阻塞队列，只要有一个 provider 成功返回了结果，就会立刻返回结果</p><p>6.<strong>Broadcast Cluster 广播模式</strong>：逐个调用每个 provider，如果其中一台报错，在循环调用结束后，抛出异常。</p><h2 id="14-说说-Dubbo-的分层？">14.说说 Dubbo 的分层？</h2><p>分层图：</p><p><img src="https://s2.loli.net/2023/05/13/1Y8itzqOsDTbGmw.png" alt="img"></p><p>从大的范围来说，dubbo 分为三层</p><ul><li><strong>business</strong>业务逻辑层由我们自己来提供接口和实现还有一些配置信息</li><li><strong>RPC</strong>层就是真正的 RPC 调用的核心层，封装整个 RPC 的调用过程、负载均衡、集群容错、代理</li><li><strong>remoting</strong>则是对网络传输协议和数据转换的封装。</li></ul><p>Service 和 Config 两层可以认为是<strong>API</strong>层，主要提供给<strong>API 使用者</strong>，使用者只需要配置和完成业务代码就可以了。</p><p>后面所有的层级是<strong>SPI</strong>层，主 要提供给扩展者使用主要是用来做<strong>Dubbo 的二次开发</strong>扩展功能。</p><p>再划分到更细的层面，就是图中的 10 层模式。</p><h2 id="16-为什么要通过代理对象通信？？">16.为什么要通过代理对象通信？？</h2><p><img src="https://s2.loli.net/2023/05/13/x7hLHKq6YSloIna.png" alt="img"></p><p>其实主要就是为了将调用细节封装起来，将调用远程方法变得和调用本地方法一样简单，还可以做一些其他方面的增强，比如负载均衡，容错机制，过滤操作，调用数据的统计。</p><h2 id="17-怎么设计一个RPC框架？">17.怎么设计一个RPC框架？</h2><p>关于这个问题，其实核心考察点就是你<strong>对于RPC框架的理解</strong>，一个成熟的RPC框架<strong>可以完成哪些功能</strong>，其实当我们看过一两个RPC框架后，就可以对这个问题回答个七七八八了，我们来举个例子。</p><img src="https://s2.loli.net/2023/05/13/xWeVFU2BGHjcJsz.png" alt="图片" style="zoom:50%;" /><p>1.首先我们得需要一个<strong>注册中心</strong>，去管理消费者和提供者的节点信息，这样才会有消费者和提供才可以去订阅服务，注册服务。</p><p>2.当有了注册中心后，可能会有很多个provider节点，那么我们肯定会有一个<strong>负载均衡</strong>模块来负责节点的调用，至于用户指定路由规则可以使一个额外的优化点。</p><p>3.具体的调用肯定会需要牵扯到通信协议，所以需要一个模块来对<strong>通信协议进行封装</strong>，网络传输还要考虑序列化。</p><p>4.当调用失败后怎么去处理？所以我们还需要一个<strong>容错模块</strong>，来负责失败情况的处理。</p><p>5.其实做完这些一个基础的模型就已经搭建好了，我们还可以有更多的优化点，比如一些请求<strong>数据的监控，配置信息的处理，日志信息的处理</strong>等等。</p><h2 id="18-Dubbo的服务发现流程">18.Dubbo的服务发现流程</h2><ol><li>服务提供者启动时，向Zookeeper注册自己的服务接口和地址信息；</li><li>服务消费者启动时，向Zookeeper订阅自己需要的服务接口；</li><li>Zookeeper返回服务提供者地址信息给服务消费者；</li><li>服务消费者从多个服务提供者中选择一个进行调用。</li></ol><div class="note info flat"><p>具体地，服务提供者在向Zookeeper注册服务接口信息时，会在Zookeeper上创建一个临时节点，该节点包含服务接口名、IP地址和端口等信息。同时，Zookeeper还会监听该节点的变化，当服务提供者下线时或者其他异常情况发生时，Zookeeper会删除该节点。</p><p>服务消费者在向Zookeeper订阅服务接口时，会创建一个持久化节点来监听服务状态的变化，并在该节点下创建订阅的服务接口节点。一旦有新的服务提供者注册到Zookeeper中，服务消费者能够立刻收到通知，从而获取到最新的服务接口地址列表。</p><p>服务消费者根据负载均衡策略，从多个服务提供者中进行选择，并缓存选取的服务提供者地址。如果某个服务提供者异常或下线，服务消费者会将其从缓存中删除，并重新选择可用的服务提供者。</p></div>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> dubbo篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23种设计模式</title>
      <link href="/posts/ea4e979e.html"/>
      <url>/posts/ea4e979e.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>设计模式相关视频，讲得挺好的，至少比马士兵的好，不足的是选集没有排好序，不能自动连播，而且还在连载中</p><p><a class="btn-beautify orange" href="https://space.bilibili.com/282739748/channel/seriesdetail?sid=2583881"   title="TuringPlanet的设计模式" target="_blank"><i class="fa-brands fa-bilibili"></i><span>TuringPlanet的设计模式</span></a></p><p><a class="btn-beautify pink" href="https://github.com/turingplanet/design-patterns-series"   title="视频配套代码" target="_blank"><i class="fa-brands fa-github"></i><span>视频配套代码</span></a></p></div><h2 id="七大原则">七大原则</h2><h3 id="1-设计模式七大原则">1. 设计模式七大原则</h3><p>设计模式六大原则分别为：</p><ol><li><strong>单一职责原则</strong>（SRP）: 一个类只应该有一个引起它变化的原因，即<strong>一个类只负责一项职责</strong>。（有点DDD那味儿）<ul><li><p>高内聚：避免大而全，避免不相关功能的耦合</p></li><li><p>低耦合：减少所需要依赖和被依赖的类</p></li></ul></li><li><strong>开放封闭原则</strong>（OCP）：<strong>对扩展开放，对修改关闭</strong>。当需要改变一个程序的功能或给它增加新功能时，可以通过增加代码来实现，而不是修改已有的代码。<ul><li>测试简单</li><li>可复用性变强</li><li>稳定性变高</li></ul></li><li><strong>里氏替换原则</strong>（LSP）：<strong>子类可以替换其父类并且仍然产生正确的结果</strong>。这表明在使用继承时需要非常小心，子类和父类之间的关系应该是is-a。</li><li><strong>接口隔离原则</strong>（ISP）：<strong>客户端不应该依赖那些它不需要使用的接口</strong>。一个类对另一个类的依赖性应该是建立在最小的接口上。</li><li><strong>依赖倒置原则</strong>（DIP）：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。<strong>抽象不应该依赖于具体实现</strong>，<strong>具体实现应该依赖于抽象</strong>。这个原则的目的是为了减少类之间的耦合。</li><li><strong>迪米特法则</strong>（LoD）：也称<strong>最少知道原则</strong>，即一个对象应该对其他对象有最少的了解。一<strong>个类应该对自己需要耦合或调用的类知道得最少</strong>，<strong>这样可以降低类之间的耦合度</strong>，<strong>提高系统的可维护性和可扩展性</strong>。缺点是有可能存在大量的中介类，增加系统的复杂度</li><li><strong>合成复用原则</strong>：尽量使用对象<strong>聚合/组合</strong>，而不是<strong>继承</strong>来实现软件复用的目的。</li></ol><p><img src="https://s2.loli.net/2023/06/23/naqZ6deNk4LE78y.png" alt="image-20230623174844186"></p><h2 id="创建型模式">创建型模式</h2><div class="note info flat"><p><strong>创建型模式</strong></p><ul><li>帮助我们创建类或者对象</li><li>核心思想:把对象的创建和使用分离，使两者能相对独立地变换</li></ul></div><h3 id="2-单例模式">2. 单例模式</h3><ul><li><p>概念：保证一个类只有一个实例。Spring中用的很多。</p></li><li><p>示例：分为懒汉式和饿汉式</p><ul><li><p>懒汉式：用的时候再实例化，需要注意线程安全问题</p><div class="tabs" id="单例模式之懒汉式"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#单例模式之懒汉式-1">双重校验锁</button></li><li class="tab active"><button type="button" data-href="#单例模式之懒汉式-2">懒汉式完美写法</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="单例模式之懒汉式-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 苹果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是亚当和夏娃吃的那个苹果，独一无二</span></span><br><span class="line"><span class="comment">     * volatile防止指令重排</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Apple INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造器，避免被实例化，但是反射还是可以做到。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Apple</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Apple <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Apple.class)&#123;</span><br><span class="line">                <span class="comment">//防止后续线程在INSTANCE 实例化后，将要return时，</span></span><br><span class="line">                <span class="comment">//其他线程抢到了sync的锁，又new一次</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="单例模式之懒汉式-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple1</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造器，避免被实例化，但是反射还是可以做到。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Apple1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Apple1 INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Apple1 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AppleHolder.APPLE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完美写法，私有内部类在使用时才加载，所以Apple1在使用时才实例化，</span></span><br><span class="line"><span class="comment">     * 同时JVM底层做了线程安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppleHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Apple1</span> <span class="variable">APPLE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li><li><p>饿汉式：类加载完就实例化了</p><div class="tabs" id="写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#写法-1">最实用的写法</button></li><li class="tab"><button type="button" data-href="#写法-2">《Effective Java》枚举写法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="写法-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Apple2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple2</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Apple2</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Apple2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写法有点怪，但是确实能保证只有一个实例</span></span><br><span class="line"><span class="comment"> * 并且线程安全，同时可以防止被反序列化，</span></span><br><span class="line"><span class="comment"> * 因为枚举类没有构造器。</span></span><br><span class="line"><span class="comment"> * 在枚举类型中，实例字段被final修饰，并且是一个在类加载时就被初始化的静态常量。</span></span><br><span class="line"><span class="comment"> * 因此，枚举实现的单例模式是一种饿汉式的变体，也可以看作是一种预先实例化的单例模式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Apple3</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ul></li></ul><h3 id="3-工厂模式">3. 工厂模式</h3><ul><li><p>概念：定义了一个用于创建对象的接口，但让子类决定实例化哪个类</p></li><li><p>示例：下面是一个简单的工厂模式示例代码，实现了在不同的国家/地区生成不同格式的日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DateFormat</span> &#123;</span><br><span class="line">    String <span class="title function_">format</span><span class="params">(LocalDate date)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChinaDateFormat</span> <span class="keyword">implements</span> <span class="title class_">DateFormat</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(LocalDate date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> date.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USDateFormat</span> <span class="keyword">implements</span> <span class="title class_">DateFormat</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">format</span><span class="params">(LocalDate date)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> date.format(DateTimeFormatter.ofPattern(<span class="string">&quot;MM/dd/yyyy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormatFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Country</span> &#123;</span><br><span class="line">        CHINA, US</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DateFormat <span class="title function_">getFormatter</span><span class="params">(Country country)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (country) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHINA:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChinaDateFormat</span>();</span><br><span class="line">            <span class="keyword">case</span> US:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">USDateFormat</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unsupported country: &quot;</span> + country);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>笔者觉得跟策略模式很像……只是这个会返回实例，策略模式是根据选择执行代码。</p></div></li></ul><h3 id="4-抽象工厂模式">4. 抽象工厂模式</h3><ul><li><p>概念：一种创建型设计模式，它提供了<strong>一种创建一系列相关或相互依赖对象的接口</strong>，而无需指定它们具体的类。</p><div class="note info flat"><p>有点拗口，举个例子。小说有魔法，武侠两种类型，他们都有攻击手段，能量两种要素</p><ul><li>魔法：魔咒，魔力（金木水火土等）</li><li>武侠：武功，内力（至阳至刚，至阴至柔等）</li></ul><p>那么抽象工厂就可以分为</p><ul><li>魔法工厂，可以创建魔咒和魔力</li><li>武侠工厂，可以创建武功和内力</li></ul><p>其实就是对工厂分类，一种工厂只能生产同一对象族的东西</p></div></li><li><p>代码实现自己去写了，上面都说得这么明白了</p></li></ul><p><img src="https://s2.loli.net/2023/06/23/wAbYQ1z3vpouT2Z.png" alt="image-20230623230603129"></p><h3 id="5-建造者模式">5. 建造者模式</h3><ul><li><p>概念：主要目的是将一个复杂对象的构建与表示分离，从而可以使用相同的构建过程来创建不同的表示。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//地址类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Location</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> String roomNo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Location loc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建造者，可以使用loc方法给Location对象设置值，</span></span><br><span class="line"><span class="comment">     * 也可以分开通过roomNo和street方法设置值</span></span><br><span class="line"><span class="comment">     * 做到复杂对象可以简单的构建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> String street;</span><br><span class="line">        <span class="keyword">private</span> String roomNo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">name</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">roomNo</span><span class="params">(String roomNo)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.roomNo = roomNo;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">street</span><span class="params">(String street)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.street = street;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">loc</span><span class="params">(String street, String roomNo)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.roomNo = roomNo;</span><br><span class="line">            <span class="built_in">this</span>.street = street;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.street != <span class="literal">null</span> || <span class="built_in">this</span>.roomNo != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Location</span> <span class="variable">location</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Location</span>();</span><br><span class="line">                location.setRoomNo(<span class="built_in">this</span>.roomNo);</span><br><span class="line">                location.setStreet(<span class="built_in">this</span>.street);</span><br><span class="line">                student.loc = location;</span><br><span class="line">            &#125;</span><br><span class="line">            student.name = <span class="built_in">this</span>.name;</span><br><span class="line">            student.age = <span class="built_in">this</span>.age;</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><div class="note info flat"><p>使用建造者模式时，客户端关注的是产品的组装过程，而不是产品的创建细节，因此更加灵活，适用于需要灵活组装、创建复杂对象的场景。同时也方便扩展和修改已有的构建流程，提高了代码的可维护性和可读性。</p></div><h3 id="6-原型模式">6. 原型模式</h3><p>没啥好说的，就是java的<code>clonable</code>接口，浅拷贝和深拷贝的问题。深拷贝就是里面的对象，比方说上面的<code>Student.loc</code>，要实现深拷贝，那<code>Location</code>也要实现<code>clonable</code>接口</p><h2 id="结构型模式">结构型模式</h2><div class="note info flat"><p><strong>结构性模式</strong></p><ul><li>涉及如何组合各种对象以便获得更好、更灵活的结构</li><li>更多地通过组合与运行期的动态结合来实现更灵活的功能</li></ul></div><h3 id="7-适配器模式">7. 适配器模式</h3><ul><li><p>概念：将两个不兼容的接口之间进行桥接，以使它们可以一起工作。适配器模式通过创建一个中间层，将客户端和目标接口分离，从而达到复用已有的代码的目的。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/home/temp/test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//isr就是适配器，让br适配is</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-桥接模式">8. 桥接模式</h3><div class="note info flat"><p>面试里不常问到。有点像套壳贴牌。</p></div><ul><li><p>概念：通过将抽象部分与实现部分分离开来，使它们可以独立地变化。桥接模式通过将抽象和实现解耦，从而可以减少系统中类的数量，并简化类的继承关系。</p></li><li><p>示例：</p><p>定义实现部分接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体实现部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawingAPI1</span> <span class="keyword">implements</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;API1.circle at %f:%f radius %f%n&quot;</span>, x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;API1.rectangle at %f:%f to %f:%f%n&quot;</span>, x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawingAPI2</span> <span class="keyword">implements</span> <span class="title class_">DrawingAPI</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;API2.circle at %f:%f radius %f%n&quot;</span>, x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;API2.rectangle at %f:%f to %f:%f%n&quot;</span>, x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawingAPI drawingAPI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(DrawingAPI drawingAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drawingAPI = drawingAPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y, radius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius, DrawingAPI drawingAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawingAPI);</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawingAPI.drawCircle(x, y, radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x1, y1, x2, y2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2, DrawingAPI drawingAPI)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(drawingAPI);</span><br><span class="line">        <span class="built_in">this</span>.x1 = x1;</span><br><span class="line">        <span class="built_in">this</span>.y1 = y1;</span><br><span class="line">        <span class="built_in">this</span>.x2 = x2;</span><br><span class="line">        <span class="built_in">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        drawingAPI.drawRectangle(x1, y1, x2, y2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们定义了实现部分接口<code>DrawingAPI</code>和具体实现部分<code>DrawingAPI1</code>和<code>DrawingAPI2</code>。在抽象部分中，我们定义了抽象类<code>Shape</code>和具体形状类<code>Circle</code>和<code>Rectangle</code>。可以看到，抽象部分持有一个实现部分对象的引用，并将抽象部分的操作转发给实现部分对象，从而实现了抽象部分与实现部分的解耦。</p><p>使用桥接模式，我们可以将系统中的抽象部分和实现部分解耦开来，减少类的数量，并简化类的继承关系。同时，它还能够提高系统的可扩展性和可维护性，使系统更加灵活，易于修改和扩展。</p></li></ul><h3 id="9-组合模式">9. 组合模式</h3><ul><li><p>概念：将对象组织成树形结构，以表示部分和整体之间的层次关系，并且使得用户对单个对象和组合对象的使用具有一致性。组合模式通过递归组合来实现对整个树形结构的操作，<strong>使得用户在使用时无需知道具体处理的是单个对象还是组合对象</strong>。</p><ul><li>Component：抽象构件，声明了组合中所有对象共有的接口和默认行为。</li><li>Leaf：叶子构件，表示组合中的叶子对象，叶子对象没有子节点。</li><li>Composite：容器构件，表示组合中的容器对象，容器对象可以包含其他组合对象和叶子对象，并且提供了管理其子部件的方法。</li></ul></li><li><p>示例：</p><p>以下是一个简单的组合模式示例代码，用于展示不同部门和员工的层次关系：</p><p>定义抽象构件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Department department)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Department department)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义叶子构件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        <span class="comment">// 叶子节点无法添加子节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        <span class="comment">// 叶子节点无法移除子节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-&quot;</span>.repeat(depth) + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义容器构件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartmentComposite</span> <span class="keyword">extends</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; subDepartments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepartmentComposite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        subDepartments.add(department);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        subDepartments.remove(department);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-&quot;</span>.repeat(depth) + name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Department department : subDepartments) &#123;</span><br><span class="line">            department.display(depth + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们定义了抽象构件<code>Department</code>，并通过叶子构件<code>Employee</code>和容器构件<code>DepartmentComposite</code>来实现其具体子类。容器构件中包含了一个子部件列表，可以添加和移除子部件，并在展示时递归显示其所有子部件。通过使用组合模式，我们可以将部分和整体都看作是“部门”，并且可以统一对它们进行操作，使得客户端代码更加简洁并易于扩展。</p></li></ul><h3 id="10-装饰器模式">10. 装饰器模式</h3><ul><li><p>概念：动态地给一个对象增加一些额外的职责，同时又不改变该对象的结构。</p></li><li><p>示例：装饰器模式通过将对象包装在装饰器对象中，从而使得装饰器对象与被包装的对象拥有相同的接口，以此来扩展对象的功能。</p><div class="tabs" id="装饰器模式"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#装饰器模式-1">抽象类-饮料</button></li><li class="tab"><button type="button" data-href="#装饰器模式-2">实现类-茶</button></li><li class="tab"><button type="button" data-href="#装饰器模式-3">装饰器-柠檬口味</button></li><li class="tab active"><button type="button" data-href="#装饰器模式-4">运行示例</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="装饰器模式-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饮料,不用抽象类也可以。抽象类更符合这个场景，</span></span><br><span class="line"><span class="comment"> * 比如可以把茶替换椰奶等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 口味</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">taste</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="装饰器模式-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 茶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">implements</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">taste</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="装饰器模式-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加柠檬，或者定义其他的，只要是类似结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LemonDecorator</span> <span class="keyword">implements</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Drink drink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LemonDecorator</span><span class="params">(Drink drink)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰器对原有方法加强</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">taste</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;柠檬&quot;</span> + drink.taste();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰器自有增强方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tenth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sugar</span><span class="params">(<span class="type">int</span> tenth)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tenth + <span class="string">&quot;分糖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="装饰器模式-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Drink</span> <span class="variable">drink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tea</span>();</span><br><span class="line">        <span class="type">LemonDecorator</span> <span class="variable">lemonDecorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LemonDecorator</span>(drink);</span><br><span class="line">        <span class="comment">//对原有方法增强</span></span><br><span class="line">        <span class="comment">//柠檬茶</span></span><br><span class="line">        System.out.println(lemonDecorator.taste());</span><br><span class="line">        <span class="comment">//装饰器自己的方法</span></span><br><span class="line">        <span class="comment">//甜度</span></span><br><span class="line">        System.out.println(lemonDecorator.sugar(<span class="number">5</span>));</span><br><span class="line">        <span class="comment">//装饰器也可以变成Drink，实现多态，但是没有甜度的方法</span></span><br><span class="line">        drink = lemonDecorator;</span><br><span class="line">        <span class="comment">//还是柠檬茶</span></span><br><span class="line">        System.out.println(drink.taste());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>这个也是套壳，但是像手机套壳，内里还是手机。桥接模式是换内里，然后内里有相同的方法，不同的实现逻辑</p></div></li></ul><h3 id="11-门面模式（Facade）">11. 门面模式（Facade）</h3><ul><li><p>概念：提供了一个简化的接口，来为复杂的子系统提供一个统一的界面。外观模式的目的是简化客户端与子系统之间的交互，减少客户端代码的复杂度。</p></li><li><p>示例：下面是一个使用外观模式的示例，假设我们有一家咖啡店，客户可以在该咖啡店订购不同类型的咖啡和添加不同的调料。为简化客户端订购咖啡的流程，我们可以使用外观模式，创建一个咖啡外观类作为客户端与咖啡店后台的接口。</p><div class="tabs" id="门面模式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#门面模式-1">定义门面类</button></li><li class="tab"><button type="button" data-href="#门面模式-2">定义子系统</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="门面模式-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFacade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Americano americano;</span><br><span class="line">    <span class="keyword">private</span> Cappuccino cappuccino;</span><br><span class="line">    <span class="keyword">private</span> Latte latte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.americano = <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">        <span class="built_in">this</span>.cappuccino = <span class="keyword">new</span> <span class="title class_">Cappuccino</span>();</span><br><span class="line">        <span class="built_in">this</span>.latte = <span class="keyword">new</span> <span class="title class_">Latte</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderAmericano</span><span class="params">()</span> &#123;</span><br><span class="line">        americano.makeCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderCappuccino</span><span class="params">()</span> &#123;</span><br><span class="line">        cappuccino.makeCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderLatte</span><span class="params">()</span> &#123;</span><br><span class="line">        latte.makeCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="门面模式-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making Americano...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cappuccino</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making Cappuccino...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Latte</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Making Latte...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在上述代码中，我们创建了一个咖啡外观类<code>CoffeeFacade</code>，该类持有各种类型的咖啡对象，客户端只需要调用相应的方法便可以订购对应类型的咖啡。同时我们也创建了<code>Coffee</code>抽象类和其具体子类<code>Americano</code>、<code>Cappuccino</code>和<code>Latte</code>作为子系统，实现了各自特定类型咖啡的制作过程。</p><p>通过使用外观模式，我们将复杂的咖啡店后台与客户端逻辑解耦，并提供了一个简单、易于使用的接口，使得客户端订购咖啡的流程更加简单、直观。</p></li></ul><h3 id="12-享元模式">12. 享元模式</h3><ul><li>概念：通过共享对象来减少内存消耗和提高性能。享元模式的核心思想是将多个相似对象的共同部分抽象出来，作为一个共享对象来使用，而将不同的部分作为外部状态。比如 <strong>线程池</strong></li><li>示例：看下线程池吧</li></ul><h3 id="13-代理模式">13. 代理模式</h3><div class="note info flat"><p>面试考的最多的，Spring AOP用的最多的</p></div><ul><li><p>概念：通过代理控制对象的访问，可以在这个对象调用方法之前、调用方法之后去处理/添加新的功能。</p></li><li><p>常见的代理模式有静态代理，动态代理，cglib代理</p><ul><li><p>静态代理：由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。（笔者觉得这是装饰器模式……）</p></li><li><p>动态代理：JDK提供的API，基于反射生成新的接口实现类（生成的字节码直接在内存中），在调用每个方法时，会调用invoke，走invocationHandler里的逻辑。不用关心代理类，只需要在运行阶段才指定代理哪一个对象，但是只能面向接口类。</p><div class="note info flat"><p><strong>动态代理字节码输出</strong></p><p>通过java.lang.System#setProperty方法设置系统属性</p><p>sun.misc.ProxyGenerator.saveGeneratedFiles=true</p><p>jdk.proxy.ProxyGenerator.saveGeneratedFiles=true</p><p>上述属性二者择其一，具体设置哪个需要依照JDK版本进行选择，老版本的前者，新版本的后者</p></div></li><li><p>cglib代理：也是利用的asm，不同的是它可以代理非接口类，因为它是通过生成目标类的子类来完成的代理。</p></li></ul></li><li><p>代码示例：</p><div class="tabs" id="三种代理"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#三种代理-1">静态代理</button></li><li class="tab"><button type="button" data-href="#三种代理-2">JDK动态代理模式</button></li><li class="tab"><button type="button" data-href="#三种代理-3">cglib方式</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="三种代理-1"><div class="note info flat"><p>我就问，这个装饰器模式有啥区别……</p></div>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">implements</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">taste</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取饮料类型&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeaProxy</span> <span class="keyword">extends</span> <span class="title class_">Tea</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Tea tea;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TeaProxy</span><span class="params">(Tea drink)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.tea = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">taste</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--before--&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">taste</span> <span class="operator">=</span> <span class="built_in">this</span>.tea.taste();</span><br><span class="line">        System.out.println(<span class="string">&quot;--after--&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> taste;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="三种代理-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Drink</span> &#123;</span><br><span class="line">    String <span class="title function_">taste</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tea</span> <span class="keyword">implements</span> <span class="title class_">Drink</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">taste</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取饮料类型&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;茶&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//输出代理类</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="type">Drink</span> <span class="variable">o</span> <span class="operator">=</span> (Drink) Proxy.newProxyInstance(Tea.class.getClassLoader()</span><br><span class="line">                , Tea.class.getInterfaces()</span><br><span class="line">                , (proxy, method, args1) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;--before--&quot;</span>);</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(Tea.class.getConstructor().newInstance());</span><br><span class="line">                    System.out.println(<span class="string">&quot;--after--&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> invoke;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//代理对象调用方法</span></span><br><span class="line">        System.out.println(o.taste());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下反编译之后的代理类</p><p><img src="https://s2.loli.net/2023/06/01/3jIo7qfFQts1HOM.png" alt="image-20230601155512465"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="三种代理-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 喜茶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeaTea</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fruit</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行fruit方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;芒果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sugar</span><span class="params">(<span class="type">int</span> tenth)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行sugar方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tenth + <span class="string">&quot;分糖&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        enhancer.setSuperclass(HeaTea.class);</span><br><span class="line">        enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--before--&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">            System.out.println(<span class="string">&quot;--after--&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> o1;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">HeaTea</span> <span class="variable">o</span> <span class="operator">=</span> (HeaTea) enhancer.create();</span><br><span class="line">        <span class="comment">//输出代理出来的子类 com.example.designmodel.proxy.HeaTea$$EnhancerByCGLIB$$3fe21093</span></span><br><span class="line">        System.out.println(o.getClass().getName());</span><br><span class="line">        System.out.println(o.sugar(<span class="number">5</span>)+o.fruit());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ul><h2 id="行为型模式">行为型模式</h2><div class="note info flat"><p><strong>行为型模式</strong></p><ul><li>用于描述类或者对象是怎样交互和如何分配职责的。</li><li>涉及到算法和对象间的职责分配，描述一组对象应该如何协作来完成一个整体的任务</li></ul></div><h3 id="14-责任链模式">14. 责任链模式</h3><ul><li>概念：可以将多个对象组成一条链，并依次处理请求，直到其中一个对象能够处理该请求为止。在责任链模式中，每个对象都拥有处理请求的机会，但是如果自己不能够处理该请求，则会将请求转发给下一个对象进行处理。这样的设计可以大大降低对象之间的耦合度，使系统更加灵活和可扩展。</li><li>示例：Spring的Filter链就是。</li></ul><h3 id="15-命令模式">15. 命令模式</h3><ul><li>概念：它将请求封装成一个对象，使得可以将不同的请求进行参数化和操作，从而实现请求的解耦和队列化。核心思想是将请求封装成一个命令对象，该命令对象包含了请求的相关信息，例如请求的接收者、请求的操作等。同时，还可以使用回调函数来处理请求的结果，从而实现请求与响应之间的解耦。</li><li>示例：<strong>命令模式常被用于实现撤销</strong>、<strong>重做</strong>、<strong>事务等功能</strong>，<strong>也可以用于实现多级菜单</strong>、<strong>快捷键等用户界面交互功能</strong>。</li></ul><h3 id="16-解释器模式">16. 解释器模式</h3><ul><li>概念：用于定义一个语言或规则的语法，并提供一个解释器来解释语言中的句子或表达式。</li><li>示例：脚本或底层开发才会用到，可以不用了解</li></ul><h3 id="17-迭代器模式">17. 迭代器模式</h3><ul><li>概念：提供了一种访问容器（如列表、集合等）元素的方式，不必暴露容器的内部结构。迭代器模式将遍历与容器的实现分离开来，并为容器提供了一个统一的接口，使得不同类型的容器都可以使用相同的遍历方式。</li><li>示例：看下<code>Iterator</code>的源码吧。通常包括两个核心角色：迭代器 (Iterator) 和容器 (Container)。</li></ul><h3 id="18-中介者模式（Mediator）">18. 中介者模式（Mediator）</h3><ul><li><p>概念：通过引入一个中介者对象，可以让对象间不直接交互，而是通过中介者来实现相互通信和协作。</p></li><li><p>示例：在中介者模式中，通常包括三个角色：中介者 (Mediator)、具体中介者 (Concrete Mediator) 和同事类 (Colleague)。在中介者模式中，同事类之间不直接交互，而是通过中介者来传递消息和协作，因此可以降低对象间的耦合性，使得系统更加易于维护和扩展。</p><div class="tabs" id="中介者模式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#中介者模式-1">Mediator</button></li><li class="tab"><button type="button" data-href="#中介者模式-2">Concrete Mediator</button></li><li class="tab"><button type="button" data-href="#中介者模式-3">Colleague</button></li><li class="tab"><button type="button" data-href="#中介者模式-4">Main</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="中介者模式-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, Colleague colleague)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Colleague colleague)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="中介者模式-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteMediator</span><span class="params">()</span> &#123;</span><br><span class="line">        colleagues = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message, Colleague colleague)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague c : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!c.equals(colleague)) &#123;</span><br><span class="line">                c.receiveMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Colleague colleague)</span> &#123;</span><br><span class="line">        colleagues.add(colleague);</span><br><span class="line">        colleague.setMediator(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Colleague colleague)</span> &#123;</span><br><span class="line">        colleagues.remove(colleague);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="中介者模式-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setMediator</span><span class="params">(Mediator mediator)</span>;</span><br><span class="line">    Mediator <span class="title function_">getMediator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteColleague</span> <span class="keyword">implements</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        mediator.sendMessage(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMediator</span><span class="params">(Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mediator <span class="title function_">getMediator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="中介者模式-4"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line">        <span class="type">Colleague</span> <span class="variable">colleague1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague</span>();</span><br><span class="line">        <span class="type">Colleague</span> <span class="variable">colleague2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteColleague</span>();</span><br><span class="line">        mediator.register(colleague1);</span><br><span class="line">        mediator.register(colleague2);</span><br><span class="line">        colleague1.sendMessage(<span class="string">&quot;Hello, colleague2!&quot;</span>);</span><br><span class="line">        colleague2.sendMessage(<span class="string">&quot;Hi, colleague1!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ul><h3 id="19-备忘录模式-快照模式">19. 备忘录模式/快照模式</h3><ul><li>概念：用于在不破坏封装性的前提下，保存和恢复对象的内部状态</li><li>示例：备忘录模式通过一个备忘录角色来存储对象的状态，并且可以在需要时恢复对象的状态，从而实现撤销和重做等功能。通常和命令模式结合使用。但是，在使用备忘录模式时，需要注意备忘录对象的存储和管理，避免占用过多的内存空间。</li></ul><h3 id="20-观察者模式-发布-订阅模式">20. 观察者模式/发布-订阅模式</h3><ul><li><p>概念：定义了一个一对多的依赖关系，当被依赖的对象状态发生改变时，它的所有依赖者都会收到通知并自动更新。这种模式在应用程序中广泛使用，例如处理事件、用户界面设计，消息中间件和监听器（Listener）等。观察者模式的优点是<strong>遵循开闭原则</strong>，可以在不修改代码的情况下增加新的主题和观察者；同时可以<strong>实现一种松耦合的关系</strong>，<strong>让主题和观察者之间的依赖减小</strong>，提高了系统的灵活性和可维护性。但是，使用观察者模式也有缺点，例如可能会引起内存泄漏问题等。</p></li><li><p>示例：</p><div class="tabs" id="观察者模式"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#观察者模式-1">事件类</button></li><li class="tab"><button type="button" data-href="#观察者模式-2">观察者模式 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="观察者模式-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义发布的事件，通常携带源数据信息，参考下js的监听事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="观察者模式-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(MyEvent event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyEvent</span> <span class="variable">myEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyEvent</span>();</span><br><span class="line">        myEvent.setTitle(<span class="string">&quot;静夜思&quot;</span>);</span><br><span class="line">        myEvent.setAuthor(<span class="string">&quot;李白&quot;</span>);</span><br><span class="line">        myEvent.setContent(<span class="string">&quot;床前明月光，疑是地上霜。举头望明月，低头思故乡。&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.receive(myEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">        subject.registerObserver(event -&gt; System.out.println(<span class="string">&quot;提取作者：&quot;</span>+event.getAuthor()));</span><br><span class="line">        subject.registerObserver(event -&gt; System.out.println(<span class="string">&quot;提取题目：&quot;</span>+event.getTitle()));</span><br><span class="line">        subject.registerObserver(event -&gt; System.out.println(<span class="string">&quot;诗句数量：&quot;</span>+event.getContent().split(<span class="string">&quot;。&quot;</span>).length));</span><br><span class="line">        subject.publish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ul><h3 id="21-状态模式">21. 状态模式</h3><ul><li><p>概念：它允许对象在不同的状态下有不同的行为。</p></li><li><p>示例：<a href="https://juejin.cn/post/6980926247001915422">状态模式-掘金</a></p><div class="note info flat"><p>反正我是不会用这个东西的，给代码挖坑。什么玩意儿……</p></div></li></ul><h3 id="22-策略模式">22. 策略模式</h3><div class="note info flat"><p>这个应该会经常问到</p></div><ul><li><p>概念：定义了一系列算法族，将每个算法封装到具有公共接口的独立类中，并且这些算法之间可以相互替换。</p></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Resp</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换List，生成新的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> origData 原始数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> func     转换的自定义策略，示例直接用了lambda函数，也可以定义成类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;      泛型，原始数据类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;      泛型，返回数据类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; Resp&lt;R&gt; <span class="title function_">toList</span><span class="params">(List&lt;T&gt; origData, Function&lt;List&lt;T&gt;, R&gt; func)</span> &#123;</span><br><span class="line">        Resp&lt;R&gt; tResp = <span class="keyword">new</span> <span class="title class_">Resp</span>&lt;&gt;();</span><br><span class="line">        <span class="type">R</span> <span class="variable">apply</span> <span class="operator">=</span> func.apply(origData);</span><br><span class="line">        tResp.setData(apply);</span><br><span class="line">        <span class="keyword">return</span> tResp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">//转换成整型</span></span><br><span class="line">        Resp&lt;List&lt;Integer&gt;&gt; listResp = Resp.toList(strings, origList -&gt; origList</span><br><span class="line">                .stream()</span><br><span class="line">                .map(Integer::valueOf)</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//转换成浮点</span></span><br><span class="line">        Resp&lt;List&lt;Double&gt;&gt; listResp2 = Resp.toList(strings, origList -&gt; origList</span><br><span class="line">                .stream()</span><br><span class="line">                .map(Double::valueOf)</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">        );</span><br><span class="line">        System.out.println(JSON.toJSONString(listResp,<span class="literal">true</span>));</span><br><span class="line">        System.out.println(JSON.toJSONString(listResp2,<span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="23-模板方法模式">23. 模板方法模式</h3><ul><li><p>概念：定义了一个算法的框架，并在一个方法中定义了该算法的各个步骤，但是把一些步骤的具体实现留给子类去完成。</p></li><li><p>示例：</p><div class="tabs" id="写法"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#写法-1">抽象类（算法骨架）</button></li><li class="tab"><button type="button" data-href="#写法-2">子类</button></li><li class="tab"><button type="button" data-href="#写法-3">Main</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="写法-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        operation1();</span><br><span class="line">        operation2();</span><br><span class="line">        operation3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClass: operation1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClass: operation2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteClass: operation3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="写法-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractClass</span> <span class="variable">abstractClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br><span class="line">        abstractClass.templateMethod();<span class="comment">//固定执行了子类的operation1,2,3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ul><h3 id="24-访问者模式">24. 访问者模式</h3><ul><li>概念：将算法和对象结构分离开来，使得可以在不修改对象结构的情况下，增加新的操作和算法。</li><li>示例：访问者模式的核心在于<strong>同一个事物不同视角下的访问信息不同</strong>，比如看一场篮球比赛，外行人关注的是是否进球，内行人看的是球员的技术，球队的配合等。</li><li>思考：这跟策略模式有啥区别？</li></ul><div class="note info flat"><p>策略模式侧重于<strong>主体结构的变化</strong>，而访问者模式更强调<strong>主体结构不变</strong>，变化的是传入的访问者。</p><p>相同点是，本质上来讲，都是面向接口的编程。</p></div>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> 23种设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka核心技术与实战</title>
      <link href="/posts/717cdc22.html"/>
      <url>/posts/717cdc22.html</url>
      
        <content type="html"><![CDATA[<h2 id="引论">引论</h2><blockquote><p>Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。<strong>同时，它也是一个分布式流处理平台</strong>（Distributed Streaming Platform）</p></blockquote><a class="btn-beautify blue inline" href="https://www.aliyundrive.com/s/mZ7xjW5Y46K"   title="点击获取《kafka核心技术与实战》" target="_blank"><span>点击获取《kafka核心技术与实战》</span></a><a class="btn-beautify purple inline" href="https://www.aliyundrive.com/s/DH6aVAsJiLj"   title="点击获取《Kafka多维度系统精讲，从入门到实战开发》" target="_blank"><span>点击获取《Kafka多维度系统精讲，从入门到实战开发》</span></a><h2 id="术语">术语</h2><h3 id="1-生产者-Producer-、消费者-Consumer-和服务进程Broker">1. 生产者(Producer)、消费者(Consumer)和服务进程Broker</h3><ul><li><p><strong>生产者</strong>：向主题发布消息的客户端应用程序称为<strong>生产者（Producer）</strong>，生产者程序通常持续不断地向一个或多个<strong>主题</strong>发送消息</p></li><li><p><strong>消费者</strong>：订阅这些<strong>主题</strong>消息的客户端应用程序就被称为<strong>消费者（Consumer）</strong></p></li><li><p><strong>服务进程</strong>：Kafka 的服务器端由被称为 <strong>Broker</strong> 的<code>服务进程</code>构成，即一个 Kafka 集群由多个 <strong>Broker</strong> 组成，<strong>Broker</strong> 负责接收和处理客户端发送过来的请求，以及对消息进行<code>持久化</code>。</p><div class="note warning flat"><p>虽然多个 <strong><code>Broker</code></strong> 进程能够运行在同一台机器上，但更常见的做法是<strong>将不同的 <code>Broker</code> 分散运行在不同的机器</strong>上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 <strong><code>Broker</code></strong> 进程都挂掉了，其他机器上的 <strong><code>Broker</code></strong> 也依然能够对外提供服务。这其实就是 Kafka 提供 <strong><code>高可用</code></strong> 的手段之一。</p></div></li></ul><h3 id="2-副本Replication">2. 副本Replication</h3><p>实现高可用的另一个手段就是<code>备份机制（Replication）</code>。备份的思想很简单，就是把<strong>相同的数据</strong>拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为<strong>副本（Replica）</strong>。Kafka 定义了两类副本：<strong>领导者副本（Leader Replica）<strong>和</strong>追随者副本（Follower Replica）</strong>。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，<strong>不能与外界进行交互。</strong></p><div class="note warning flat"><p>MySQL的副本是可以对外提供读服务的。但是在 Kafka 中追随者副本不会对外提供服务。</p></div><p><strong>副本的工作机制</strong>也很简单：生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。</p><h3 id="3-分区（Partitioning）和消息位移（Offset）">3. 分区（Partitioning）和消息位移（Offset）</h3><p>有了副本机制可以保证数据的持久化或消息不丢失，但倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳，需要</p><p>把数据分割成多份保存在不同的 Broker 上。</p><p>Kafka 中的分区机制指的是将每个主题划分成多个<strong>分区（Partition）</strong>，每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。这些位置号也叫<strong>消息位移</strong></p><div class="note info flat"><p>可以参考 <strong>MySQL</strong> 中的 <strong>sharding-jdbc</strong> 配置，或者redis的<code>高可用-横向扩容</code></p></div><h3 id="4-kafka的三层消息结构">4. kafka的三层消息结构</h3><ul><li>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li><li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li><li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li><li>最后，客户端程序只能与分区的领导者副本进行交互。</li></ul><h3 id="5-Kafka-Broker-是如何持久化数据的">5. Kafka Broker 是如何持久化数据的</h3><p>总的来说，Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。</p><ul><li>因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段。</li><li>在 Kafka 底层，一个日志又近一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。</li><li>Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</li></ul><h3 id="6-消费者位移、消费者组和重平衡">6. 消费者位移、消费者组和重平衡</h3><ul><li><strong>消费者组</strong>（Consumer Group）：多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。消费者组中，一个分区只会被一个消费者实例消费。</li><li><strong>消费者位移</strong>（Consumer Offset）：表征消费者消费进度，每个消费者都有自己的消费者位移。</li><li><strong>重平衡</strong>（Rebalance）：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li></ul><div class="note info flat"><p>消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且更酷的是它们还能彼此协助。假设组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者。这个过程就是 Kafka 中大名鼎鼎的“重平衡”（Rebalance）。嗯，其实既是大名鼎鼎，也是臭名昭著，因为由重平衡引发的消费者问题比比皆是。事实上，目前很多重平衡的 Bug 社区都无力解决。</p></div><h2 id="基本使用">基本使用</h2><h3 id="7-操作系统">7. 操作系统</h3><p>kafka是属于jvm系的大数据框架，所以可以跨平台部署。但是以<code>linux</code>系统性能为佳。</p><ul><li><p><strong>I/O 模型的使用</strong>：<code>selector</code>在linux中是<strong>epoll</strong>，在windows中的实现机制是<strong>select</strong>。</p></li><li><p><strong>数据网络传输效率</strong>：Kafka 生产和消费的消息都是通过网络传输的，而消息保存在磁盘。故 Kafka 需要在磁盘和网络间进行大量数据传输。Linux 平台实现了这样的零拷贝机制（当数据在磁盘和网络进行传输时避免昂贵的内核态数据拷贝从而实现快速地数据传输）。</p><div class="note info flat"><p>主流的 I/O 模型通常有 5 种类型：阻塞式 I/O、非阻塞式 I/O、I/O 多路复用、信号驱动 I/O 和异步 I/O。每种 I/O 模型都有各自典型的使用场景，比如 Java 中 Socket 对象的阻塞模式和非阻塞模式就对应于前两种模型；而 Linux 中的系统调用 select 函数就属于 I/O 多路复用模型；大名鼎鼎的 epoll 系统调用则介于第三种和第四种模型之间；至于第五种模型，其实很少有 Linux 系统支持，反而是 Windows 系统提供了一个叫 IOCP 线程模型属于这一种。😑redis为啥快？它也是epoll。</p></div></li></ul><h3 id="8-磁盘">8. 磁盘</h3><p>磁盘类型对于kafka的影响不大，所以机械硬盘物美价廉，最适合kafka。因为kafka的使用方式多是<strong>顺序读写</strong>的，避免了机械硬盘<strong>随机读写数据</strong>的短板。</p><blockquote><p>关于磁盘选择另一个经常讨论的话题就是到底是否应该使用磁盘阵列（RAID）。使用 RAID 的两个主要优势在于：</p><ul><li>提供冗余的磁盘存储空间</li><li>提供负载均衡</li></ul><p>不过就 Kafka 而言，一方面 Kafka 自己实现了冗余机制来提供高可靠性；另一方面通过分区的概念，Kafka 也能在软件层面自行实现负载均衡。如此说来 RAID 的优势就没有那么明显了</p></blockquote><h3 id="9-磁盘容量">9. 磁盘容量</h3><p>规划磁盘容量时你需要考虑下面这几个元素：</p><ul><li>新增消息数</li><li>消息留存时间</li><li>平均消息大小</li><li>备份数</li><li>是否启用压缩</li></ul><h3 id="10-带宽">10. 带宽</h3><p>根据实际使用经验，超过 70% 的带宽阈值就有网络丢包的可能性了，故 70% 的设定是一个比较合理的值。这只是它能使用的最大带宽资源，你不能让 Kafka 服务器常规性使用这么多资源，故通常要再额外预留出 2/3 的资源，即47%左右。可以结合你自己机器的使用情况酌情减少此值。</p><div class="note info flat"><p>总结一下</p><p><img src="https://s2.loli.net/2023/04/30/vDFapAwBehTXNSG.jpg" alt="img"></p></div><h3 id="11-重要的参数配置">11. 重要的参数配置</h3><h4 id="11-1-Broker端参数">11.1. Broker端参数</h4><p>针对存储信息的重要参数有以下这么几个</p><ul><li><strong><code>log.dirs</code></strong>：这是非常重要的参数，指定了 Broker 需要使用的若干个文件目录路径。要知道这个参数是没有默认值的，这说明什么？这说明它必须由你亲自指定。</li><li><strong><code>log.dir</code></strong>：注意这是 dir，结尾没有 s，说明它只能表示单个路径，它是补充上一个参数用的。</li></ul><blockquote><p>这两个参数只要配置 <code>log.dirs</code>就可以了。在线上生产环境中一定要为<code>log.dirs</code>配置多个路径，具体格式是一个 CSV 格式，也就是用逗号分隔的多个路径。如果有条件的话你最好保证这些目录挂载到不同的物理磁盘上。这样做有两个好处：</p><ul><li><strong>提升读写性能</strong>：比起单块磁盘，多块物理磁盘同时读写数据有更高的吞吐量。</li><li><strong>能够实现故障转移</strong>：即 Failover。这是 Kafka 1.1 版本新引入的强大功能。要知道在以前，只要 Kafka Broker 使用的任何一块磁盘挂掉了，整个 Broker 进程都会关闭。但是自 1.1 开始，这种情况被修正了，坏掉的磁盘上的数据会自动地转移到其他正常的磁盘上，而且 Broker 还能正常工作。这个改进正是我们舍弃 RAID 方案的基础：没有这种 Failover 的话，我们只能依靠 RAID 来提供保障。</li></ul></blockquote><p>下面说说与 <strong>ZooKeeper</strong> 相关的设置。<strong>ZooKeeper</strong>是一个分布式协调框架，负责协调管理并保存 Kafka 集群的所有元数据信息，比如集群都有哪些 Broker 在运行、创建了哪些 Topic，每个 Topic 都有多少分区以及这些分区的 Leader 副本都在哪些机器上等信息。</p><ul><li><strong><code>zookeeper.connect</code></strong>: Kafka 与 ZooKeeper 相关的最重要的参数当属<code>zookeeper.connect</code>。这也是一个 CSV 格式的参数，比如我可以指定它的值为<code>zk1:2181,zk2:2181,zk3:2181</code>。2181 是 ZooKeeper 的默认端口。多集群可以在后面加 chroot。例如 <code>zk1:2181,zk2:2181,zk3:2181/kafka1</code>和<code>zk1:2181,zk2:2181,zk3:2181/kafka2</code></li></ul><p>第三组参数是与 Broker 连接相关的，即客户端程序或其他 Broker 如何与该 Broker 进行通信的设置。有以下三个参数：</p><ul><li><strong><code>listeners</code></strong>：学名叫监听器，其实就是告诉外部连接者要通过什么协议访问指定主机名和端口开放的 Kafka 服务。</li><li><strong><code>advertised.listeners</code></strong>：和 listeners 相比多了个 advertised。Advertised 的含义表示宣称的、公布的，就是说这组监听器是 Broker 用于对外发布的。</li><li><s><strong><code>host.name/port</code></strong>：列出这两个参数就是想说你把它们忘掉吧，压根不要为它们指定值，毕竟都是过期的参数了。</s></li></ul><p>第四组参数是关于 Topic 管理的。我来讲讲下面这三个参数：</p><ul><li><code>auto.create.topics.enable</code>：是否允许自动创建 Topic。建议最好设置成 false，即不允许自动创建 Topic。在我们的线上环境里面有很多名字稀奇古怪的 Topic，我想大概都是因为该参数被设置成了 true 的缘故。</li><li><code>unclean.leader.election.enable</code>：是否允许 Unclean Leader 选举。如果设置成 false，则选举保存数据最多的副本为leader。反之，允许从保存数据少的副本中选举leader，这样会丢失更多的数据。</li><li><code>auto.leader.rebalance.enable</code>：是否允许定期进行 Leader 选举。设置它的值为 true 表示允许 Kafka 定期地对一些 Topic 分区进行 Leader 重选举，当然这个重选举不是无脑进行的，它要满足一定的条件才会发生。严格来说它与上一个参数中 Leader 选举的最大不同在于，它不是选 Leader，而是换 Leader！换一次leader成本很高，所以建议设置为false</li></ul><p>最后一组参数是数据留存方面的，即：</p><ul><li><p><code>log.retention.&#123;hour|minutes|ms&#125;</code>：这是个“三兄弟”，都是控制一条消息数据被保存多长时间。从优先级上来说 ms 设置最高、minutes 次之、hour 最低。</p><div class="note info flat"><p>虽然 ms 设置有最高的优先级，但是通常情况下我们还是设置 hour 级别的多一些，比如<code>log.retention.hour=168</code>表示默认保存 7 天的数据，自动删除 7 天前的数据。很多公司把 Kafka 当做存储来使用，那么这个值就要相应地调大。</p></div></li><li><p><code>log.retention.bytes</code>：这是指定 Broker 为消息保存的总磁盘容量大小。这个值默认是 -1，表明你想在这台 Broker 上保存多少数据都可以。</p></li><li><p><code>message.max.bytes</code>：控制 Broker 能够接收的最大消息大小。默认的 1000012 太少了，还不到 1MB。实际场景中突破 1MB 的消息都是屡见不鲜的，因此在线上环境中设置一个比较大的值还是比较保险的做法。</p></li></ul><h4 id="11-2-Topic级别的参数配置">11.2. Topic级别的参数配置</h4><p>如果同时设置了 Topic 级别参数和全局 Broker 参数，Topic级别参数会覆盖Broker的参数。</p><p>保存消息相关的参数：</p><ul><li><strong><code>retention.ms</code></strong>：规定了该 Topic 消息被保存的时长。默认是 7 天，即该 Topic 只保存最近 7 天的消息。一旦设置了这个值，它会覆盖掉 Broker 端的全局参数值。</li><li><strong><code>retention.bytes</code></strong>：规定了要为该 Topic 预留多大的磁盘空间。和全局参数作用相似，这个值通常在多租户的 Kafka 集群中会有用武之地。当前默认值是 -1，表示可以无限使用磁盘空间。</li></ul><h4 id="11-3-JVM参数">11.3. JVM参数</h4><p>设置的方法也很简单，你只需要设置下面这两个环境变量即可：</p><ul><li><code>KAFKA_HEAP_OPTS</code>：指定堆大小。</li><li><code>KAFKA_JVM_PERFORMANCE_OPTS</code>：指定 GC 参数。</li></ul><h2 id="实践及原理剖析">实践及原理剖析</h2><h3 id="12-生产者消息分区机制原理">12. 生产者消息分区机制原理</h3><p>分区的作用就是提供负载均衡的能力，或者说对数据进行分区的主要原因，就是为了实现系统的<strong>高伸缩性</strong>（Scalability）。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来<em>增加整体系统的吞吐量</em>。</p><p>所谓<strong>分区策略</strong>是<strong>决定生产者将消息发送到哪个分区的算法</strong>。Kafka 为我们提供了默认的分区策略，同时它也支持你自定义分区策略。</p><p>如果要自定义分区策略，你需要显式地配置生产者端的参数<code>partitioner.class</code>。这个参数该怎么设定呢？方法很简单，在编写生产者程序时，你可以编写一个具体的类实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口。这个接口也很简单，只定义了两个方法：<code>partition()</code>和<code>close()</code>，通常你只需要实现最重要的 partition 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(String topic, Object key, <span class="type">byte</span>[] keyBytes, Object value, <span class="type">byte</span>[] valueBytes, Cluster cluster)</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>topic</code>、<code>key</code>、<code>keyBytes</code>、<code>value</code>和<code>valueBytes</code>都属于消息数据，<code>cluster</code>则是集群信息（比如当前 Kafka 集群共有多少主题、多少 Broker 等）。Kafka 给你这么多信息，就是希望让你能够充分地利用这些信息对消息进行分区，计算出它要被发送到哪个分区中。只要你自己的实现类定义好了 partition 方法，同时设置<code>partitioner.class</code>参数为你自己实现类的 Full Qualified Name，那么生产者程序就会按照你的代码逻辑对消息进行分区。</p><p>比较常见的分区策略也就那么几种:</p><h4 id="轮询策略">轮询策略</h4><p>也称 Round-robin 策略，即顺序分配。比如一个主题下有 3 个分区，那么第一条消息被发送到分区 0，第二条被发送到分区 1，第三条被发送到分区 2，以此类推。当生产第 4 条消息时又会重新开始，即将其分配到分区 0，就像下面这张图展示的那样。</p><p><img src="https://s2.loli.net/2023/04/30/RrkAXP2MWDJe3qB.png" alt="kafka分区策略_轮询策略"></p><p>这就是所谓的轮询策略。轮询策略是 Kafka Java 生产者 API 默认提供的分区策略。如果你未指定<code>partitioner.class</code>参数，那么你的生产者程序会按照轮询的方式在主题的所有分区间均匀地“码放”消息。</p><div class="note info flat"><p>轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们最常用的分区策略之一。</p></div><h4 id="随机策略">随机策略</h4><p>也称 Randomness 策略。所谓随机就是我们随意地将消息放置到任意一个分区上，如下面这张图所示。</p><p><img src="https://s2.loli.net/2023/04/30/rxLQm1z7boascpe.png" alt="kafka分区策略_随机策略"></p><p>如果要实现随机策略版的 partition 方法，很简单，只需要两行代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure><p>先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。</p><p>本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以<strong>如果追求数据的均匀分布，还是使用轮询策略比较好</strong>。事实上，随机策略是老版本生产者使用的分区策略，在新版本中已经改为轮询了。</p><h4 id="Key-ordering-策略">Key-ordering 策略</h4><p>Kafka 允许为每条消息定义消息键，简称为 Key。这个 Key 的作用非常大，它可以是一个有着明确业务含义的字符串，比如客户代码、部门编号或是业务 ID 等；也可以用来表征消息元数据。特别是在 Kafka 不支持时间戳的年代，在一些场景中，工程师们都是直接将消息创建时间封装进 Key 里面的。一旦消息被定义了 Key，那么你就可以保证同一个 Key 的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略。</p><p><img src="https://s2.loli.net/2023/04/30/1LFAUwKk75yZrsP.png" alt="kafka分区策略_Key-Ordering策略"></p><p>代码实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure><h3 id="13-生产者压缩算法">13. 生产者压缩算法</h3><h4 id="何时压缩？">何时压缩？</h4><p>压缩可能发生在 <strong>生产者</strong> 和 <strong>Broker</strong> 端。</p><p>生产者程序中配置 <code>compression.type</code> 参数即表示启用指定类型的压缩算法，如 <code>GZIP</code>等。</p><p><strong>Broker</strong> 端也有这个参数。如果 <strong>生产者</strong> 和 <strong>Broker</strong> 端两个参数不一致，那么就会有个消息解压和重新压缩的过程。</p><p>其实大部分情况下 Broker 从 Producer 端接收到消息后仅仅是原封不动地保存而不会对其进行任何修改，但这里的“大部分情况”也是要满足一定条件的。有两种例外情况就可能让 Broker 重新压缩消息。</p><ul><li><strong>Broker端指定了和 Producer 端不同的压缩算法</strong>。一旦你在 Broker 端设置了不同的 compression.type 值，就一定要小心了，因为可能会发生预料之外的压缩 / 解压缩操作，通常表现为 Broker 端 CPU 使用率飙升。</li><li><strong>Broker端发生了消息格式转换</strong>。消息格式转换主要是为了兼容老版本的消费者程序。Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩。一般情况下这种消息格式转换对性能是有很大影响的，除了这里的压缩之外，它还让 Kafka 丧失了引以为豪的 <strong>Zero Copy</strong> 特性。</li></ul><h4 id="何时解压？">何时解压？</h4><p>Producer 发送压缩消息到 Broker 后，Broker 照单全收并原样保存起来。当 Consumer 程序请求这部分消息时，Broker 依然原样发送出去，当消息到达 Consumer 端后，由 Consumer 自行解压缩还原成之前的消息。Kafka 会将启用了哪种压缩算法封装进消息集合中，这样当 Consumer 读取到消息集合时，它自然就知道了这些消息使用的是哪种压缩算法。如果用一句话总结一下压缩和解压缩，那么我希望你记住这句话：<strong>Producer 端压缩、Broker 端保持、Consumer 端解压缩。</strong></p><h4 id="各种压缩算法的对比">各种压缩算法的对比</h4><p>下面这张表是 Facebook Zstandard 官网提供的一份压缩算法 benchmark 比较结果：</p><p><img src="https://s2.loli.net/2023/04/30/ikzP8VeyqoIACKh.png" alt="kafka压缩算法"></p><p>在实际使用中，GZIP、Snappy、LZ4 甚至是 zstd 的表现各有千秋。</p><ul><li>吞吐量方面：LZ4 &gt; Snappy &gt; zstd 和 GZIP；</li><li>在压缩比方面，zstd &gt; LZ4 &gt; GZIP &gt; Snappy；</li><li>具体到物理资源，使用 Snappy 算法占用的网络带宽最多，zstd 最少，这是合理的，毕竟 zstd 就是要提供超高的压缩比；在 CPU 使用率方面，各个算法表现得差不多，只是在压缩时 Snappy 算法使用的 CPU 较多一些，而在解压缩时 GZIP 算法则可能使用更多的 CPU。</li></ul><h3 id="14-无消息丢失配置">14. 无消息丢失配置</h3><div class="note danger flat"><p>这块面试很经常会问！</p></div><p>Kafka 到底在什么情况下才能保证消息不丢失呢？</p><p><strong>一句话概括，Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证。</strong></p><ul><li><p><strong>已提交的消息</strong>：当 Kafka 的若干个 Broker 成功地接收到一条消息并写入到日志文件后，它们会告诉生产者程序这条消息已成功提交。此时，这条消息在 Kafka 看来就正式变为“已提交”消息了。</p></li><li><p><strong>有限度的持久化保证</strong>：假如你的消息保存在 N 个 Kafka Broker 上，那么这个前提条件就是这 N 个 Broker 中至少有 1 个存活。只要这个条件成立，Kafka 就能保证你的这条消息永远不会丢失。</p></li></ul><h4 id="“消息丢失”案例">“消息丢失”案例</h4><p><strong>案例 1：生产者程序丢失数据</strong></p><p>Producer 程序丢失消息，这应该算是被抱怨最多的数据丢失场景了。我来描述一个场景：你写了一个 Producer 应用向 Kafka 发送消息，最后发现 Kafka 没有保存，于是大骂：“Kafka 真烂，消息发送居然都能丢失，而且还不告诉我？！”如果你有过这样的经历，那么请先消消气，我们来分析下可能的原因。</p><p>目前 Kafka Producer 是异步发送消息的，也就是说如果你调用的是 producer.send(msg) 这个 API，那么它通常会立即返回，但此时你不能认为消息发送已成功完成。</p><p>这种发送方式有个有趣的名字，叫“fire and forget”，翻译一下就是“发射后不管”。这个术语原本属于导弹制导领域，后来被借鉴到计算机领域中，它的意思是，执行完一个操作后不去管它的结果是否成功。调用 producer.send(msg) 就属于典型的“fire and forget”，因此如果出现消息丢失，我们是无法知晓的。这个发送方式挺不靠谱吧，不过有些公司真的就是在使用这个 API 发送消息。</p><p>如果用这个方式，可能会有哪些因素导致消息没有发送成功呢？其实原因有很多，例如网络抖动，导致消息压根就没有发送到 Broker 端；或者消息本身不合格导致 Broker 拒绝接收（比如消息太大了，超过了 Broker 的承受能力）等。这么来看，让 Kafka“背锅”就有点冤枉它了。就像前面说过的，Kafka 不认为消息是已提交的，因此也就没有 Kafka 丢失消息这一说了。</p><p>不过，就算不是 Kafka 的“锅”，我们也要解决这个问题吧。实际上，解决此问题的方法非常简单：<strong>Producer 永远要使用带有回调通知的发送 API，也就是说不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)</strong>。不要小瞧这里的 callback（回调），它能准确地告诉你消息是否真的提交成功了。一旦出现消息提交失败的情况，你就可以有针对性地进行处理。</p><p>举例来说，如果是因为那些瞬时错误，那么仅仅让 Producer 重试就可以了；如果是消息不合格造成的，那么可以调整消息格式后再次发送。总之，处理发送失败的责任在 Producer 端而非 Broker 端。</p><p>你可能会问，发送失败真的没可能是由 Broker 端的问题造成的吗？当然可能！如果你所有的 Broker 都宕机了，那么无论 Producer 端怎么重试都会失败的，此时你要做的是赶快处理 Broker 端的问题。但之前说的核心论据在这里依然是成立的：Kafka 依然不认为这条消息属于已提交消息，故对它不做任何持久化保证。</p><p><strong>案例 2：消费者程序丢失数据</strong></p><p>Consumer 端丢失数据主要体现在 Consumer 端要消费的消息不见了。Consumer 程序有个“位移”的概念，表示的是这个 Consumer 当前消费到的 Topic 分区的位置。下面这张图来自于官网，它清晰地展示了 Consumer 端的位移数据。</p><p><img src="https://s2.loli.net/2023/04/30/CpbSEvPWNj3Fmsw.png" alt="kafka消息丢失案例_消费者程序丢失数据"></p><p>比如对于 Consumer A 而言，它当前的位移值就是 9；Consumer B 的位移值是 11。</p><p>这里的“位移”类似于我们看书时使用的书签，它会标记我们当前阅读了多少页，下次翻书的时候我们能直接跳到书签页继续阅读。</p><p>正确使用书签有两个步骤：第一步是读书，第二步是更新书签页。如果这两步的顺序颠倒了，就可能出现这样的场景：当前的书签页是第 90 页，我先将书签放到第 100 页上，之后开始读书。当阅读到第 95 页时，我临时有事中止了阅读。那么问题来了，当我下次直接跳到书签页阅读时，我就丢失了第 96～99 页的内容，即这些消息就丢失了。</p><p>同理，Kafka 中 Consumer 端的消息丢失就是这么一回事。要对抗这种消息丢失，办法很简单：<strong>维持先消费消息（阅读），再更新位移（书签）的顺序</strong>即可。这样就能最大限度地保证消息不丢失。</p><p>当然，这种处理方式可能带来的问题是消息的重复处理，类似于同一页书被读了很多遍，但这不属于消息丢失的情形。</p><p><strong>案例3：多线程场景位移更新但是处理失败</strong></p><p>除了上面所说的场景，其实还存在一种比较隐蔽的消息丢失场景。</p><p>我们依然以看书为例。假设你花钱从网上租借了一本共有 10 章内容的电子书，该电子书的有效阅读时间是 1 天，过期后该电子书就无法打开，但如果在 1 天之内你完成阅读就退还租金。</p><p>为了加快阅读速度，你把书中的 10 个章节分别委托给你的 10 个朋友，请他们帮你阅读，并拜托他们告诉你主旨大意。当电子书临近过期时，这 10 个人告诉你说他们读完了自己所负责的那个章节的内容，于是你放心地把该书还了回去。不料，在这 10 个人向你描述主旨大意时，你突然发现有一个人对你撒了谎，他并没有看完他负责的那个章节。那么很显然，你无法知道那一章的内容了。</p><p>对于 Kafka 而言，这就好比 Consumer 程序从 Kafka 获取到消息后开启了多个线程异步处理消息，而 Consumer 程序自动地向前更新位移。假如其中某个线程运行失败了，它负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于 Consumer 而言实际上是丢失了。</p><p>这里的关键在于 Consumer 自动提交位移，与你没有确认书籍内容被全部读完就将书归还类似，你没有真正地确认消息是否真的被消费就“盲目”地更新了位移。</p><p>这个问题的解决方案也很简单：<strong>如果是多线程异步处理消费消息，Consumer 程序不要开启自动提交位移，而是要应用程序手动提交位移</strong>。在这里我要提醒你一下，单个 Consumer 程序使用多线程来消费消息说起来容易，写成代码却异常困难，因为你很难正确地处理位移的更新，<code>也就是说避免无消费消息丢失很简单，但极易出现消息被消费了多次的情况。</code></p><h4 id="最佳实践">最佳实践</h4><ol><li>不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。</li><li>设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li><li>设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li><li>设置 unclean.leader.election.enable = false。这是 Broker 端的参数，它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。</li><li>设置 replication.factor &gt;= 3。这也是 Broker 端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。</li><li>设置 min.insync.replicas &gt; 1。这依然是 Broker 端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。</li><li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。</li><li>确保消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。就像前面说的，这对于单 Consumer 多线程处理的场景而言是至关重要的。</li></ol><h3 id="15-不常用但是高级的功能——客户端的拦截器">15. 不常用但是高级的功能——客户端的拦截器</h3><p>客户端的拦截器设计思想可以参考spring的拦截器。主要有两类：</p><ul><li><p><code>org.apache.kafka.clients.producer.ProducerInterceptor</code>的子类（继承）。ProducerInterceptor主要是两个方法：</p><ul><li><p><code>onSend</code>：发送之前执行</p></li><li><p><code>onAcknowladgement</code>：该方法会在消息成功提交或发送失败之后被调用，并且比callback先执行。</p><div class="note danger flat"><p>值得注意的是，这个方法和 onSend 不是在同一个线程中被调用的，因此如果你在这两个方法中调用了某个共享可变对象，一定要保证线程安全哦。还有一点很重要，这个方法处在 Producer 发送的主路径中，所以最好别放一些太重的逻辑进去，否则你会发现你的 Producer TPS 直线下降。</p></div></li></ul></li><li><p><code>org.apache.kafka.clients.consumer.ConsumerInterceptor</code>的实现类（接口实现）</p><ul><li><code>onConsume</code>：该方法在消息返回给 Consumer 程序之前调用</li><li><code>onCommit</code>：Consumer 在提交位移之后调用该方法。通常你可以在该方法中做一些记账类的动作，比如打日志等。</li></ul></li></ul><p>写好代码后，将 <strong>全限定名</strong> 添加到kafka的配置中。<strong>Kafka 拦截器可以应用于包括客户端监控、端到端系统性能检测、消息审计等多种功能在内的场景</strong>。</p><h3 id="16-Producer的TCP连接">16. Producer的TCP连接</h3><ul><li><p>何时创建？</p><div class="note info flat"><p>在 <code>KafkaProducer</code> 实例化的同时，创建了 <code>KafkaProducer.Sender</code>实例 <strong>sender</strong>，然后 <strong>sender</strong> 与 <strong>Broker</strong> 进行TCP连接</p></div></li><li><p>何时关闭？</p><div class="note info flat"><p>两种情况下会关闭：</p><ul><li>用户显式调用了close方法</li><li>超过配置的最大超时时间 <code>connections.max.idle.ms</code>（默认值为9分钟）没有数据流过</li></ul></div></li></ul><div class="note danger modern"><p>后续内容可以下载专栏自己看，主要是消费者的生产实践经验。</p></div>]]></content>
      
      
      <categories>
          
          <category> 中间件集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 中间件集合 </tag>
            
            <tag> 极客时间专栏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap精选13问</title>
      <link href="/posts/ab05b615.html"/>
      <url>/posts/ab05b615.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>本文转自 <a href="https://tobebetterjavaer.com/interview/java-hashmap-13.html">沉默王二</a></p></div><h3 id="01、HashMap的底层数据结构是什么？">01、HashMap的底层数据结构是什么？</h3><p>JDK 7 中，HashMap 由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>在 JDK 8 中，HashMap 由“数组+链表+红黑树”组成。链表过长，会严重影响 HashMap 的性能，而红黑树搜索的时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK 8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：</p><ul><li>当链表超过 8 且数据总量超过 64 时会转红黑树。</li><li>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树，以减少搜索时间。</li></ul><p>链表长度超过 8 体现在 putVal 方法中的这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure><p>table 长度为 64 体现在 treeifyBin 方法中的这段代码：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MIN_TREEIFY_CAPACITY 的值正好为 64。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>JDK 8 中 HashMap 的结构示意图：</p><p><img src="https://s2.loli.net/2023/05/11/UTOZWzjySDrVuQk.png" alt=""></p><h3 id="02、为什么链表改为红黑树的阈值是-8">02、为什么链表改为红黑树的阈值是 8?</h3><p>因为泊松分布，我们来看作者在源码中的注释：</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we<br>use them only when bins contain enough nodes to warrant use<br>(see TREEIFY_THRESHOLD). And when they become too small (due to<br>removal or resizing) they are converted back to plain bins.  In<br>usages with well-distributed user hashCodes, tree bins are<br>rarely used.  Ideally, under random hashCodes, the frequency of<br>nodes in bins follows a Poisson distribution<br>(<a href="http://en.wikipedia.org/wiki/Poisson_distribution">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a<br>parameter of about 0.5 on average for the default resizing<br>threshold of 0.75, although with a large variance because of<br>resizing granularity. Ignoring variance, the expected<br>occurrences of list size k are (exp(-0.5) pow(0.5, k) /<br>factorial(k)). The first values are:<br>0:    0.60653066<br><br>1:    0.30326533<br><br>2:    0.07581633<br><br>3:    0.01263606<br><br>4:    0.00157952<br><br>5:    0.00015795<br><br>6:    0.00001316<br><br>7:    0.00000094<br><br>8:    0.00000006<br><br>more: less than 1 in ten million</p></blockquote><p>翻译过来大概的意思是：理想情况下使用随机的哈希码，容器中节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的计算公式计算出了桶中元素个数和概率的对照表，可以看到链表中元素个数为 8 时的概率已经非常小，再多的就更少了，所以原作者在选择链表元素个数时选择了 8，是根据概率统计而选择的。</p><h3 id="03、解决hash冲突的办法有哪些？HashMap用的哪种？">03、解决hash冲突的办法有哪些？HashMap用的哪种？</h3><p>解决Hash冲突方法有：</p><ul><li>开放定址法：也称为再散列法，基本思想就是，如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H§,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi。因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的节点上做标记，而不能真正删除节点。</li><li>再哈希法：双重散列，多重散列，提供多个不同的hash函数，当R1=H1(key1)发生冲突时，再计算R2=H2(key1)，直到没有冲突为止。这样做虽然不易产生堆集，但增加了计算的时间。</li><li>链地址法：拉链法，将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li><li>建立公共溢出区：将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</li></ul><p>HashMap中采用的是链地址法 。</p><h3 id="04、为什么在解决-hash-冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树">04、为什么在解决 hash 冲突的时候，不直接用红黑树？而选择先用链表，再转红黑树?</h3><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。</p><p>当元素小于 8 个的时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于 8 个的时候， 红黑树搜索时间复杂度是 O(logn)，而链表是 O(n)，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p><p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><h3 id="05、HashMap默认加载因子是多少？为什么是-0-75，不是-0-6-或者-0-8-？">05、HashMap默认加载因子是多少？为什么是 0.75，不是 0.6 或者 0.8 ？</h3><p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。</p><p><a href="https://mp.weixin.qq.com/s/a3qfatEWizKK1CpYaxVBbA">详情参照这篇</a></p><h3 id="06、HashMap-中-key-的存储索引是怎么计算的？">06、HashMap 中  key 的存储索引是怎么计算的？</h3><p>首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&amp;（length-1）计算得到存储的位置。</p><p><a href="https://mp.weixin.qq.com/s/aS2dg4Dj1Efwujmv-6YTBg">详情参照这篇</a></p><h3 id="07、JDK-8-为什么要-hashcode-异或其右移十六位的值？">07、JDK 8 为什么要 hashcode 异或其右移十六位的值？</h3><p>因为在JDK 7 中扰动了 4 次，计算 hash 值的性能会稍差一点点。</p><p>从速度、功效、质量来考虑，JDK 8 优化了高位运算的算法，通过hashCode()的高16位异或低16位实现：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>。</p><p>这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p><h3 id="08、为什么-hash-值要与length-1相与？">08、为什么 hash 值要与length-1相与？</h3><ul><li>把 hash 值对数组长度取模运算，模运算的消耗很大，没有位运算快。</li><li>当 length 总是 2 的n次方时，<code>h&amp; (length-1) </code>运算等价于对length取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。</li></ul><h3 id="09、HashMap数组的长度为什么是-2-的幂次方？">09、HashMap数组的长度为什么是 2 的幂次方？</h3><p>2 的 N 次幂有助于减少碰撞的几率。如果 length 为2的幂次方，则 length-1 转化为二进制必定是11111……的形式，在与h的二进制与操作效率会非常的快，而且空间不浪费。我们来举个例子，看下图：</p><p><img src="https://s2.loli.net/2023/05/11/pJz8FlEACavemPX.png" alt=""></p><p>当 length =15时，6 和 7 的结果一样，这样表示他们在 table 存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，4和5的结果也是一样，这样就会导致查询速度降低。</p><p>如果我们进一步分析，还会发现空间浪费非常大，以 length=15 为例，在 1、3、5、7、9、11、13、15 这八处没有存放数据。因为hash值在与14（即 1110）进行&amp;运算时，得到的结果最后一位永远都是0，即 0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的。</p><p><strong>再补充数组容量计算的小奥秘。</strong></p><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。会取大于或等于这个数的 且最近的2次幂作为 table 数组的初始容量，使用tableSizeFor(int)方法，如 tableSizeFor(10) = 16（2 的 4 次幂），tableSizeFor(20) = 32（2 的 5 次幂），也就是说 table 数组的长度总是 2 的次幂。JDK 8 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>让cap-1再赋值给n的目的是另找到的目标值大于或等于原值。例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。减1后二进制为111，再进行操作则会得到原来的数值1000，即8。</p><h3 id="10、HashMap-的put方法流程？">10、HashMap 的put方法流程？</h3><p>以JDK 8为例，简要流程如下：</p><p>1、首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</p><p>2、如果数组是空的，则调用 resize 进行初始化；</p><p>3、如果没有哈希冲突直接放在对应的数组下标里；</p><p>4、如果冲突了，且 key 已经存在，就覆盖掉 value；</p><p>5、如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；</p><p>6、如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。</p><p><img src="https://s2.loli.net/2023/05/11/smyq8TciftZVB9O.png" alt=""></p><h3 id="11、HashMap-的扩容方式？">11、HashMap 的扩容方式？</h3><p>HashMap 在容量超过负载因子所定义的容量之后，就会扩容。</p><p><a href="https://mp.weixin.qq.com/s/0KSpdBJMfXSVH63XadVdmw">详情参照这篇</a></p><h3 id="12、一般用什么作为HashMap的key">12、一般用什么作为HashMap的key?</h3><p>一般用Integer、String 这种不可变类当作 HashMap 的 key，String 最为常见。</p><ul><li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。</li><li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的。Integer、String 这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li></ul><h3 id="13、HashMap为什么线程不安全？">13、HashMap为什么线程不安全？</h3><ul><li>JDK 7 时多线程下扩容会造成死循环。</li><li>多线程的put可能导致元素的丢失。</li><li>put和get并发时，可能导致get为null。</li></ul><p><a href="https://mp.weixin.qq.com/s/qk_neCdzM3aB6pVWVTHhNw">详情参照这篇</a></p><blockquote><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/362214327">https://zhuanlan.zhihu.com/p/362214327</a></p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap精选13问 </tag>
            
            <tag> java面试八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka篇</title>
      <link href="/posts/80596e28.html"/>
      <url>/posts/80596e28.html</url>
      
        <content type="html"><![CDATA[<h2 id="引论">引论</h2><blockquote><p>Kafka 属于分布式的消息引擎系统，它的主要功能是提供一套完备的消息发布与订阅解决方案。在 Kafka 中，发布订阅的对象是主题（Topic），你可以为每个业务、每个应用甚至是每类数据都创建专属的主题。<strong>同时，它也是一个分布式流处理平台</strong>（Distributed Streaming Platform）</p></blockquote><a class="btn-beautify blue inline" href="https://www.aliyundrive.com/s/mZ7xjW5Y46K"   title="点击获取《kafka核心技术与实战》" target="_blank"><span>点击获取《kafka核心技术与实战》</span></a><a class="btn-beautify purple inline" href="https://www.aliyundrive.com/s/DH6aVAsJiLj"   title="点击获取《Kafka多维度系统精讲，从入门到实战开发》" target="_blank"><span>点击获取《Kafka多维度系统精讲，从入门到实战开发》</span></a><h2 id="1、Kafka-的设计">1、Kafka 的设计</h2><p>Kafka 将消息以 topic 为单位进行归纳，发布消息的程序称为 <strong>Producer</strong>，消费消息的程序称为 <strong>Consumer</strong>。它是以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 <strong>Broker</strong>，Producer 通过网络将消息发送到 kafka 集群，集群向消费者提供消息，broker 在中间起到一个代理保存消息的中转站。</p><p><strong>Kafka 中重要的组件</strong></p><p><em>1）Producer</em>：消息生产者，发布消息到Kafka集群的终端或服务</p><p><em>2）Broker</em>：一个 Kafka 节点就是一个 Broker，多个Broker可组成一个Kafka 集群。</p><blockquote><p>如果某个 Topic 下有 n 个Partition 且集群有 n 个Broker，那么每个 Broker会存储该 Topic 下的一个 Partition</p><p>如果某个 Topic 下有 n 个Partition 且集群中有 m+n 个Broker，那么只有 n 个Broker会存储该Topic下的一个 Partition</p><p>如果某个 Topic 下有 n 个Partition 且集群中的Broker数量小于 n，那么一个 Broker 会存储该 Topic 下的一个或多个 Partition，这种情况尽量避免，会导致集群数据不均衡</p></blockquote><p><em>3）Topic</em>：消息主题，每条发布到Kafka集群的消息都会归集于此，Kafka是面向Topic 的</p><p><em>4）Partition</em>：Partition 是Topic在物理上的分区，一个Topic可以分为多个Partition，每个Partition是一个有序的不可变的记录序列。单一主题中的分区有序，但无法保证主题中所有分区的消息有序。</p><p><em>5）Consumer</em>：从Kafka集群中消费消息的终端或服务</p><p><em>6）Consumer Group</em>：每个Consumer都属于一个Consumer Group，每条消息只能被Consumer Group中的一个Consumer消费，但可以被多个Consumer Group消费。</p><p><em>7）Replica</em>：Partition 的副本，用来保障Partition的高可用性。</p><p><em>8）Controller：</em> Kafka 集群中的其中一个服务器，用来进行Leader election以及各种 Failover 操作。</p><p><em>9）Zookeeper</em>：Kafka 通过Zookeeper来存储集群中的 meta 消息</p><h2 id="2、Kafka-性能高原因">2、Kafka 性能高原因</h2><ul><li><p>日志的顺序读写，日志分段和快速检索</p></li><li><p>partition机制</p></li><li><p>批量的收发机制和数据压缩</p></li><li><p>多路复用和零拷贝（linux下性能最高，用的epoll模型，参考<a href="/posts/717cdc22.html#7-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">kafka核心技术与实战</a>）</p><div class="note info flat"><ul><li><p>顺序读写可以弥补磁盘的短板——<a href="/posts/717cdc22.html#5-Kafka-Broker-%E6%98%AF%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%9A%84">随机IO读写，提高吞吐量</a>。</p></li><li><p>partition机制可以类比elastic search的分片，多分区可以并行检索。</p></li><li><p>批量收发可以类比 buffer，减少上下文切换。数据压缩也只有在批量的情况下才有意义，批量数据压缩能节省更多的带宽。</p></li></ul></div></li></ul><h2 id="3、Kafka-文件高效存储设计原理">3、Kafka 文件高效存储设计原理</h2><p>总的来说，Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。</p><ul><li>因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高吞吐量特性的一个重要手段。</li><li>在 Kafka 底层，一个日志又近一步细分成多个日志段 <strong>segment</strong>，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。</li><li>Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</li></ul><div class="note info flat"><p><strong>segment</strong> 存储设计：</p><p>1）<strong>Partition</strong> 只会追加消息到最后一个 <strong>segment</strong>，</p><p>2）<strong>segment</strong> 大小达到一定阈值之后才会 flush 到磁盘中。</p><p>3）<strong>segment</strong> 分为两部分，index.log + data.log</p></div><h2 id="4、kafka的优缺点">4、kafka的优缺点</h2><p><strong>优点</strong></p><ul><li>高性能、高吞吐量、低延迟：Kafka 生产和消费消息的速度都达到每秒10万级</li><li>高可用：所有消息持久化存储到磁盘，并支持数据备份防止数据丢失</li><li>高并发：支持数千个客户端同时读写</li><li>容错性：允许集群中节点失败（若副本数量为n，则允许 n-1 个节点失败）</li><li>高扩展性：Kafka 集群支持热伸缩，无须停机</li></ul><p><strong>缺点</strong></p><ul><li><p>没有完整的监控工具集</p></li><li><p>不支持通配符主题选择</p></li><li><p>不能保证消息的有序性</p><div class="note info flat"><p>主要是 <strong>partition机制</strong>，如果需要保证消息的有序性，要根据业务场景，给每个消息加上特定的key。一般采用key+offset的方法，即按同key下的offset排序。</p></div></li></ul><h2 id="5、Kafka-的应用场景">5、Kafka 的应用场景</h2><ol><li><strong>日志聚合</strong>：可收集各种服务的日志写入kafka的消息队列进行存储</li><li><strong>消息系统</strong>：广泛用于消息中间件(kafka是分布式流平台，但是具有消息系统的订阅发布功能)</li><li><strong>系统解耦</strong>：在重要操作完成后，发送消息，由别的服务系统来完成其他操作</li><li><strong>削峰填谷</strong>：一般用于秒杀或抢购活动中，来缓冲网站短时间内高流量带来的压力</li><li><strong>流式数据处理</strong>：比如spark streaming和 Flink</li></ol><h2 id="6、Kafka-中分区的概念（partition机制）">6、Kafka 中分区的概念（partition机制）</h2><p>Kafka 中的分区机制指的是将每个主题划分成多个<strong>分区（Partition）</strong>，每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。如你所见，Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。这些位置号也叫<strong>消息位移</strong>。</p><p>在分区中又引入了多副本（replica）的概念，通过增加副本数量可以提高容灾能力。同一分区的不同副本中保存的是相同的消息。副本之间是一主多从的关系，其中主副本负责读写，从副本只负责消息同步。副本处于不同的 broker 中，当主副本出现异常，便会在从副本中提升一个为主副本。</p><p>参考 <a href="/posts/717cdc22.html#3-%E5%88%86%E5%8C%BA%EF%BC%88Partitioning%EF%BC%89%E5%92%8C%E6%B6%88%E6%81%AF%E4%BD%8D%E7%A7%BB%EF%BC%88Offset%EF%BC%89">kafka核心技术与实战</a></p><h2 id="7、Kafka-中分区的规则">7、Kafka 中分区的规则</h2><ol><li>指明Partition的情况下，直接将指明的值作为Partition值</li><li>没有指明Partition值但有 key 的情况下，将 key 的 Hash 值与 topic 的Partition值进行取余得到Partition值</li><li>既没有Partition值又没有 key 值的情况下，第一次调用时随机生成一个整数（后面每次调用在这个整数上自增），将这个值与Topic可用的Partition总数取余得到Parittion值，也就是常说的 轮询(round-robin) 算法</li></ol><h2 id="8、Kafka-为什么要把消息分区">8、Kafka 为什么要把消息分区</h2><ol><li>多分区切割数据，方便横向扩容，实现系统的高伸缩性。</li><li>负载均衡。因为是顺序读写，多分区可以并行读写，提高效率。</li></ol><div class="note info flat"><p>类比elastic search的分片。参考 [kafka核心技术和实战——生产者分区机制原理](/posts/717cdc22.html#12. 生产者消息分区机制原理)</p></div><h2 id="9、Kafka-中生产者运行流程">9、Kafka 中生产者运行流程</h2><ol><li>一条消息发过来首先会被封装成一个 <code>ProducerRecord</code> 对象</li><li>对该对象进行<strong>序列化处理</strong>（可以使用默认，也可以自定义序列化）</li><li><strong>对消息进行分区处理</strong>，分区的时候需要获取集群的元数据，决定这个消息会被发送到哪个主题的哪个分区</li><li><strong>分好区的消息不会直接发送到服务端，而是放入生产者的缓存区</strong>，多条消息会被封装成一个批次（Batch），默认一个批次的大小是 16KB</li><li>Sender 线程启动以后会<strong>从缓存里面去获取可以发送的批次</strong></li><li>Sender 线程把一个一个批次发送到服务端</li></ol><img src="https://s2.loli.net/2023/05/10/TtiXqgwrUvh2sbG.png" alt="kafka中生产者运行流程" style="zoom: 67%;" /><h2 id="10、Kafka-的批量发送">10、Kafka 的批量发送</h2><p>在Kafka 中 <strong>Producer</strong> 可以 <strong>Batch</strong> 的方式推送数据达到提高效率的作用。<strong>Kafka Producer</strong> 可以将消息在内存中累积到一定数量后作为一个 <strong>Batch</strong> 发送请求。Batch 的数量大小可以通过 <strong>Producer</strong> 的参数进行控制，可以从三个维度进行控制</p><ul><li>累计的消息的数量（如500条）</li><li>累计的时间间隔（如100ms）</li><li>累计的数据大小（如64KB）</li></ul><p>通过增加 Batch 的大小，可以减少网络请求和磁盘I/O的频次，具体参数配置需要在效率和时效性做一个权衡。</p><h2 id="11、Kafka-消息的消费模式">11、Kafka 消息的消费模式</h2><div class="note info flat"><p>Kafka采用大部分消息系统遵循的传统模式：Producer将消息推送到Broker，Consumer从Broker获取消息。</p></div><p>如果采用 <strong>Push</strong> 模式，则Consumer难以处理不同速率的上游推送消息。</p><p>采用 <strong>Pull</strong> 模式的好处是Consumer可以自主决定是否批量的从Broker拉取数据。Pull模式有个缺点是，如果Broker没有可供消费的消息，将导致Consumer不断在循环中轮询，直到新消息到达。为了避免这点，Kafka有个参数 <code>fetch.min.bytes</code> 可以让Consumer阻塞直到新消息到达。</p><div class="note info flat"><p><strong><a href="http://fetch.max.wait.ms">fetch.max.wait.ms</a></strong></p><p>这个参数也和 <code>fetch.min.bytes</code> 参数有关，如果 Kafka 仅仅参考 <code>fetch.min.bytes</code> 参数的要求，那么有可能会一直阻塞等待而无法发送响应给 Consumer，显然这是不合理的。<code>fetch.max.wait.ms</code> 参数用于指定 Kafka 的等待时间，默认值为500（ms）。如果 Kafka 中没有足够多的消息而满足不了 <code>fetch.min.bytes</code> 参数的要求，那么最终会等待500ms。这个参数的设定和 Consumer 与 Kafka 之间的延迟也有关系，如果业务应用对延迟敏感，那么可以适当调小这个参数</p></div><h2 id="12、Kafka-如何实现负载均衡与故障转移">12、Kafka 如何实现负载均衡与故障转移</h2><div class="note info flat"><p>负载均衡是指<strong>让系统的负载根据一定的规则均衡地分配在所有参与工作的服务器上，从而最大限度保证系统整体运行效率与稳定性</strong></p></div><p><strong>负载均衡</strong></p><p>Kakfa 的负载均衡就是每个 <strong>Broker</strong> 都有均等的机会为 Kafka 的客户端（生产者与消费者）提供服务，可以负载分散到所有集群中的机器上。Kafka 通过智能化的分区领导者选举来实现负载均衡，提供智能化的 Leader 选举算法，可在集群的所有机器上均匀分散各个Partition的Leader，从而整体上实现负载均衡。</p><p><strong>故障转移</strong></p><p>Kafka 的故障转移是通过使用<strong>会话机制</strong>实现的，每台 Kafka 服务器启动后会以会话的形式把自己注册到 Zookeeper 服务器上。一旦服务器运转出现问题，就会导致与Zookeeper 的会话不能维持从而超时断连，此时Kafka集群会选举出另一台服务器来完全替代这台服务器继续提供服务。</p><h2 id="13、Kafka-中-Zookeeper-的作用">13、Kafka 中 Zookeeper 的作用</h2><p>kafka是强依赖于zookeeper的中间件。</p><ul><li>Kafka 的各 Broker 在启动时都要在Zookeeper上注册，由Zookeeper统一协调管理。</li><li>如果任何节点失败，可通过Zookeeper从先前提交的偏移量中恢复，因为它会做周期性提交偏移量工作。</li><li>同一个Topic的消息会被分成多个分区并将其分布在多个Broker上，这些分区信息及与Broker的对应关系也是Zookeeper在维护。</li></ul><h2 id="14、Kafka-提供了哪些系统工具">14、Kafka 提供了哪些系统工具</h2><ul><li><strong>Kafka 迁移工具</strong>：它有助于将代理从一个版本迁移到另一个版本</li><li><strong>Mirror Maker</strong>：Mirror Maker 工具有助于将一个 Kafka 集群的镜像提供给另一个</li><li><strong>消费者检查</strong>：对于指定的主题集和消费者组，可显示主题、分区、所有者</li></ul><div class="note info flat"><p>开发人员应该用不到这些东西。觉得没啥必要记。</p></div><h2 id="15、Kafka-中消费者与消费者组的关系与负载均衡实现">15、Kafka 中消费者与消费者组的关系与负载均衡实现</h2><p>Consumer Group 是Kafka独有的可扩展且具有容错性的消费者机制。一个组内可以有多个Consumer，它们共享一个全局唯一的Group ID。组内的所有Consumer协调在一起来消费订阅主题（Topic）内的所有分区（Partition）。当然，每个Partition只能由同一个Consumer Group内的一个Consumer 来消费。消费组内的消费者可以使用多线程的方式实现，消费者的数量通常不超过分区的数量，且二者最好保持整数倍的关系，这样不会造成有空闲的消费者。</p><blockquote><p>Consumer 订阅的是Topic的Partition，而不是Message。所以在同一时间点上，订阅到同一个分区的Consumer必然属于不同的Consumer Group</p></blockquote><p>Consumer Group与Consumer的关系是动态维护的，当一个Consumer进程挂掉或者是卡住时，该Consumer所订阅的Partition会被重新分配到改组内的其他Consumer上，当一个Consumer加入到一个Consumer Group中时，同样会从其他的Consumer中分配出一个或者多个Partition到这个新加入的Consumer。</p><p><strong>负载均衡</strong></p><p>当启动一个Consumer时，会指定它要加入的Group，使用的配置项是：<a href="http://group.id/">Group.idopen in new window</a></p><p>为了维持Consumer与Consumer Group之间的关系，Consumer 会周期性地发送 hearbeat 到 coodinator（协调者），如果有 hearbeat 超时或未收到 hearbeat，coordinator 会认为该Consumer已经退出，那么它所订阅的Partition会分配到同一组内的其他Consumer上，这个过程称为 rebalance（再平衡）</p><h2 id="16、Kafka-中消息偏移的作用">16、Kafka 中消息偏移的作用</h2><p>生产过程中给分区中的消息提供一个顺序ID号，称之为偏移量，偏移量在每个分区中唯一。Kafka的存储文件都是按照offset.kafka来命名</p><h2 id="17、-生产过程中何时会发生QueueFullExpection以及如何处理">17、 生产过程中何时会发生QueueFullExpection以及如何处理</h2><p><strong>何时发生</strong></p><p>当生产者试图发送消息的速度快于Broker可以处理的速度时，通常会发生 <strong>QueueFullException</strong></p><p><strong>如何解决</strong></p><p>首先先进行判断生产者是否能够降低生产速率，如果生产者不能阻止这种情况，为了处理增加的负载，用户需要添加足够的 Broker。或者选择生产阻塞，设置<code>Queue.enQueueTimeout.ms</code> 为 -1，通过这样处理，如果队列已满的情况，生产者将阻止而不是删除消息。或者容忍这种异常，进行消息丢弃。</p><h2 id="18、Consumer-如何消费指定分区消息">18、Consumer 如何消费指定分区消息</h2><p>Cosumer 消费消息时，想Broker 发出 <code>fetch</code> 请求去消费特定分区的消息，Consumer 可以通过指定消息在日志中的偏移量 offset，就可以从这个位置开始消息消息，Consumer 拥有了 offset 的控制权，也可以向后回滚去重新消费之前的消息。</p><p>也可以使用 <code>seek(Long topicPartition)</code> 来指定消费的位置。</p><h2 id="19、Replica、Leader-和-Follower-三者的概念">19、Replica、Leader 和 Follower 三者的概念</h2><p>把<strong>相同的数据</strong>拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为<strong>副本（Replica）</strong>。Kafka 定义了两类副本：<strong>领导者副本（Leader Replica）<strong>和</strong>追随者副本（Follower Replica）</strong>。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，<strong>不能与外界进行交互。</strong></p><h2 id="20、Replica-的重要性">20、Replica 的重要性</h2><p>Replica 可以确保发布的消息不会丢失，保证了Kafka的高可用性。并且可以在发生任何机器错误、程序错误或软件升级、扩容时都能生产使用。</p><h2 id="21、Kafka-中的-Geo-Replication-是什么">21、Kafka 中的 Geo-Replication 是什么</h2><p>Kafka官方提供了MirrorMaker组件，作为跨集群的流数据同步方案。借助MirrorMaker，消息可以跨多个数据中心或云区域进行复制。您可以在主动/被动场景中将其用于备份和恢复，或者在主动/主动方案中将数据放置得更靠近用户，或支持数据本地化要求。</p><p>它的实现原理比较简单，就是通过从源集群消费消息，然后将消息生产到目标集群，即普通的消息生产和消费。用户只要通过简单的Consumer配置和Producer配置，然后启动Mirror，就可以实现集群之间的准实时的数据同步。</p><div class="note info flat"><p>感觉开发面试不怎么会问到这种</p></div><h2 id="22、Kafka-中-AR、ISR、OSR-三者的概念">22、Kafka 中 AR、ISR、OSR 三者的概念</h2><ul><li><code>AR</code>：分区中所有副本称为 AR</li><li><code>ISR</code>：所有与主副本保持一定程度同步的副本（包括主副本）称为 ISR</li><li><code>OSR</code>：与主副本滞后过多的副本组成 OSR</li></ul><h2 id="23、分区副本什么情况下会从-ISR-中剔出">23、分区副本什么情况下会从 ISR 中剔出</h2><p>Leader 会维护一个与自己基本保持同步的Replica列表，该列表称为ISR，每个Partition都会有一个ISR，而且是由Leader动态维护。所谓动态维护，就是说如果一个Follower比一个Leader落后太多，或者超过一定时间未发起数据复制请求，则Leader将其从ISR中移除。当ISR中所有Replica都向Leader发送ACK（Acknowledgement确认）时，Leader才commit。</p><h2 id="24、分区副本中的-Leader-如果宕机但-ISR-却为空该如何处理">24、分区副本中的 Leader 如果宕机但 ISR 却为空该如何处理</h2><p>可以通过配置<code>unclean.leader.election</code> ：</p><ul><li><strong>true</strong>：允许 OSR 成为 Leader，但是 OSR 的消息较为滞后，可能会出现消息不一致的问题</li><li><strong>false</strong>：会一直等待旧 leader 恢复正常，降低了可用性</li></ul><h2 id="25、如何判断一个-Broker-是否还有效">25、如何判断一个 Broker 是否还有效</h2><ol><li>Broker必须可以维护和ZooKeeper的连接，Zookeeper通过心跳机制检查每个结点的连接。</li><li>如果Broker是个Follower，它必须能及时同步Leader的写操作，延时不能太久。</li></ol><h2 id="26、Kafka-可接收的消息最大默认多少字节，如何修改">26、Kafka 可接收的消息最大默认多少字节，如何修改</h2><p>Kafka可以接收的最大消息默认为<strong>1000000</strong>字节，如果想调整它的大小，可在Broker中修改配置参数：<code>Message.max.bytes</code>的值</p><blockquote><p>但要注意的是，修改这个值，还要同时注意其他对应的参数值是正确的，否则就可能引发一些系统异常。首先这个值要比消费端的<code>fetch.Message.max.bytes</code>（默认值1MB，表示消费者能读取的最大消息的字节数）参数值要小才是正确的设置，否则Broker就会因为消费端无法使用这个消息而挂起。</p></blockquote><h2 id="27、Kafka-的-ACK-机制">27、Kafka 的 ACK 机制</h2><blockquote><p>Kafka的Producer有三种ack机制，参数值有0、1 和 -1。</p></blockquote><ul><li><strong>0：</strong> 相当于异步操作，Producer 不需要 Leader 给予回复，发送完就认为成功，继续发送下一条（批）Message。<strong>此机制具有最低延迟，但是持久性可靠性也最差，当服务器发生故障时，很可能发生数据丢失。</strong></li><li><strong>1：</strong> Kafka 默认的设置。表示 Producer 要 Leader 确认已成功接收数据才发送下一条（批）Message。不过 Leader 宕机，Follower 尚未复制的情况下，数据就会丢失。<strong>此机制提供了较好的持久性和较低的延迟性。</strong></li><li><strong>-1：</strong> Leader 接收到消息之后，还必须要求ISR列表里跟Leader保持同步的那些Follower都确认消息已同步，Producer 才发送下一条（批）Message。<strong>此机制持久性可靠性最好，但延时性最差。</strong></li></ul><h2 id="28、Kafka-的-consumer-如何消费数据">28、Kafka 的 consumer 如何消费数据</h2><p>在Kafka中，Producers将消息推送给Broker端，在Consumer和Broker建立连接之后，会主动去 Pull（或者说Fetch）消息。这种模式有些优点，首先Consumer端可以根据自己的消费能力适时的去fetch消息并处理，且可以控制消息消费的进度（offset）；此外，消费者可以控制每次消费的数，实现批量消费。</p><h2 id="29、Kafka-提供的API有哪些">29、Kafka 提供的API有哪些</h2><p>Kafka 提供了两套 Consumer API，分为 <strong>High-level API</strong> 和 <strong>Sample API</strong></p><p><strong>Sample API</strong></p><p>这是一个底层API，它维持了一个与单一 Broker 的连接，并且这个API 是完全无状态的，每次请求都需要指定 offset 值，因此这套 API 也是最灵活的。</p><p><strong>High-level API</strong></p><p>该API封装了对集群中一系列Broker的访问，可以透明地消费下一个Topic，它自己维护了已消费消息的状态，即每次消费的都会下一个消息。High-level API 还支持以组的形式消费Topic，如果 Consumers 有同一个组名，那么Kafka就相当于一个队列消息服务，而各个 Consumer 均衡地消费相应Partition中的数据。若Consumers有不同的组名，那么此时Kafka就相当于一个广播服务，会把Topic中的所有消息广播到每个Consumer</p><h2 id="30、Kafka-的Topic中-Partition-数据是怎么存储到磁盘的">30、Kafka 的Topic中 Partition 数据是怎么存储到磁盘的</h2><p>Topic 中的多个 Partition 以文件夹的形式保存到 Broker，每个分区序号从0递增，且消息有序。Partition 文件下有多个Segment（xxx.index，xxx.log），Segment文件里的大小和配置文件大小一致。默认为1GB，但可以根据实际需要修改。如果大小大于1GB时，会滚动一个新的Segment并且以上一个Segment最后一条消息的偏移量命名。</p><h2 id="31、Kafka-创建Topic后如何将分区放置到不同的-Broker-中">31、Kafka 创建Topic后如何将分区放置到不同的 Broker 中</h2><p>Kafka创建Topic将分区放置到不同的Broker时遵循以下规则：</p><ol><li>副本因子不能大于Broker的个数。</li><li>第一个分区（编号为0）的第一个副本放置位置是随机从Broker List中选择的。</li><li>其他分区的第一个副本放置位置相对于第0个分区依次往后移。也就是如果有3个Broker，3个分区，假设第一个分区放在第二个Broker上，那么第二个分区将会放在第三个Broker上；第三个分区将会放在第一个Broker上，更多Broker与更多分区依此类推。剩余的副本相对于第一个副本放置位置其实是由<code>nextReplicaShift</code>决定的，而这个数也是随机产生的。</li></ol><h2 id="32、Kafka-的日志保留期与数据清理策略">32、Kafka 的日志保留期与数据清理策略</h2><p><strong>概念</strong></p><p>保留期内保留了Kafka群集中的所有已发布消息，超过保期的数据将被按清理策略进行清理。默认保留时间是7天，如果想修改时间，在<code>server.properties</code>里更改参数<code>log.retention.hours/minutes/ms</code> 的值便可。</p><p><strong>清理策略</strong></p><ul><li><strong>删除：</strong> <code>log.cleanup.policy=delete</code> 表示启用删除策略，这也是默认策略。一开始只是标记为delete，文件无法被索引。只有过了<code>log.Segment.delete.delay.ms</code>这个参数设置的时间，才会真正被删除。</li><li><strong>压缩：</strong> <code>log.cleanup.policy=compact</code> 表示启用压缩策略，将数据压缩，只保留每个Key最后一个版本的数据。首先在Broker的配置中设置<code>log.cleaner.enable=true</code> 启用 cleaner，这个默认是关闭的。</li></ul><h2 id="33、Kafka-日志存储的Message是什么格式">33、Kafka 日志存储的Message是什么格式</h2><p>Kafka一个Message由<strong>固定长度的header</strong>和<strong>一个变长的消息体body</strong>组成。将Message存储在日志时采用不同于Producer发送的消息格式。每个日志文件都是一个log entries（日志项）序列：</p><ol><li>每一个log entry包含一个四字节整型数（Message长度，值为1+4+N）。</li><li>1个字节的magic，magic表示本次发布Kafka服务程序协议版本号。</li><li>4个字节的CRC32值，CRC32用于校验Message。</li><li>最终是N个字节的消息数据。每条消息都有一个当前Partition下唯一的64位offset。</li></ol><div class="note info flat"><p>Kafka没有限定单个消息的大小，但一般推荐消息大小不要超过1MB，通常一般消息大小都在1～10KB之间。</p></div><h2 id="35、Kafka-的日志分段策略与刷新策略">35、Kafka 的日志分段策略与刷新策略</h2><p><strong>日志分段（Segment）策略</strong></p><ol><li><code>log.roll.hours/ms</code>：日志滚动的周期时间，到达指定周期时间时，强制生成一个新的Segment，默认值168h（7day）。</li><li><code>log.Segment.bytes</code>：每个Segment的最大容量。到达指定容量时，将强制生成一个新的Segment。默认值1GB（-1代表不限制）。</li><li><code>log.retention.check.interval.ms</code>：日志片段文件检查的周期时间。默认值60000ms。</li></ol><p><strong>日志刷新策略</strong></p><p>Kafka的日志实际上是开始是在缓存中的，然后根据实际参数配置的策略定期一批一批写入到日志文件中，以提高吞吐量。</p><ol><li><code>log.flush.interval.Messages</code>：消息达到多少条时将数据写入到日志文件。默认值为10000。</li><li><code>log.flush.interval.ms</code>：当达到该时间时，强制执行一次flush。默认值为null。</li><li><code>log.flush.scheduler.interval.ms</code>：周期性检查，是否需要将信息flush。默认为很大的值。</li></ol><h2 id="36、Kafka-中如何进行主从同步">36、Kafka 中如何进行主从同步</h2><div class="note info flat"><p>Kafka动态维护了一个同步状态的副本的集合（a set of In-SyncReplicas），简称ISR，在这个集合中的结点都是和Leader保持高度一致的，任何一条消息只有被这个集合中的每个结点读取并追加到日志中，才会向外部通知“这个消息已经被提交”。</p></div><p>kafka 通过配置 <code>producer.type</code> 来确定是异步还是同步，默认是同步</p><p><strong>同步复制</strong></p><p>Producer 会先通过Zookeeper识别到Leader，然后向 Leader 发送消息，Leader 收到消息后写入到本地 log文件。这个时候Follower 再向 Leader Pull 消息，Pull 回来的消息会写入的本地 log 中，写入完成后会向 Leader 发送 Ack 回执，等到 Leader 收到所有 Follower 的回执之后，才会向 Producer 回传 Ack。</p><p><strong>异步复制</strong></p><p>Kafka 中 Producer 异步发送消息是基于同步发送消息的接口来实现的，异步发送消息的实现很简单，客户端消息发送过来以后，会先放入一个 <code>BlackingQueue</code> 队列中然后就返回了。Producer 再开启一个线程 <code>ProducerSendTread</code> 不断从队列中取出消息，然后调用同步发送消息的接口将消息发送给 Broker。</p><div class="note info flat"><p>Producer的这种在内存缓存消息，当累计达到阀值时批量发送请求，小数据I/O太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。但是如果在达到阀值前，Producer不可用了，缓存的数据将会丢失。</p></div><h2 id="37、-消息丢失-不一致的问题">37、 消息丢失/不一致的问题</h2><div class="note danger flat"><p>这个地方很喜欢考。这是后端开发回答的版本。详细可以参考 <a href="/posts/717cdc22.html#14-%E6%97%A0%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E9%85%8D%E7%BD%AE">kafka核心技术与实战</a></p></div><h3 id="消息发送时">消息发送时</h3><ul><li><p>producer使用的send方法没有使用带callback参数的方法，或者没有获取发送是否成功的结果（这里会有线程阻塞），导致有异常没发送出去也不知道</p></li><li><p>ack配置成0，kafka只管发送，不理会 <strong>Leader Replica</strong> 是否成功接收到，而发送的时候刚好出现问题。</p></li><li><p>还有一种情况，因为是<strong>异步刷盘</strong>（segment达到一定阈值才会flush到磁盘，参考3），broker还没有把消息刷到磁盘中时，broker宕机了。</p></li></ul><h3 id="消息消费时">消息消费时</h3><ul><li><strong>消费消息前</strong>就已经提交了消息位移，而消息没有成功消费</li><li><strong>多线程结构</strong>消费消息时，瓜分消息的线程中有执行失败的批次任务，没有处理，正常提交了消息位移</li><li>消息“被窃取”。有其他的人配置错topic + group.id了。这是运维不当。</li></ul><h2 id="38、Kafka-作为流处理平台的特点">38、Kafka 作为流处理平台的特点</h2><blockquote><p>流处理就是连续、实时、并发和以逐条记录的方式处理数据的意思。Kafka 是一个分布式流处理平台，它的高吞吐量、低延时、高可靠性、容错性、高可扩展性都使得Kafka非常适合作为流式平台。</p></blockquote><ol><li>它是一个简单的、轻量级的Java类库，能够被集成到任何Java应用中</li><li>除了Kafka之外没有任何其他的依赖，利用Kafka的分区模型支持水平扩容和保证顺序性</li><li>支持本地状态容错，可以执行非常快速有效的有状态操作</li><li>支持 <code>exactly-once</code> 语义</li><li>支持一次处理一条记录，实现 ms 级的延迟</li></ol><h2 id="39、消费者故障，出现活锁问题如何解决">39、消费者故障，出现活锁问题如何解决</h2><p><strong>活锁的概念</strong>：消费者持续的维持心跳，但没有进行消息处理。</p><p>为了预防消费者在这种情况一直持有分区，通常会利用 <code>max.poll.interval.ms</code>活跃检测机制，如果调用 Poll 的频率大于最大间隔，那么消费者将会主动离开消费组，以便其他消费者接管该分区</p><h2 id="40、Kafka-中如何保证顺序消费">40、Kafka 中如何保证顺序消费</h2><p>Kafka 的消费单元是 Partition，同一个 Partition 使用 offset 作为唯一标识保证顺序性，但这只是保证了在 Partition 内部的顺序性而不是 Topic 中的顺序，因此我们需要将所有消息发往统一 Partition 才能保证消息顺序消费，那么可以在发送的时候指定 MessageKey，同一个 key 的消息会发到同一个 Partition 中。</p><div class="note info flat"><p>key-ordering的分区策略需要自己实现。可以参考 <a href="/posts/717cdc22.html#Key-ordering-%E7%AD%96%E7%95%A5">kafka核心技术与实战</a></p></div>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统(修正版)</title>
      <link href="/posts/11696cf2.html"/>
      <url>/posts/11696cf2.html</url>
      
        <content type="html"><![CDATA[<h2 id="引论">引论</h2><h3 id="什么是操作系统？">什么是操作系统？</h3><p>可以这么说，操作系统是一种运行在内核态的软件。</p><p>它是应用程序和硬件之间的媒介，向应用程序提供硬件的抽象，以及管理硬件资源。</p><p><img src="https://s2.loli.net/2023/04/01/y3ghzNrx9jUtsLF.png" alt="操作系统是什么"></p><h3 id="操作系统主要有哪些功能？">操作系统主要有哪些功能？</h3><p>操作系统最主要的功能：</p><ul><li>处理器（CPU）管理：CPU的管理和分配，主要指的是进程管理。</li><li>内存管理：内存的分配和管理，主要利用了虚拟内存的方式。</li><li>外存管理：外存（磁盘等）的分配和管理，将外存以文件的形式提供出去。</li><li>I/O管理：对输入/输出设备的统一管理。</li></ul><p>除此之外，还有保证自身正常运行的健壮性管理，防止非法操作和入侵的安全性管理。</p><p><img src="https://s2.loli.net/2023/04/01/WrYANG7bpTEU6sS.png" alt="操作系统主要功能"></p><h2 id="操作系统结构">操作系统结构</h2><h3 id="什么是内核？">什么是内核？</h3><p>可以这么说，内核是一个计算机程序，它是操作系统的核心，提供了操作系统最核心的能力，可以控制操作系统中所有的内容。</p><h3 id="什么是用户态和内核态？">什么是用户态和内核态？</h3><p>内核具有很⾼的权限，可以控制 cpu、内存、硬盘等硬件，出于权限控制的考虑，因此⼤多数操作系统，把内存分成了两个区域：</p><ul><li>内核空间，这个内存空间只有内核程序可以访问；</li><li>⽤户空间，这个内存空间专⻔给应⽤程序使⽤，权限比较小；</li></ul><p>⽤户空间的代码只能访问⼀个局部的内存空间，⽽内核空间的代码可以访问所有内存空间。因此，当程序使⽤⽤户空间时，我们常说该程序在<strong>⽤户态</strong>执⾏，⽽当程序使内核空间时，程序则在<strong>内核态</strong>执⾏。</p><h3 id="用户态和内核态是如何切换的？">用户态和内核态是如何切换的？</h3><p>应⽤程序如果需要进⼊内核空间，就需要通过系统调⽤，来进入内核态：</p><p><img src="https://s2.loli.net/2023/04/01/pOVGdhPFnJ2LyKR.png" alt="用户态&amp;内核态切换"></p><p>内核程序执⾏在内核态，⽤户程序执⾏在⽤户态。当应⽤程序使⽤系统调⽤时，会产⽣⼀个中断。发⽣中断后， CPU 会中断当前在执⾏的⽤户程序，转⽽跳转到中断处理程序，也就是开始执⾏内核程序。内核处理完后，主动触发中断，把 CPU 执⾏权限交回给⽤户程序，回到⽤户态继续⼯作。</p><h2 id="进程和线程">进程和线程</h2><h3 id="并行和并发有什么区别？">并行和并发有什么区别？</h3><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器做到的并发，其实是利用时间片的轮转，例如有两个进程A和B，A运行一个时间片之后，切换到B，B运行一个时间片之后又切换到A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p><p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p><p><img src="https://s2.loli.net/2023/04/01/SyPVlF4AJsmruMh.png" alt="并发和并行"></p><h3 id="什么是进程上下文切换？">什么是进程上下文切换？</h3><p>对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</p><p><img src="https://s2.loli.net/2023/04/01/UuJWSmIFhjs5nlB.png" alt="进程上下文切换-来源参考[3]"></p><h3 id="进程有哪些状态？">进程有哪些状态？</h3><p>当一个进程开始运行时，它可能会经历下面这几种状态：</p><p>上图中各个状态的意义：</p><ul><li>运⾏状态（<em>Runing</em>）：该时刻进程占⽤ CPU；</li><li>就绪状态（<em>Ready</em>）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；</li><li>阻塞状态（<em>Blocked</em>）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运⾏，这时，即使给它CPU控制权，它也⽆法运⾏；</li></ul><p><img src="https://s2.loli.net/2023/04/01/A8tJfGQVFbw2nY3.png" alt="进程3种状态"></p><p>当然，进程还有另外两个基本状态：</p><ul><li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li><li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；</li></ul><p><img src="https://s2.loli.net/2023/04/01/inugjWXxlEMyKqN.png" alt="进程5种状态"></p><h3 id="什么是僵尸进程？">什么是僵尸进程？</h3><p>僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。</p><p>僵尸进程一般发生有父子关系的进程中，一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中。</p><h3 id="什么是孤儿进程？">什么是孤儿进程？</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程 (进程 ID 为 1 的进程) 所收养，并由 init 进程对它们完成状态收集工作。因为孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h3 id="进程有哪些调度算法？">进程有哪些调度算法？</h3><p>进程调度就是确定某一个时刻CPU运行哪个进程，常见的进程调度算法有：</p><p><img src="https://s2.loli.net/2023/04/01/1sdukvYBxaZbF8K.png" alt="进程调度算法"></p><ul><li><strong>先来先服务</strong></li></ul><p>非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/O密集型进程也不利，因为这种进程每次进行I/O操作之后又得重新排队。</p><p><img src="https://s2.loli.net/2023/04/01/CXE7fzDT2Yw3jF5.png" alt="先来先服务"></p><ul><li><strong>短作业优先</strong></li></ul><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><img src="https://s2.loli.net/2023/04/01/j7S3VUet2HmnPWL.png" alt="短作业优先"></p><ul><li><strong>优先级调度</strong></li></ul><p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><img src="https://s2.loli.net/2023/04/01/gIDSX6sEmHYvqA3.png" alt="优先级调度"></p><ul><li><strong>时间片轮转</strong></li></ul><p>将所有就绪进程按 先来先服务的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p><p><img src="https://s2.loli.net/2023/04/01/4Cfausiz7KNnIV8.png" alt="时间片轮转"></p><ul><li><strong>最短剩余时间优先</strong></li></ul><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="进程间通信有哪些方式？">进程间通信有哪些方式？</h3><p><img src="https://s2.loli.net/2023/04/01/5Na4uMGUywID7oL.png" alt="进程间通信方式"></p><ul><li><p>管道：管道可以理解成不同进程之间的对白，一方发声，一方接收，声音的介质可是是空气或者电缆，进程之间就可以通过管道，<strong>所谓的管道就是内核中的一串缓存</strong>，从管道的一端写入数据，就是缓存在了内核里，另一端读取，也是从内核中读取这段数据。</p><p>管道可以分为两类：<strong>匿名管道</strong>和<strong>命名管道</strong>。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道是双向的，可以实现本机任意两个进程通信。</p><p><img src="https://s2.loli.net/2023/04/01/VYncE9sG5x31wTr.png" alt="“奉先我儿”"></p></li><li><p>信号 ： 信号可以理解成一种电报，发送方发送内容，指定接收进程，然后发出特定的软件中断，操作系统接到中断请求后，找到接收进程，通知接收进程处理信号。</p><p>比如<code>kill -9 1050</code>就表示给PID为1050的进程发送<code>SIGKIL</code>信号。Linux系统中常用信号：</p><p>（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br>（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。<br>（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\键将产生该信号。<br>（4）SIGBUS和SIGSEGV：进程访问非法地址。<br>（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。<br>（6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。<br>（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。<br>（8）SIGALRM：定时器信号。<br>（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></li><li><p>消息队列：<strong>消息队列就是保存在内核中的消息链表</strong>，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li></ul><p><img src="https://s2.loli.net/2023/04/01/bUYsHyXOzaWnpVM.png" alt="消息队列"></p><ul><li>共享内存：<strong>共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写⼊的东西，另外的进程⻢上就能看到。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li></ul><p><img src="https://s2.loli.net/2023/04/01/XY7e6taVWLmqw5J.png" alt="共享内存"></p><ul><li><p>信号量：信号量我们可以理解成红绿灯，红灯行，绿灯停。<strong>它本质上是一个整数计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：</p><ul><li>⼀个是 <strong>P</strong> <strong>操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使⽤，进程可正常继续执⾏。</li><li>另⼀个是 <strong>V</strong> <strong>操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ul><p>P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。</p><p><img src="https://s2.loli.net/2023/04/01/6hXBwy4ucDOW3ov.png" alt="信号量"></p></li><li><p>Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。</p></li></ul><p>优缺点：</p><ul><li>管道：简单；效率低，容量有限；</li><li>消息队列：不及时，写入和读取需要用户态、内核态拷贝。</li><li>共享内存区：能够很容易控制容量，速度快，但需要注意不同进程的同步问题。</li><li>信号量：不能传递复杂消息，一般用来实现进程间的同步；</li><li>信号：它是进程间通信的唯一异步机制。</li><li>Socket：用于不同主机进程间的通信。</li></ul><h3 id="进程和线程的联系和区别？">进程和线程的联系和区别？</h3><p>线程和进程的联系：</p><p><strong>线程是进程当中的⼀条执⾏流程。</strong></p><p>同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，但每个线程各⾃都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的。</p><p><img src="https://s2.loli.net/2023/04/01/Ertm7ARelTMx5hg.png" alt="多线程-来源参考[3]"></p><p>线程与进程的⽐较如下：</p><ul><li>调度：<strong>进程是资源（包括内存、打开的⽂件等）分配的单位</strong>，<strong>线程是 CPU 调度的单位</strong>；</li><li>资源：进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；</li><li>拥有资源：线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；</li><li>系统开销：线程能减少并发执⾏的时间和空间开销——创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ul><h3 id="线程上下文切换了解吗？">线程上下文切换了解吗？</h3><p>这还得看线程是不是属于同⼀个进程：</p><ul><li><p>当两个线程不是属于同⼀个进程，则切换的过程就跟进程上下⽂切换⼀样；</p></li><li><p><strong>当两个线程是属于同⼀个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</p></li></ul><p>所以，线程的上下⽂切换相⽐进程，开销要⼩很多。</p><h3 id="线程有哪些实现方式？">线程有哪些实现方式？</h3><p>主要有三种线程的实现⽅式：</p><ul><li><strong>内核态线程实现</strong>：在内核空间实现的线程，由内核直接管理直接管理线程。</li></ul><p><img src="https://s2.loli.net/2023/04/01/SNf5IdtVmBphCEj.png" alt="内核态线程实现"></p><ul><li><strong>⽤户态线程实现</strong>：在⽤户空间实现线程，不需要内核的参与，内核对线程无感知。</li></ul><p><img src="https://s2.loli.net/2023/04/01/p3sx2gdPJMWXehV.png" alt="用户态线程"></p><ul><li><strong>混合线程实现</strong>：现代操作系统基本都是将两种方式结合起来使用。用户态的执行系统负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。即我们同时实现内核态和用户态线程管理。其中内核态线程数量较少，而用户态线程数量较多。每个内核态线程可以服务一个或多个用户态线程。</li></ul><p><img src="https://s2.loli.net/2023/04/01/JaL2yMBAkNFC5xI.png" alt="混合线程实现"></p><h3 id="线程间如何同步？">线程间如何同步？</h3><p>同步解决的多线程操作共享资源的问题，目的是不管线程之间的执行如何穿插，最后的结果都是正确的。</p><p>我们前面知道线程和进程的关系：线程是进程当中的⼀条执⾏流程。所以说下面的一些同步机制不止针对线程，同样也可以针对进程。</p><p><strong>临界区</strong>：我们把对共享资源访问的程序片段称为<code>临界区</code>，我们希望这段代码是<code>互斥</code>的，保证在某时刻只能被一个线程执行，也就是说一个线程在临界区执行时，其它线程应该被阻止进入临界区。</p><p><img src="https://s2.loli.net/2023/04/01/YFaxJSipqL2zw3A.png" alt="临界区互斥-来源参考[3]"></p><p>临界区不仅针对线程，同样针对进程。</p><p>临界区同步的一些实现方式：</p><p>1、<strong>锁</strong></p><p>使⽤加锁操作和解锁操作可以解决并发线程/进程的互斥问题。</p><p>任何想进⼊临界区的线程，必须先执⾏加锁操作。若加锁操作顺利通过，则线程可进⼊临界区；在完成对临界资源的访问后再执⾏解锁操作，以释放该临界资源。</p><p>加锁和解锁锁住的是什么呢？可以是<code>临界区对象</code>，也可以只是一个简单的<code>互斥量</code>，例如互斥量是<code>0</code>无锁，<code>1</code>表示加锁。</p><p><img src="https://s2.loli.net/2023/04/01/xsobBuHUMAqDndt.png" alt="加锁和解锁-来源参考[3]"></p><p>根据锁的实现不同，可以分为<code>忙等待锁和</code>和<code>⽆忙等待锁</code>。</p><p><code>忙等待锁和</code>就是加锁失败的线程，会不断尝试获取锁，也被称为自旋锁，它会一直占用CPU。</p><p><code>⽆忙等待锁</code>就是加锁失败的线程，会进入阻塞状态，放弃CPU，等待被调度。</p><p>2、<strong>信号量</strong></p><p>信号量是操作系统提供的⼀种协调共享资源访问的⽅法。</p><p>通常<strong>信号量表示资源的数量</strong>，对应的变量是⼀个整型（ sem ）变量。</p><p>另外，还有<strong>两个原⼦操作的系统调⽤函数来控制信号量的</strong>，分别是：</p><ul><li><p><em>P</em> 操作：将 sem 减 1 ，相减后，如果 sem &lt; 0 ，则进程/线程进⼊阻塞等待，否则继续，表明 P操作可能会阻塞；</p></li><li><p><em>V</em> 操作：将 sem 加 1 ，相加后，如果 sem &lt;= 0 ，唤醒⼀个等待中的进程/线程，表明 V 操作不会阻塞；</p></li></ul><p>P 操作是⽤在进⼊临界区之前，V 操作是⽤在离开临界区之后，这两个操作是必须成对出现的。</p><h3 id="什么是死锁？">什么是死锁？</h3><p>在两个或者多个并发线程中，如果每个线程持有某种资源，而又等待其它线程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组线程产生了死锁。通俗的讲就是两个或多个线程无限期的阻塞、相互等待的一种状态。</p><p><img src="https://s2.loli.net/2023/04/01/TvlgM9pHS6LfZE5.png" alt="死锁"></p><h3 id="死锁产生有哪些条件？">死锁产生有哪些条件？</h3><p>死锁产生需要<strong>同时</strong>满足四个条件：</p><ul><li><strong>互斥条件</strong>：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li><strong>请求并持有条件</strong>：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。</li><li><strong>不可剥夺条件</strong>：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。</li></ul><h3 id="如何避免死锁呢？">如何避免死锁呢？</h3><p>产⽣死锁的有四个必要条件：互斥条件、持有并等待条件、不可剥夺条件、环路等待条件。</p><p>避免死锁，破坏其中的一个就可以。</p><p><strong>消除互斥条件</strong></p><p>这个是没法实现，因为很多资源就是只能被一个线程占用，例如锁。</p><p><strong>消除请求并持有条件</strong></p><p>消除这个条件的办法很简单，就是一个线程一次请求其所需要的所有资源。</p><p><strong>消除不可剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可剥夺这个条件就破坏掉了。</p><p><strong>消除环路等待条件</strong></p><p>可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。</p><h3 id="活锁和饥饿锁了解吗？">活锁和饥饿锁了解吗？</h3><p><strong>饥饿锁：</strong></p><p>饥饿锁，这个饥饿指的是资源饥饿，某个线程一直等不到它所需要的资源，从而无法向前推进，就像一个人因为饥饿无法成长。</p><p><strong>活锁：</strong></p><p>在活锁状态下，处于活锁线程组里的线程状态可以改变，但是整个活锁组的线程无法推进。</p><p>活锁可以用两个人过一条很窄的小桥来比喻：为了让对方先过，两个人都往旁边让，但两个人总是让到同一边。这样，虽然两个人的状态一直在变化，但却都无法往前推进。</p><h2 id="内存管理">内存管理</h2><h3 id="什么是虚拟内存？">什么是虚拟内存？</h3><p>我们实际的物理内存主要是主存，但是物理主存空间有限，所以一般现代操作系统都会想办法把一部分内存块放到磁盘中，用到的时候再装入主存，但是对用户程序而言，是不需要注意实际的物理内存的，为什么呢？因为有<code>虚拟内存</code>的机制。</p><p><strong>简单说，虚拟内存是操作系统提供的⼀种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>每个进程都有自己独立的地址空间，再由操作系统映射到到实际的物理内存。</p><p>于是，这⾥就引出了两种地址的概念：</p><p>程序所使⽤的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</p><p>实际存在硬件⾥⾯的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</p><p><img src="https://s2.loli.net/2023/04/01/34ZCxnv59PAq1OR.png" alt="虚拟内存"></p><h3 id="什么是内存分段？">什么是内存分段？</h3><p>程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。</p><p>分段机制下的虚拟地址由两部分组成，<strong>段号</strong>和<strong>段内偏移量</strong>。</p><p>虚拟地址和物理地址通过段表映射，段表主要包括<strong>段号</strong>、<code>段的界限</code>。</p><p><img src="https://s2.loli.net/2023/04/01/CtFIXYGzZTeUVcm.png" alt="虚拟地址、段表、物理地址"></p><p>我们来看一个映射，虚拟地址：段3、段偏移量500  ----&gt;  段基地址7000+段偏移量500 ----&gt; 物理地址：7500。</p><p><img src="https://s2.loli.net/2023/04/01/1ve7jJ5BquLpPW2.png" alt="段虚拟地址映射"></p><h3 id="什么是内存分页？">什么是内存分页？</h3><p><strong>分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩</strong>。这样⼀个连续并且尺⼨固定的内存空间，我们叫<strong>⻚</strong>（<em>Page</em>）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。</p><p>访问分页系统中内存数据需要两次的内存访问 ：一次是从内存中访问页表，从中找到指定的物理页号，加上页内偏移得到实际物理地址，第二次就是根据第一次得到的物理地址访问内存取出数据。</p><p><img src="https://s2.loli.net/2023/04/01/aAf8WJsXC7gEDcr.png" alt="内存分页"></p><h3 id="多级页表知道吗？">多级页表知道吗？</h3><p>操作系统可能会有非常多进程，如果只是使用简单分页，可能导致的后果就是页表变得非常庞大。</p><p>所以，引入了多级页表的解决方案。</p><p>所谓的多级页表，就是把我们原来的单级页表再次分页，这里利用了<code>局部性原理</code>，除了顶级页表，其它级别的页表一来可以在需要的时候才被创建，二来内存紧张的时候还可以被置换到磁盘中。</p><p><img src="https://s2.loli.net/2023/04/01/xgN9jlu4aOXsqA7.png" alt="多级页表示意图"></p><h3 id="什么是块表？">什么是块表？</h3><p>同样利用了<code>局部性原理</code>，即在⼀段时间内，整个程序的执⾏仅限于程序中的某⼀部分。相应地，执⾏所访问的存储空间也局限于某个内存区域。</p><p>利⽤这⼀特性，把最常访问的⼏个⻚表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯⽚中，加⼊了⼀个专⻔存放程序最常访问的⻚表项的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为⻚表缓存、转址旁路缓存、快表等。</p><p><img src="https://s2.loli.net/2023/04/01/y1zHmZldPGxLCkV.png" alt="TLB示意图-来源参考[3]"></p><h3 id="分页和分段有什么区别？">分页和分段有什么区别？</h3><ul><li>段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。</li><li>段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定</li><li>段向用户提供二维地址空间；页向用户提供的是一维地址空间</li><li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li></ul><h3 id="什么是交换空间？">什么是交换空间？</h3><p>操作系统把物理内存(Physical RAM)分成一块一块的小内存，每一块内存被称为页(page)。当内存资源不足时，Linux把某些页的内容转移至磁盘上的一块空间上，以释放内存空间。磁盘上的那块空间叫做交换空间(swap space),而这一过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可用容量。</p><p>用途：</p><ul><li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li><li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li></ul><h3 id="页面置换算法有哪些？">页面置换算法有哪些？</h3><p>在分页系统里，一个虚拟的页面可能在主存里，也可能在磁盘中，如果CPU发现虚拟地址对应的物理页不在主存里，就会产生一个缺页中断，然后从磁盘中把该页调入主存中。</p><p>如果内存里没有空间，就需要从主存里选择一个页面来置换。</p><p>常见的页面置换算法：</p><p><img src="https://s2.loli.net/2023/04/01/mra2VinKOzgTDob.png" alt="常见页面置换算法"></p><ul><li><strong>最佳⻚⾯置换算法（<em>OPT</em>）</strong></li></ul><p>最佳⻚⾯置换算法是一个理想的算法，基本思路是，<strong>置换在未来最⻓时间不访问的⻚⾯</strong>。</p><p>所以，该算法实现需要计算内存中每个逻辑⻚⾯的下⼀次访问时间，然后⽐较，选择未来最⻓时间不访问的⻚⾯。</p><p>但这个算法是无法实现的，因为当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问。</p><ul><li><strong>先进先出置换算法（FIFO）</strong></li></ul><p>既然我们⽆法预知⻚⾯在下⼀次访问前所需的等待时间，那可以<strong>选择在内存驻留时间很⻓的⻚⾯进⾏中置换</strong>，这个就是「先进先出置换」算法的思想。</p><p>FIFO的实现机制是使用链表将所有在内存的页面按照进入时间的早晚链接起来，然后每次置换链表头上的页面就行了，新加进来的页面则挂在链表的末端。</p><p><img src="https://s2.loli.net/2023/04/01/imHCWtakInSX3U5.png" alt="按照进入内存早晚构建的页面链表 "></p><ul><li><strong>最近最久未使⽤的置换算法（LRU）</strong></li></ul><p>最近最久未使⽤（<em>LRU</em>）的置换算法的基本思路是，发⽣缺⻚时，<strong>选择最⻓时间没有被访问的⻚⾯进⾏置换</strong>，也就是说，该算法假设已经很久没有使⽤的⻚⾯很有可能在未来较⻓的⼀段时间内仍然不会被使⽤。</p><p>这种算法近似最优置换算法，最优置换算法是通过「未来」的使⽤情况来推测要淘汰的⻚⾯，⽽ LRU 则是通过<code>历史</code>的使⽤情况来推测要淘汰的⻚⾯。</p><p>LRU 在理论上是可以实现的，但代价很⾼。为了完全实现 LRU，需要在内存中维护⼀个所有⻚⾯的链表，最近最多使⽤的⻚⾯在表头，最近最少使⽤的⻚⾯在表尾。</p><p><img src="https://s2.loli.net/2023/04/01/OUpAFGWtvR6hc7E.png" alt="LRU实现"></p><p>困难的是，在每次访问内存时都必须要更新整个链表。在链表中找到⼀个⻚⾯，删除它，然后把它移动到表头是⼀个⾮常费时的操作。</p><p>所以，LRU 虽然看上去不错，但是由于开销⽐较⼤，实际应⽤中⽐较少使⽤。</p><ul><li><strong>时钟页面置换算法</strong></li></ul><p>这个算法的思路是，把所有的⻚⾯都保存在⼀个类似钟⾯的环形链表中，⼀个表针指向最⽼的⻚⾯。</p><p><img src="https://s2.loli.net/2023/04/01/46g7pD5sJk1Nljb.png" alt="时钟页面置换算法"></p><p>当发⽣缺⻚中断时，算法⾸先检查表针指向的⻚⾯：</p><p>如果它的访问位位是 0 就淘汰该⻚⾯，并把新的⻚⾯插⼊这个位置，然后把表针前移⼀个位置；</p><p>如果访问位是 1 就清除访问位，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的⻚⾯为⽌；</p><ul><li><strong>最不常⽤置换算法</strong></li></ul><p>最不常用算法（LFU），<strong>当发⽣缺⻚中断时，选择访问次数最少的那个⻚⾯，将其置换</strong>。</p><p>它的实现⽅式是，对每个⻚⾯设置⼀个「访问计数器」，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就累加 1。在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯。</p><h2 id="文件">文件</h2><h3 id="硬链接和软链接有什么区别？">硬链接和软链接有什么区别？</h3><ul><li>硬链接就是在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。</li></ul><p><img src="https://s2.loli.net/2023/04/01/4jqpDfAa2H3yX8z.png" alt="硬链接-来源参考[3]"></p><ul><li><p>软链接相当于重新创建⼀个⽂件，这个⽂件有<strong>独⽴的</strong> <strong>inode</strong>，但是这个<strong>⽂件的内容是另外⼀个⽂件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外⼀个⽂件，所以<strong>软链接是可以跨⽂件系统的</strong>，甚⾄<strong>⽬标⽂件被删除了，链接⽂件还是在的，只不过打不开指向的文件了而已。</strong></p><p><img src="https://s2.loli.net/2023/04/01/ULZ9ho7OiAzaG1d.png" alt="软链接-来源参考[3]"></p></li></ul><h2 id="IO">IO</h2><h3 id="零拷贝了解吗？">零拷贝了解吗？</h3><p>假如需要文件传输，使用传统I/O，数据读取和写入是用户空间到内核空间来回赋值，而内核空间的数据是通过操作系统的I/O接口从磁盘读取或者写入，这期间发生了多次用户态和内核态的上下文切换，以及多次数据拷贝。</p><p><img src="https://s2.loli.net/2023/04/01/lAiLGwDYKFWdO71.png" alt="传统文件传输示意图-来源参考[3]"></p><p>为了提升I/O性能，就需要<strong>减少用户态与内核态的上下文切换</strong>和<strong>内存拷贝的次数</strong>。</p><p>这就用到了我们零拷贝的技术，零拷贝技术实现主要有两种：</p><ul><li><strong>mmap + write</strong></li></ul><p>mmap() 系统调⽤函数会直接把内核缓冲区⾥的数据「<strong>映射</strong>」到⽤户空间，这样，操作系统内核与⽤户空间就不需要再进⾏任何的数据拷⻉操作。</p><p><img src="https://s2.loli.net/2023/04/01/TC85WikhVO7u6zv.png" alt="mmap示意图-来源参考[3]"></p><ul><li><strong>sendfile</strong></li></ul><p>在 Linux 内核版本 2.1 中，提供了⼀个专⻔发送⽂件的系统调⽤函数 sendfile() 。</p><p>⾸先，它可以替代前⾯的 read() 和 write() 这两个系统调⽤，这样就可以减少⼀次系统调⽤，也就减少了 2 次上下⽂切换的开销。</p><p>其次，该系统调⽤，可以直接把内核缓冲区⾥的数据拷⻉到 socket 缓冲区⾥，不再拷⻉到⽤户态，这样就只有 2 次上下⽂切换，和 3 次数据拷⻉。</p><p><img src="https://s2.loli.net/2023/04/01/ALskpywO6rVq1FN.png" alt="sendfile示意图-来源参考[3]"></p><p>很多开源项目如Kafka、RocketMQ都采用了零拷贝技术来提升IO效率。</p><h3 id="聊聊阻塞与非阻塞I-O、同步与异步I-O？">聊聊阻塞与非阻塞I/O、同步与异步I/O？</h3><ul><li><strong>阻塞I/O</strong></li></ul><p>先来看看<strong>阻塞</strong> <strong>I/O</strong>，当⽤户程序执⾏ read ，线程会被阻塞，⼀直等到内核数据准备好，并把数据从内核缓冲区拷⻉到应⽤程序的缓冲区中，当拷⻉过程完成， read 才会返回。</p><p>注意，<strong>阻塞等待的是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程</strong>。</p><p><img src="https://s2.loli.net/2023/04/01/IDpZGljdSzo34xu.png" alt="阻塞I/O"></p><ul><li><strong>非阻塞I/O</strong></li></ul><p>⾮阻塞的 read 请求在数据未准备好的情况下⽴即返回，可以继续往下执⾏，此时应⽤程序不断轮询内核，直到数据准备好，内核将数据拷⻉到应⽤程序缓冲区， read 调⽤才可以获取到结果。</p><p><img src="https://s2.loli.net/2023/04/01/dTbYoX8Bf4gzwSs.png" alt="非阻塞I/O"></p><ul><li><strong>基于非阻塞的I/O多路复用</strong></li></ul><p>我们上面的非阻塞I/O有一个问题，什么问题呢？应用程序要一直轮询，这个过程没法干其它事情，所以引入了<strong>I/O</strong> <strong>多路复⽤</strong>技术。</p><p>当内核数据准备好时，以事件通知应⽤程序进⾏操作。</p><p><img src="https://s2.loli.net/2023/04/01/PBdqUAFJahYfHk1.png" alt="基于非阻塞的I/O多路复用"></p><p><strong>注意：<strong>⽆论是阻塞 I/O、还是⾮阻塞 I/O、非阻塞I/O多路复用，都是同步调⽤。因为它们在read调⽤时，内核将数据从内核空间拷⻉到应⽤程序空间，过程都是需要等待的，也就是说这个过程是</strong>同步</strong>的，如果内核实现的拷⻉效率不⾼，read调⽤就会在这个同步过程中等待⽐较⻓的时间。</p><ul><li><strong>异步I/O</strong></li></ul><p>真正的<strong>异步</strong> <strong>I/O</strong> 是<code>内核数据准备好</code>和<code>数据从内核态拷⻉到⽤户态</code>这两个过程都不⽤等待。</p><p>发起 aio_read 之后，就⽴即返回，内核⾃动将数据从内核空间拷⻉到应⽤程序空间，这个拷⻉过程同样是异步的，内核⾃动完成的，和前⾯的同步操作不⼀样，应⽤程序并不需要主动发起拷⻉动作。</p><p><img src="https://s2.loli.net/2023/04/01/LkGvxANWcOl3ZC7.png" alt="异步/IO"></p><blockquote><p>拿例子理解几种I/O模型</p></blockquote><p>老三关注了很多UP主，有些UP主是老鸽子，到了更新的时间：</p><p>阻塞I/O就是，老三不干别的，就干等着，盯着UP的更新。</p><p>非阻塞I/O就是，老三发现UP没更，就去喝个茶什么的，过一会儿来盯一次，一直等到UP更新。</p><p>基于⾮阻塞的 I/O 多路复⽤好⽐，老三发现UP没更，就去干别的，过了一会儿B站推送消息了，老三一看，有很多条，就去翻动态，看看等的UP是不是更新了。</p><p>异步I/O就是，老三说UP你该更了，UP赶紧爆肝把视频做出来，然后把视频亲自呈到老三面前，这个过程不用等待。</p><p><img src="https://s2.loli.net/2023/04/01/EhDd8jVSYqRGH3l.png" alt="鸽宗"></p><h3 id="详细讲一讲I-O多路复用？">详细讲一讲I/O多路复用？</h3><blockquote><p>我们先了解什么是I/O多路复用？</p></blockquote><p>我们在传统的I/O模型中，如果服务端需要支持多个客户端，我们可能要为每个客户端分配一个进程/线程。</p><p>不管是基于重一点的进程模型，还是轻一点的线程模型，假如连接多了，操作系统是扛不住的。</p><p>所以就引入了<strong>I/O多路复用</strong> 技术。</p><p>简单说，就是一个进程/线程维护多个Socket，这个多路复用就是多个连接复用一个进程/线程。</p><p><img src="https://s2.loli.net/2023/04/01/oFyVwKd3bjkCvHp.png" alt="I/O多路复用"></p><p>我们来看看I/O多路复用三种实现机制：</p><ul><li><strong>select</strong></li></ul><p>select 实现多路复⽤的⽅式是：</p><p>将已连接的 Socket 都放到⼀个<strong>⽂件描述符集合</strong>fd_set，然后调⽤ select 函数将fd_set集合拷⻉到内核⾥，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是通过遍历fd_set的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着再把整个fd_set拷⻉回⽤户态⾥，然后⽤户态还需要再通过遍历的⽅法找到可读或可写的 Socket，再对其处理。</p><p>select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的，在Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最⼤值为 1024 ，只能监听 0~1023 的⽂件描述符。</p><blockquote><p>select机制的缺点：</p></blockquote><p>（1）每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大，比如百万连接却只有少数活跃连接时这样做就太没有效率。</p><p>（2）每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大。</p><p>（3）为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，一般为1024，如果想要修改会比较麻烦，可能还需要编译内核。</p><p>（4）每次调用select之前都需要遍历设置监听集合，重复工作。</p><ul><li><strong>poll</strong></li></ul><p>poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤动态数组，以链表形式来组织，突破了select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。</p><p>但是 poll 和 select 并没有太⼤的本质区别，都是使⽤线性结构存储进程关注的Socket集合，因此都需要遍历⽂件描述符集合来找到可读或可写的Socke，时间复杂度为O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。</p><ul><li><strong>epoll</strong></li></ul><p>epoll 通过两个⽅⾯，很好解决了 select/poll 的问题。</p><p>第⼀点，epoll 在内核⾥使⽤<strong>红⿊树来跟踪进程所有待检测的⽂件描述字</strong>，把需要监控的 socket 通过epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，增删查⼀般时间复杂度是O(logn) ，通过对这棵⿊红树进⾏操作，这样就不需要像 select/poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，<strong>减少了内核和⽤户空间⼤量的数据拷⻉和内存分配</strong>。</p><p>第⼆点， epoll 使⽤事件驱动的机制，内核⾥<strong>维护了⼀个链表来记录就绪事件</strong>，当某个 socket 有事件发⽣时，通过回调函数，内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤ epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。</p><p><img src="https://s2.loli.net/2023/04/01/AsyP4k8YQWv6C59.png" alt="epoll接口作用-来源参考[3]"></p><p>epoll 的⽅式即使监听的 Socket 数量越多的时候，效率不会⼤幅度降低，能够同时监听的 Socket 的数⽬也⾮常的多了，上限就为系统定义的进程打开的最⼤⽂件描述符个数。因⽽，<strong>epoll</strong> <strong>被称为解决</strong> <strong>C10K</strong> <strong>问题的利器</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(修正版)</title>
      <link href="/posts/fa1f3033.html"/>
      <url>/posts/fa1f3033.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="1-说下计算机网络体系结构">1.说下计算机网络体系结构</h3><p>计算机网络体系结构，一般有三种：OSI 七层模型、TCP/IP 四层模型、五层结构。</p><p><img src="https://s2.loli.net/2023/04/22/HBZLn27selyWFQV.png" alt="网络模型"></p><p>简单说，OSI 是一个理论上的网络通信模型，TCP/IP 是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。</p><blockquote><p>网络上对 <strong>TCP/IP</strong> 每一层结构命名都不一样，连百度百科的解释和后面的层都是对不上的。<strong>链路层</strong>在百度百科也有叫<strong>网络接口层</strong>的。</p></blockquote><h3 id="2-说一下每一层对应的网络协议有哪些？">2.说一下每一层对应的网络协议有哪些？</h3><p>一张表格总结常见网络协议：</p><p><img src="https://s2.loli.net/2023/04/01/l1WJ4SXdAytwxkp.png" alt="各层网络对应的网络协议"></p><h3 id="3-那么数据在各层之间是怎么传输的呢？">3.那么数据在各层之间是怎么传输的呢？</h3><p>对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。</p><ul><li>发送方的应用进程向接收方的应用进程传送数据</li><li>AP 先将数据交给本主机的应用层，应用层加上本层的控制信息 H5 就变成了下一层的数据单元</li><li>传输层收到这个数据单元后，加上本层的控制信息 H4（即TCP头），再交给网络层，成为网络层的数据单元</li><li>网络层在这个数据单元前面加上H3（即IP头），再交给数据链路层</li><li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2，即帧头）和尾部（T2，即帧尾）</li><li>最后的物理层，进行比特流的传输</li></ul><p><img src="https://s2.loli.net/2023/04/01/98YajlNQOVPrtvI.png" alt="数据在各层之间的传输"></p><p>这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</p><h2 id="网络综合">网络综合</h2><h3 id="4-从浏览器地址栏输入-url-到显示主页的过程？">4.从浏览器地址栏输入 url 到显示主页的过程？</h3><p>这道题，大概的过程比较简单，但是有很多点可以细挖：DNS 解析、TCP 三次握手、HTTP 报文格式、TCP 四次挥手等等。</p><ol><li>DNS 解析：将域名解析成对应的 IP 地址。</li><li>TCP 连接：与服务器通过三次握手，建立 TCP 连接</li><li>向服务器发送 Http 请求</li><li>服务器处理请求，返回 Http响应</li><li>浏览器解析并渲染页面</li><li>断开连接：TCP 四次挥手，连接结束</li></ol><p>我们以输入 <a href="http://www.baidu.com">www.baidu.com</a> 为例：</p><p><img src="https://s2.loli.net/2023/04/01/a1ExFi2jGdhKqct.png" alt="www.baidu.comliu 到显示主页"></p><blockquote><p>各个过程都使用了哪些协议？</p></blockquote><p><img src="https://s2.loli.net/2023/04/01/jug7bqyMavBOPo3.png" alt="www.baidu.comliu 到显示主页过程使用的协议"></p><h3 id="5-说说-DNS-的解析过程？">5.说说 DNS 的解析过程？</h3><p>DNS，英文全称是 <strong>domain name system</strong>，域名解析系统，它的作用也很明确，就是域名和 IP 相互映射。</p><p>DNS 的解析过程如下图：</p><p><img src="https://s2.loli.net/2023/04/01/cDQ17YABploIMk6.png" alt="DNS 解析流程"></p><p>假设你要查询 <strong><a href="http://www.baidu.com">www.baidu.com</a></strong> 的 IP 地址:</p><ul><li>首先会查找浏览器的缓存,看看是否能找到<strong><a href="http://www.baidu.com">www.baidu.com</a></strong>对应的 IP 地址，找到就直接返回；否则进行下一步。</li><li>将请求发往给本地 DNS 服务器，如果查找到也直接返回，否则继续进行下一步；</li></ul><p><img src="https://s2.loli.net/2023/04/01/W8nrSvzuwHMDY3G.png" alt="域名服务器层级"></p><ul><li>本地 DNS 服务器向<strong>根域名服务器</strong>发送请求，根域名服务器返回负责<code>com</code>的顶级域名服务器的 IP 地址的列表。</li><li>本地 DNS 服务器再向其中一个负责<code>com</code>的顶级域名服务器发送一个请求，返回负责<code>baidu.com</code>的权限域名服务器的 IP 地址列表。</li><li>本地 DNS 服务器再向其中一个权限域名服务器发送一个请求，返回<strong><a href="http://www.baidu.com">www.baidu.com</a></strong>所对应的 IP 地址。</li></ul><h3 id="6-说说-WebSocket-与-Socket-的区别？">6.说说 WebSocket 与 Socket 的区别？</h3><ul><li>Socket 其实就是等于 <strong>IP 地址 + 端口 + 协议</strong>。</li></ul><blockquote><p>具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。</p></blockquote><ul><li>WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 <strong>http 不支持持久化连接</strong>的问题。</li><li>Socket 一个是<strong>网编编程的标准接口</strong>，而 WebSocket 则是应用层通信协议。</li></ul><h3 id="7-说一下你了解的端口及对应的服务？">7.说一下你了解的端口及对应的服务？</h3><p><img src="https://s2.loli.net/2023/04/01/jIKG7XirV4J5FYS.png" alt="常见端口和服务"></p><h2 id="HTTP">HTTP</h2><h3 id="8-说说-HTTP-常用的状态码及其含义？">8.说说 HTTP 常用的状态码及其含义？</h3><p>HTTP 状态码首先应该知道个大概的分类：</p><ul><li>1XX：信息性状态码</li><li>2XX：成功状态码</li><li>3XX：重定向状态码</li><li>4XX：客户端错误状态码</li><li>5XX：服务端错误状态码</li></ul><p>几个常用的，面试之外，也应该记住：</p><p><img src="https://s2.loli.net/2023/04/01/9LjzeZAb32PYtU7.png" alt="常见 HTTP 状态码"></p><blockquote><p><strong>说一下 301 和 302 的区别？</strong></p></blockquote><ul><li>301：永久性移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址。</li><li>302：临时性性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址。</li></ul><p>用一个比喻，301 就是嫁人的新垣结衣，302 就是有男朋友的长泽雅美。</p><h3 id="9-HTTP-有哪些请求方式？">9.HTTP 有哪些请求方式？</h3><p><img src="https://s2.loli.net/2023/04/01/IRSqr265bzKj48p.png" alt="HTTP 请求方式"></p><p>其中，POST、DELETE、PUT、GET 的含义分别对应我们最熟悉的增、删、改、查。</p><h3 id="10-说⼀下-GET-和-POST-的区别？">10.说⼀下 GET 和 POST 的区别？</h3><p>可以从以下几个方面来说明 GET 和 POST 的区别：</p><p><img src="https://s2.loli.net/2023/04/01/CZY2D4wQIMcHGTv.png" alt="Get 和 Post 区别"></p><ol><li>从 HTTP 报文层面来看，GET 请求将信息放在 URL，POST 将请求信息放在请求体中。这一点使得 GET 请求携带的数据量有限，因为 URL 本身是有长度限制的，而 POST 请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET 请求把数据放 URL 上不太安全，而 POST 请求把数据放在请求体里想比较而言安全一些。</li><li>从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。这个其实和 GET/POST 请求的作用有关。按照 HTTP 的约定，GET 请求用于查看信息，不会改变服务器上的信息；而 POST 请求用来改变服务器上的信息。正因为 GET 请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据。</li><li>从其他层面来看，GET 请求能够被缓存，GET 请求能够保存在浏览器的浏览记录里，GET 请求的 URL 能够保存为浏览器书签。这些都是 POST 请求所不具备的。缓存是 GET 请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的 GET 请求都被 CDN 缓存起来了，大大减少了 Web 服务器的负担。</li></ol><h3 id="11-GET-的长度限制是多少？">11.GET 的长度限制是多少？</h3><p>HTTP 中的 GET 方法是通过 URL 传递数据的，但是 URL 本身其实并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器。</p><p>例如 IE 浏览器对 URL 的最大限制是 2000 多个字符，大概 2kb 左右，像 Chrome、Firefox 等浏览器支持的 URL 字符数更多，其中 FireFox 中 URL 的最大长度限制是 65536 个字符，Chrome 则是 8182 个字符。</p><p>这个长度限制也不是针对数据部分，而是针对整个 URL。</p><h3 id="12-HTTP-请求的过程与原理？">12.HTTP 请求的过程与原理？</h3><p>HTTP 协议定义了浏览器怎么向服务器请求文档，以及服务器怎么把文档传给浏览器。</p><p><img src="https://s2.loli.net/2023/04/01/ur6pIUN8qDT4HaG.png" alt="HTTP 请求的过程和原理"></p><ul><li>每个服务器都有一个进程，它不断监听 TCP 的端口 80，以便发现是否有浏览器向它发出连接建立请求</li><li>监听到连接请求，就会建立 TCP 连接</li><li>浏览器向服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应</li><li>最后，释放 TCP 连接</li></ul><p>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则，这些格式和规则就是超文本传输协议 HTTP。</p><p>PS:这道题和上面浏览器输入网址发生了什么那道题大差不差。</p><h3 id="13-说一下-HTTP-的报文结构？">13.说一下 HTTP 的报文结构？</h3><p>HTTP 报文有两种，HTTP 请求报文和 HTTP 响应报文：</p><p><img src="https://s2.loli.net/2023/04/01/uvePtg5G4bAqy7B.png" alt="HTTP 报文"></p><p><strong>HTTP 请求报文</strong></p><p>HTTP 请求报文的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。</p><p>请求行包含三个字段：</p><ul><li>方法字段：包括 POST、GET 等请方法。</li><li>URL 字段</li><li>HTTP 版本字段。</li></ul><p><strong>HTTP 响应报文</strong></p><p>HTTP 响应报文的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>HTTP 响应报文的第一行叫做<strong>状态行</strong>，后面的行是<strong>首部行</strong>，最后是<strong>实体主体</strong>。</p><ul><li><p><strong>状态行</strong>包含了三个字段：协议版本字段、状态码和相应的状态信息。</p></li><li><p><strong>实体部分</strong>是报文的主要部分，它包含了所请求的对象。</p></li><li><p><strong>首部行</strong>首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。</p></li><li><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p></li><li><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p></li><li><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p></li><li><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</p></li></ul><h3 id="14-URI-和-URL-有什么区别">14.URI 和 URL 有什么区别?</h3><p><img src="https://s2.loli.net/2023/04/01/8jEByNJlYMsodfx.png" alt="URI 和 URL"></p><ul><li>URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是 Web 上每一种可用的资源，如 HTML 文档、图像、视频片段、程序等都是由一个 URI 进行标识的。</li><li>URL，统一资源定位符（Uniform Resource Location)，它是 URI 的一种子集，主要作用是提供资源的路径。</li></ul><p>它们的主要区别在于，URL 除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx 职业技术学院/14 号宿舍楼/525 号寝/张三.男。</p><h3 id="15-说下-HTTP-1-0，1-1，2-0-的区别？">15.说下 HTTP/1.0，1.1，2.0 的区别？</h3><p>关键需要记住 <strong>HTTP/1.0</strong> 默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用<strong>多路复用</strong>。</p><p><strong>HTTP/1.0</strong></p><ul><li>默认使用<strong>短连接</strong>，每次请求都需要建立一个 TCP 连接。它可以设置<code>Connection: keep-alive</code> 这个字段，强制开启长连接。</li></ul><p><strong>HTTP/1.1</strong></p><ul><li>引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。</li><li>分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。</li><li>管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。</li></ul><p><strong>HTTP/2.0</strong></p><ul><li>二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。</li><li>完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</li><li>报头压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送。</li><li>服务端推送，允许服务器未经请求，主动向客户端发送资源。</li></ul><h3 id="16-HTTP-3-了解吗？">16.HTTP/3 了解吗？</h3><p>HTTP/3 主要有两大变化，<strong>传输层基于 UDP</strong>、使用<strong>QUIC 保证 UDP 可靠性</strong>。</p><p>HTTP/2 存在的一些问题，比如重传等等，都是由于 TCP 本身的特性导致的，所以 HTTP/3 在 QUIC 的基础上进行发展而来，QUIC（Quick UDP Connections）直译为快速 UDP 网络连接，底层使用 UDP 进行数据传输。</p><p>HTTP/3 主要有这些特点：</p><ul><li>使用 UDP 作为传输层进行通信</li><li>在 UDP 的基础上 QUIC 协议保证了 HTTP/3 的安全性，在传输的过程中就完成了 TLS 加密握手</li><li>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 <strong>3</strong> 次，减少了交互次数。</li><li>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。</li></ul><p>我们拿一张图看一下 HTTP 协议的变迁：</p><p><img src="https://s2.loli.net/2023/04/01/CmRI1FZjhpYOeQc.png" alt="HTTP 协议变迁"></p><h3 id="17-HTTP-如何实现长连接？在什么时候会超时？">17.HTTP 如何实现长连接？在什么时候会超时？</h3><blockquote><p><strong>什么是 HTTP 的长连接？</strong></p></blockquote><ol><li>HTTP 分为长连接和短连接，<strong>本质上说的是 TCP 的长短连接</strong>。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法。</li><li>TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。</li></ol><blockquote><p><strong>如何设置长连接？</strong></p></blockquote><p>通过在头部（请求和响应头）设置 <strong>Connection</strong> 字段指定为<code>keep-alive</code>，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。</p><blockquote><p><strong>在什么时候会超时呢？</strong></p></blockquote><ul><li>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</li><li>TCP 的 <strong>keep-alive</strong> 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 <strong>tcp_keepalive_time</strong>，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. tcp_keepalive_intvl = 15</span><br><span class="line">2. tcp_keepalive_probes = 5</span><br><span class="line">3. tcp_keepalive_time = 1800</span><br></pre></td></tr></table></figure><h3 id="18-说说-HTTP-与-HTTPS-有哪些区别？">18.说说 HTTP 与 HTTPS 有哪些区别？</h3><ol><li>HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。</li><li>HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。</li><li>HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ol><h3 id="19-为什么要用-HTTPS？解决了哪些问题？">19.为什么要用 HTTPS？解决了哪些问题？</h3><p>因为 HTTP 是明⽂传输，存在安全上的风险：</p><p><strong>窃听⻛险</strong>，⽐如通信链路上可以获取通信内容，用户账号被盗。</p><p><strong>篡改⻛险</strong>，⽐如强制植⼊垃圾⼴告，视觉污染。</p><p><strong>冒充⻛险</strong>，⽐如冒充淘宝⽹站，用户金钱损失。</p><p><img src="https://s2.loli.net/2023/04/01/UspFAgJvCofVi3X.png" alt="HTTP 和 HTTPS"></p><p>所以引入了 HTTPS，HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了这些风险：</p><ul><li><strong>信息加密</strong>：交互信息⽆法被窃取。</li><li><strong>校验机制</strong>：⽆法篡改通信内容，篡改了就不能正常显示。</li><li><strong>身份证书</strong>：能证明淘宝是真淘宝。</li></ul><p>所以 SSL/TLS 协议是能保证通信是安全的。</p><h3 id="20-HTTPS-工作流程是怎样的？">20.HTTPS 工作流程是怎样的？</h3><p>这道题有几个要点：<strong>公私钥、数字证书、加密、对称加密、非对称加密</strong>。</p><p>HTTPS 主要工作流程：</p><ol><li>客户端发起 HTTPS 请求，连接到服务端的 443 端口。</li><li>服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</li><li>服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</li><li>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</li><li>客户端将公钥加密后的密钥发送到服务器。</li><li>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</li><li>服务器将加密后的密文返回到客户端。</li><li>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</li></ol><p><img src="https://s2.loli.net/2023/04/01/8kuKYWa1ACOEyRh.png" alt="https 主要流程"></p><p>这里还画了一张更详尽的图：</p><p><img src="https://s2.loli.net/2023/04/01/xOiplmAs6YcID9W.jpg" alt="https 工作流程详图"></p><h3 id="21-客户端怎么去校验证书的合法性？">21.客户端怎么去校验证书的合法性？</h3><p>首先，服务端的证书从哪来的呢？</p><p>为了让服务端的公钥被⼤家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA 就是⽹络世界⾥的公安局、公证中⼼，具有极⾼的可信度，所以由它来给各个公钥签名，信任的⼀⽅签发的证书，那必然证书也是被信任的。</p><p><img src="https://s2.loli.net/2023/04/01/XT8SWCBQnkjL1Os.png" alt="证书签名和客户端校验-来源参考"></p><p>CA 签发证书的过程，如上图左边部分：</p><ul><li>⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；</li><li>然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程，如上图右边部分：</p><ul><li>⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate Signature 内容，得到⼀个 Hash 值 H2 ；</li><li>最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p>假如在 HTTPS 的通信过程中，中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以 CA 公钥解密的内容就不一致。</p><h3 id="22-如何理解-HTTP-协议是无状态的？">22.如何理解 HTTP 协议是无状态的？</h3><p>这个<code>无状态</code>的<code>状态</code>值的是什么？是客户端的状态，所以字面意思，就是 HTTP 协议中服务端不会保存客户端的任何信息。</p><p>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p><blockquote><p><strong>那有什么办法记录状态呢？</strong></p></blockquote><p>主要有两个办法，Session 和 Cookie。</p><h3 id="23-说说-Session-和-Cookie-有什么联系和区别">23.说说 Session 和 Cookie 有什么联系和区别?</h3><p>先来看看什么是 Session 和 Cookie ：</p><ul><li>Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。服务端可以根据这个 Cookie 判断用户的身份和状态。</li><li>Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。</li></ul><p><img src="https://s2.loli.net/2023/04/01/14uh2iDY6mQMFVq.png" alt="Cookie 和 Session"></p><blockquote><p>Session 和 Cookie 到底有什么不同呢？</p></blockquote><ul><li>存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。</li><li>存储数据类型不一样，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><blockquote><p>Session 和 Cookie 有什么关联呢？</p></blockquote><p>可以使用 Cookie 记录 Session 的标识。</p><p><img src="https://s2.loli.net/2023/04/01/VjQYcFlwZEizKad.png" alt="Session 和 Cookie 的关联"></p><ul><li>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。</li><li>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul><blockquote><p><strong>分布式环境下 Session 怎么处理呢？</strong></p></blockquote><p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的 Session。</p><p>这时候怎么办呢？</p><p>可以使用 Redis 等分布式缓存来存储 Session，在多台服务器之间共享。</p><p><img src="https://s2.loli.net/2023/04/01/kpZQeCgmHRdWbGS.png" alt="Session 共享"></p><blockquote><p><strong>客户端无法使用 Cookie 怎么办？</strong></p></blockquote><p>有可能客户端无法使用 Cookie，比如浏览器禁用 Cookie，或者客户端是安卓、IOS 等等。</p><p>这时候怎么办？SessionID 怎么存？怎么传给服务端呢？</p><p>首先是 SessionID 的存储，可以使用客户端的本地存储，比如浏览器的 sessionStorage。</p><p>接下来怎么传呢？</p><ul><li>拼接到 URL 里：直接把 SessionID 作为 URL 的请求参数</li><li>放到请求头里：把 SessionID 放到请求的 Header 里，比较常用。</li></ul><h2 id="TCP">TCP</h2><h3 id="24-详细说一下-TCP-的三次握手机制">24.详细说一下 TCP 的三次握手机制</h3><div class="note warning modern"><p>TCP 三次握手是最重要的知识点，一定要熟悉到，问即送分。</p></div><p><img src="https://s2.loli.net/2023/04/22/n8dvytJF3UNC1wS.png" alt="TCP三次握手"></p><p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 <strong><code>CLOSE</code></strong> 阶段，被动打开的服务器也结束 <strong><code>CLOSE</code></strong> 阶段，并进入 <strong><code>LISTEN</code></strong> 阶段。随后进入三次握手阶段：</p><ol><li><p>首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p><ul><li>标志位为 <strong><code>SYN</code></strong>，表示请求建立连接；</li><li>序号为 <strong><code>Seq = x</code></strong>（x 一般取随机数）；</li><li>随后客户端进入 <strong><code>SYN-SENT</code></strong> 阶段。</li></ul></li><li><p>服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 <strong><code>LISTEN</code></strong> 阶段，并返回一段 TCP 报文，其中：</p><ul><li>标志位为 <strong><code>SYN</code></strong> 和 <strong><code>ACK</code></strong>，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；</li><li>序号为 <strong><code>Seq = y</code></strong>；</li><li>确认号为 <strong><code>ack = x + 1</code></strong>，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 ACK 的值，随后服务器端进入 <strong><code>SYN-RECV</code></strong> 阶段。</li></ul></li><li><p>客户端接收到发送的 <strong><code>SYN + ACK</code></strong> 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 <strong><code>SYN-SENT</code></strong> 阶段。并返回最后一段报文。其中：</p><ul><li>标志位为 <strong><code>ACK</code></strong>，表示确认收到服务器端同意连接的信号；</li><li>序号为 <strong><code>Seq = x + 1</code></strong>，表示收到服务器端的确认号 <strong><code>ACK</code></strong>，并将其值作为自己的序号值；</li><li>确认号为 <strong><code>ack = y + 1</code></strong>，表示收到服务器端序号 Seq ，并将其值加 1 作为自己的确认号 <strong><code>ack</code></strong> 的值。</li><li>随后客户端进入 ESTABLISHED。</li></ul></li></ol><h3 id="25-TCP-握手为什么是三次，为什么不能是两次？不能是四次？">25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h3><blockquote><p><strong>为什么不能是两次？</strong></p></blockquote><ul><li>为了防止服务器端开启一些无用的连接增加服务器开销</li><li>防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</li></ul><p>当客户端向服务器发送连接请求时，可能会出现以下情况：</p><ol><li><p>第一种情况：可能存在历史连接的延续。假设客户端发送一个连接请求，但是由于某种原因导致服务器没有收到请求，客户端可能会认为连接已经建立，但是服务器并不知道。如果后来有其他客户端向服务器发送请求，而请求中恰好包含了与之前客户端相同的源地址和端口号，那么服务器就会误认为这是之前客户端发送的请求，从而建立连接，这就导致了历史连接的延续，可能会给网络带来安全隐患。</p><blockquote><p>简单的说就是<strong>已失效的连接请求又传送到服务器端，因而产生错误</strong></p></blockquote><p><img src="https://s2.loli.net/2023/04/22/OLDEza37Gogq18r.png" alt="响应生效请求"></p></li><li><p>第二种情况：服务器向客户端发送的SYN+ACK报文段在网络中丢失了。这种情况下，客户端并没有收到服务器的确认，无法进行后续的数据传输，而服务器仍然认为连接已经建立成功，也会一直等待客户端的数据传输请求。</p><p><img src="https://s2.loli.net/2023/04/01/OFIkuh7fxosCVQm.png" alt="无三次握手导致端口占用"></p></li></ol><p>由于以上两种情况的存在，如果只进行两次握手，就无法完全保证后续的数据传输安全可靠。因此，在TCP协议中采用三次握手来建立连接，确保客户端和服务器之间建立可靠的传输连接。</p><blockquote><p>为什么不能是4次</p></blockquote><p>简单说，就是三次握手已经足够创建可靠的连接，没有必要再多一次握手导致花费更多的时间建立连接。</p><p><a href="https://www.bilibili.com/video/BV1kV411j7hA/?share_source=copy_web&amp;vd_source=fe2653ebe933d4d68f2279ef88b506f5">一条视频讲清楚TCP协议与UDP协议-什么是三次握手与四次挥手</a></p><h3 id="26-三次握手中每一次没收到报文会发生什么情况？">26.三次握手中每一次没收到报文会发生什么情况？</h3><ul><li><p>第一次握手服务端未收到 SYN 报文</p><p>服务端不会进行任何的动作，而客户端由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送 SYN 报文，如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。</p></li><li><p>第二次握手客户端未收到服务端响应的 ACK 报文</p><p>客户端会继续重传，直到次数限制；而服务端此时会阻塞在 accept()处，等待客户端发送 ACK 报文</p></li><li><p>第三次握手服务端为收到客户端发送过来的 ACK 报文</p><p>服务端同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则 accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的 accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送 RST 报文给客户端，消除客户端单方面建立连接的状态。</p></li></ul><h3 id="27-第二次握手传回了-ACK，为什么还要传回-SYN？">27.第二次握手传回了 ACK，为什么还要传回 SYN？</h3><p>ACK 是为了告诉客户端传来的数据已经接收无误。</p><p>而传回 SYN 是为了告诉客户端，服务端响应的确实是客户端发送的报文。</p><h3 id="28-第-3-次握手可以携带数据吗？">28.第 3 次握手可以携带数据吗？</h3><p>第 3 次握手是可以携带数据的。</p><p>此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。</p><p>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在 SYN 报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成 CPU 和内存的消耗。</p><h3 id="29-说说半连接队列和-SYN-Flood-攻击的关系？">29.说说半连接队列和 SYN Flood 攻击的关系？</h3><blockquote><p><strong>什么是半连接队列？</strong></p></blockquote><p>TCP 进入三次握手前，服务端会从 <strong>CLOSED</strong> 状态变为 <strong>LISTEN</strong> 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。</p><p><img src="https://s2.loli.net/2023/04/01/qbGn6m5vSQrYRdc.png" alt="三次握手中创建的队列"></p><p>顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。</p><ul><li>TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 <strong>ACK 和 SYN</strong>，状态由 <strong>LISTEN 变为 SYN_RCVD</strong>，此时这个连接就被推入了 <strong>SYN 队列</strong>，即半连接队列。</li><li>当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。</li></ul><blockquote><p><strong>什么是 SYN Flood ？</strong></p></blockquote><p>SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造<strong>不存在的 IP 地址</strong>, 向服务器发送大量 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么 SYN 队列里的连接旧不会出对队，久⽽久之就会占满服务端的 <strong>SYN</strong> 接收队列（半连接队列），使得服务器不能为正常⽤户服务。</p><p><img src="https://s2.loli.net/2023/04/01/zpesnQrMb4JxRXu.png" alt="SYN 攻击"></p><blockquote><p><strong>那有什么应对方案呢？</strong></p></blockquote><p>主要有 <strong>syn cookie</strong> 和 <strong>SYN Proxy 防火墙</strong>等。</p><ul><li><strong>syn cookie</strong>：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。</li><li><strong>SYN Proxy 防火墙</strong>：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。</li></ul><h3 id="30-说说-TCP-四次挥手的过程？">30.说说 TCP 四次挥手的过程？</h3><div class="note warning modern"><p>问完三次握手，常常也会顺道问问四次挥手，所以也是必须掌握知识点。</p></div><p><img src="https://s2.loli.net/2023/04/01/ozlYt6eH9J5AUVE.png" alt="TCP 四次挥手"></p><p>TCP 四次挥手过程：</p><ul><li>数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起</li><li>客户端发送释放连接报文，<strong>第一次挥手</strong> (FIN=1，seq=u)，发送完毕后，客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li><li>服务端发送确认报文，<strong>第二次挥手</strong> (ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态。</li><li>服务端发送释放连接报文，<strong>第三次挥手</strong> (FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 ACK。</li><li>客户端发送确认报文，<strong>第四次挥手</strong> (ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，<strong>等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后</strong>，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li></ul><p>大白话说四次挥手：</p><p>假如单身狗博主有一个女朋友—由于博主上班九九六，下班肝博客，导致没有时间陪女朋友，女朋友忍无可忍。</p><ul><li>女朋友：狗男人，最近你都不理我，你是不是不爱我了？你是不是外面有别的狗子了？我要和你分手？</li><li>沙雕博主一愣，怒火攻心：分手就分手，不陪你闹了，等我把东西收拾收拾。</li></ul><p>沙雕博主小心翼翼地装起了自己的青轴机械键盘。</p><ul><li>哼，蠢女人，我已经收拾完了，我先滚为敬，再见！</li><li>女朋友：滚，滚的远远的，越远越好，我一辈子都不想再见到你。</li></ul><p>挥手的故事总充满了悲伤和遗憾！</p><p><img src="https://s2.loli.net/2023/04/01/m3vidCsI7BgXzaR.png" alt="大白话四次挥手"></p><h3 id="31-TCP-挥手为什么需要四次呢？">31.TCP 挥手为什么需要四次呢？</h3><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p><h3 id="32-TCP-四次挥手过程中，为什么需要等待-2MSL-才进入-CLOSED-关闭状态？">32.TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</h3><blockquote><p><strong>为什么需要等待？</strong></p></blockquote><p><strong>1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。</strong> 这个 ACK 报文段有可能丢失，因而使处在 <strong>LAST-ACK</strong> 状态的服务端就收不到对已发送的 <strong>FIN + ACK</strong> 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（<strong>超时 + 1MSL 传输</strong>）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 <strong>CLOSED</strong> 状态。</p><p><strong>2. 防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p><blockquote><p><strong>为什么等待的时间是 2MSL？</strong></p></blockquote><p>MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。</p><p>TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 <strong>2</strong> 倍的时间。</p><p><img src="https://s2.loli.net/2023/04/01/Obu1iyacg2S6dNG.png" alt="2MSL 恰好一个来回"></p><p>⽐如如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。</p><h3 id="33-保活计时器有什么用？">33.保活计时器有什么用？</h3><p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。</p><p>设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p><p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p><h3 id="34-CLOSE-WAIT-和-TIME-WAIT-的状态和意义？">34.CLOSE-WAIT 和 TIME-WAIT 的状态和意义？</h3><blockquote><p><strong>CLOSE-WAIT 状态有什么意义？</strong></p></blockquote><p>服务端收到客户端关闭连接的请求并确认之后，就会进入 CLOSE-WAIT 状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务端在关闭连接之前将待发送的数据处理完。</p><blockquote><p><strong>TIME-WAIT 有什么意义？</strong></p></blockquote><p>TIME-WAIT 状态发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入 TIME-WAIT 状态。</p><p>它存在的意义主要是两个：</p><p><img src="https://s2.loli.net/2023/04/01/jGKCi6Y4E3JFy2s.png" alt="TIME_WAIT 状态的作用"></p><ul><li><strong>防⽌旧连接的数据包</strong></li></ul><p>如果客户端收到服务端的 FIN 报文之后立即关闭连接，但是此时服务端对应的端口并没有关闭，如果客户端在相同端口建立新的连接，可能会导致新连接收到旧连接残留的数据包，导致不可预料的异常发生。</p><ul><li><strong>保证连接正确关闭</strong></li></ul><p>假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，如果客户端没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会使用 RST 包来响应服务端，导致服务端以为有错误发生，然而实际关闭连接过程是正常的。</p><h3 id="35-TIME-WAIT-状态过多会导致什么问题？怎么解决？">35.TIME_WAIT 状态过多会导致什么问题？怎么解决？</h3><blockquote><p><strong>TIME_WAIT 状态过多会导致什么问题?</strong></p></blockquote><p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。</p><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><p>第⼀是内存资源占⽤；</p><p>第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；</p><blockquote><p><strong>怎么解决 TIME_WAIT 状态过多？</strong></p></blockquote><ul><li>服务器可以设置 SO_REUSEADDR 套接字来通知内核，如果端口被占用，但是 TCP 连接位于 TIME_WAIT 状态时可以重用端口。</li><li>还可以使用长连接的方式来减少 TCP 的连接和断开，在长连接的业务里往往不需要考虑 TIME_WAIT 状态。</li></ul><h3 id="36-说说-TCP-报文首部的格式？">36.说说 TCP 报文首部的格式？</h3><p>看一下 TCP 报文首部的格式：</p><p><img src="https://s2.loli.net/2023/04/01/PXiZgbCATVLIUvk.png" alt="TCP 报文首部的格式"></p><ul><li><strong>16 位端口号</strong>：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序</li><li><strong>32 位序号</strong>：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</li><li><strong>32 位确认号</strong>：用作对另一方发送的 tcp 报文段的响应。其值是收到的 TCP 报文段的序号值加 1。</li><li><strong>4 位首部长度</strong>：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标识 15，所以 TCP 头部最长是 60 字节。</li><li><strong>6 位标志位</strong>：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PST（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）</li><li><strong>16 位窗口大小</strong>：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li><li><strong>16 位校验和</strong>：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</li><li><strong>16 位紧急指针</strong>：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</li></ul><h3 id="37-TCP-是如何保证可靠性的？">37.TCP 是如何保证可靠性的？</h3><p>TCP 主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。</p><p><img src="https://s2.loli.net/2023/04/01/u9rTCWBlORcshmD.png" alt="TCP 保证可靠性的方法"></p><ol><li><strong>连接管理</strong>：TCP 使用三次握手和四次挥手保证可靠地建立连接和释放连接，这里就不用多说了。</li><li><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li></ol><p><img src="https://s2.loli.net/2023/04/01/ZDLX4W7acsdnex3.png" alt=""></p><p>TCP 校验和</p><ol start="3"><li><strong>序列号/确认应答</strong>：TCP 给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包，如果发现没有收到，就会重发，这样就能保证数据的完整性。就像老师上课，会问一句，这一章听懂了吗？没听懂再讲一遍。</li></ol><p><img src="https://s2.loli.net/2023/04/01/VsRmjT15ZS2YLe4.png" alt="序列号/确认应答"></p><ol start="4"><li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）</li></ol><p><img src="https://s2.loli.net/2023/04/01/qUbW1VXjgEOQzpv.png" alt="滑动窗口简图"></p><ol start="5"><li><strong>最大消息长度</strong>：在建立 TCP 连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</li></ol><p><img src="https://s2.loli.net/2023/04/01/OajCXucBoK1HvJ8.png" alt="最大消息长度"></p><ol start="6"><li><strong>超时重传</strong>：超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。</li></ol><p><img src="https://s2.loli.net/2023/04/01/13q4UKF7jg9LvpY.png" alt="超时重传"></p><ol start="7"><li><strong>拥塞控制</strong>：如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此 TCP 引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。</li></ol><p><img src="https://s2.loli.net/2023/04/01/QxXK4swGF6ahPbI.png" alt="拥塞控制简略示意图"></p><h3 id="38-说说-TCP-的流量控制？">38.说说 TCP 的流量控制？</h3><p>TCP 提供了一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是<strong>流量控制</strong>。</p><p>TCP 通过<strong>滑动窗口</strong>来控制流量，我们看下简要流程：</p><ul><li>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。</li></ul><p><img src="https://s2.loli.net/2023/04/01/DiQbdfuSM6AReF1.jpg" alt="TCP 流量控制"></p><ul><li>假如当前发送方给接收方发送了 200 个字节，那么，发送方的<code>SND.NXT</code>会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。</li><li>接受方收到后，放到缓冲队列里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节</li><li>发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节，即 win=100 返回发送方。</li><li>发送方继续发送 100 字节过来，这时候，接收窗口 win 变为 0。</li><li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。</li></ul><h3 id="39-详细说说-TCP-的滑动窗口？">39.详细说说 TCP 的滑动窗口？</h3><p>TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。</p><p>“用一个比喻，我们在微信上聊天，你打完一句话，我回复一句之后，你才能打下一句。假如我没有及时回复呢？你是把话憋着不说吗？然后傻傻等到我回复之后再接着发下一句？”</p><p>为了解决这个问题，TCP 引入了<strong>窗口</strong>，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。</p><p>TCP 头部有个字段叫 win，也即那个 <strong>16 位的窗口大小</strong>，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到<strong>流量控制</strong>的目的。</p><p>“通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是 win。”</p><p>TCP 滑动窗口分为两种: 发送窗口和接收窗口。<strong>发送端的滑动窗口</strong>包含四大部分，如下：</p><ul><li>已发送且已收到 ACK 确认</li><li>已发送但未收到 ACK 确认</li><li>未发送但可以发送</li><li>未发送也不可以发送</li></ul><p><img src="https://s2.loli.net/2023/04/01/nirSuE51Xl78UGo.jpg" alt="发送端滑动窗口"></p><ul><li>深蓝色框里就是发送窗口。</li><li>SND.WND: 表示发送窗口的大小, 上图虚线框的格子数是 10 个，即发送窗口大小是 10。</li><li>SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。</li><li>SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。</li></ul><p>接收方的滑动窗口包含三大部分，如下：</p><ul><li>已成功接收并确认</li><li>未收到数据但可以接收</li><li>未收到数据并不可以接收的数据</li></ul><p><img src="https://s2.loli.net/2023/04/01/HVyvJoX1RqgtZfm.jpg" alt="接收方滑动窗口"></p><ul><li>蓝色框内，就是接收窗口。</li><li>REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。</li><li>REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。</li></ul><h3 id="40-了解-Nagle-算法和延迟确认吗？">40.了解 Nagle 算法和延迟确认吗？</h3><blockquote><p><strong>Nagle 算法和延迟确认是干什么的？</strong></p></blockquote><p>当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。</p><p><img src="https://s2.loli.net/2023/04/01/qBiyYCkps6xSTnV.png" alt="小数据情况"></p><p>这就好像快递员开着⼤货⻋送⼀个⼩包裹⼀样浪费。</p><p>那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：</p><ul><li>Nagle 算法</li><li>延迟确认</li></ul><blockquote><p><strong>Nagle 算法</strong></p></blockquote><p>Nagle 算法：<strong>任意时刻，最多只能有一个未被确认的小段</strong>。所谓 “小段”，指的是小于 MSS 尺寸的数据块，所谓 “未被确认”，是指一个数据块发送出去后，没有收到对方发送的 ACK 确认该数据已收到。</p><p>Nagle 算法的策略：</p><ul><li>没有已发送未确认报⽂时，⽴刻发送数据。</li><li>存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS ⼤⼩」时，再发送数据。</li></ul><p>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。</p><blockquote><p><strong>延迟确认</strong></p></blockquote><p>事实上当没有携带数据的 ACK，它的⽹络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报⽂。</p><p>为了解决 ACK 传输效率低问题，所以就衍⽣出了 <strong>TCP</strong> 延迟确认。</p><p>TCP 延迟确认的策略：</p><ul><li>当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅</li><li>当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送</li><li>如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK</li></ul><p>一般情况下，<strong>Nagle 算法和延迟确认</strong>不能一起使用，Nagle 算法意味着延迟发，<strong>延迟确认</strong>意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。</p><h3 id="41-说说-TCP-的拥塞控制？">41.说说 TCP 的拥塞控制？</h3><blockquote><p><strong>什么是拥塞控制？不是有了流量控制吗？</strong></p></blockquote><p>前⾯的流量控制是避免发送⽅的数据填满接收⽅的缓存，但是并不知道整个⽹络之中发⽣了什么。</p><p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。</p><p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤…</p><p>所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p><p>于是，就有了拥塞控制，控制的⽬的就是避免发送⽅的数据填满整个⽹络。</p><p>就像是一个水管，不能让太多的水（数据流）流入水管，如果超过水管的承受能力，水管会被撑爆（丢包）。</p><p>发送方维护一个<strong>拥塞窗口 cwnd（congestion window）</strong> 的变量，调节所要发送数据的量。</p><blockquote><p><strong>什么是拥塞窗⼝？和发送窗⼝有什么关系呢？</strong></p></blockquote><p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p><p>发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p><p>拥塞窗⼝ cwnd 变化的规则：</p><ul><li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li><li>但⽹络中出现了拥塞， cwnd 就减少；</li></ul><blockquote><p><strong>拥塞控制有哪些常用算法？</strong></p></blockquote><p>拥塞控制主要有这几种常用算法：</p><p><img src="https://s2.loli.net/2023/04/01/7ocqCasIkE4TA63.png" alt="拥塞控制常用算法"></p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h5 id="慢启动算法">慢启动算法</h5><p>慢启动算法，慢慢启动。</p><p>它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）</strong>。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p><p>举个例子：</p><ul><li>连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。</li><li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发 2 个，所以这⼀次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发 4 个，所以这⼀次能够发送 8 个。</li></ul><p><img src="https://s2.loli.net/2023/04/01/pASwybe3MXY4oR1.png" alt="慢启动算法"></p><p>发包的个数是指数性的增⻓。</p><p><img src="https://s2.loli.net/2023/04/01/WsxUezuOlqrG5N8.png" alt="慢启动呈指数型增长"></p><p>为了防止 cwnd 增长过大引起网络拥塞，还需设置一个<strong>慢启动阀值 ssthresh</strong>（slow start threshold）状态变量。当<code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 <strong>cwnd &gt;ssthresh</strong> 时，进入了<strong>拥塞避免</strong>算法。</p><h5 id="拥塞避免算法">拥塞避免算法</h5><p>一般来说，慢启动阀值 ssthresh 是 65535 字节，<code>cwnd</code>到达<strong>慢启动阀值</strong>后</p><ul><li>每收到一个 ACK 时，cwnd = cwnd + 1/cwnd</li><li>当每过一个 RTT 时，cwnd = cwnd + 1</li></ul><p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。</p><p>接着上面慢启动的例子，假定 ssthresh 为 8 ：：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。</li></ul><p><img src="https://s2.loli.net/2023/04/01/EPmC7f8tBruchAY.png" alt="拥塞避免算法"></p><h5 id="拥塞发生">拥塞发生</h5><p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：</p><ul><li>RTO 超时重传</li><li>快速重传</li></ul><p>如果是发生了 <strong>RTO 超时重传</strong>，就会使用拥塞发生算法</p><ul><li>慢启动阀值 sshthresh = cwnd /2</li><li>cwnd 重置为 1</li><li>进入新的慢启动过程</li></ul><p><img src="https://s2.loli.net/2023/04/01/ei4k7aRZdTouUAP.png" alt="拥塞发生算法"></p><p>这种方式就像是飙车的时候急刹车，还飞速倒车，这。。。</p><p>其实还有更好的处理方式，就是<strong>快速重传</strong>。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 <strong>RTO 超时</strong>再重传。</p><p>发⽣快速重传的拥塞发⽣算法：</p><ul><li>拥塞窗口大小 cwnd = cwnd/2</li><li>慢启动阀值 ssthresh = cwnd</li><li>进入快速恢复算法</li></ul><h5 id="快速恢复">快速恢复</h5><p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：</p><ul><li>cwnd = cwnd /2</li></ul><p>- sshthresh = cwnd</p><p>然后，进⼊快速恢复算法如下：</p><ul><li>cwnd = sshthresh + 3</li><li>重传重复的那几个 ACK（即丢失的那几个数据包）</li><li>如果再收到重复的 ACK，那么 cwnd = cwnd +1</li><li>如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li></ul><p><img src="https://s2.loli.net/2023/04/01/6bsv28lWM5LzBnG.png" alt="快速恢复算法"></p><h3 id="42-说说-TCP-的重传机制？">42.说说 TCP 的重传机制？</h3><p>重传包括<strong>超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种</strong>。</p><p><img src="https://s2.loli.net/2023/04/01/KlGqyXfahNjWIQ8.png" alt="TCP 重传分类"></p><h5 id="超时重传">超时重传</h5><p>超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。</p><blockquote><p><strong>超时时间应该设置为多少呢？</strong></p></blockquote><p>先来看下什么叫 <strong>RTT（Round-Trip Time，往返时间）</strong>。</p><p><img src="https://s2.loli.net/2023/04/01/Un6MuZgb1wfPJpc.png" alt="RTT"></p><p>RTT 就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。</p><p>超时重传时间，就是 RTO（Retransmission Timeout)。那么，<strong>RTO 到底设置多大呢？</strong></p><ul><li>如果 RTO 设置很大，等了很久都没重发，这样肯定就不行。</li><li>如果 RTO 设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。</li></ul><p>一般来说，RTO 略微大于 RTT，效果是最佳的。</p><p>其实，RTO 有个标准方法的计算公式，也叫 <strong>Jacobson / Karels 算法</strong>。</p><ol><li>首先计算 SRTT（即计算平滑的 RTT）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均</span><br></pre></td></tr></table></figure><ol start="2"><li>其次，计算 RTTVAR (round-trip time variation)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距</span><br></pre></td></tr></table></figure><ol start="3"><li>最后，得出最终的 RTO</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  </span><br></pre></td></tr></table></figure><p>在 Linux 下，<strong>α = 0.125</strong>，<strong>β = 0.25</strong>， <strong>μ = 1</strong>，<strong>∂ = 4</strong>。别问这些参数是怎么来的，它们是大量实践，调出的最优参数。</p><p>超时重传不是十分完美的重传方案，它有这些缺点：</p><ul><li>当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。</li><li>当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li></ul><p>并且，对于 TCP，如果发生一次超时重传，时间间隔下次就会加倍。</p><h5 id="快速重传">快速重传</h5><p>TCP 还有另外⼀种快速重传（<strong>Fast Retransmit</strong>）机制，它不以时间为驱动，⽽是以数据驱动重传。</p><p>它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。</p><p>可以用它来解决超时重发的时间等待问题，快速重传流程如下：</p><p><img src="https://s2.loli.net/2023/04/01/Lho84uQPOREqTge.png" alt="快速重传流程"></p><p>在上图，发送⽅发出了 1，2，3，4，5 份数据：</p><ul><li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li>发送端收到了三个 <strong>Ack = 2</strong> 的确认，知道了 <strong>Seq2</strong> 还没有收到，就会在定时器过期之前，重传丢失的 <strong>Seq2</strong>。</li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><p>快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。</p><p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。</p><p>根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是⼀把双刃剑。</p><p>为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。</p><h5 id="带选择确认的重传（SACK）">带选择确认的重传（SACK）</h5><p>为了解决应该重传多少个包的问题? TCP 提供了<strong>带选择确认的重传</strong>（即 SACK，Selective Acknowledgment）。</p><p><strong>SACK 机制</strong>就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。</p><p><img src="https://s2.loli.net/2023/04/01/sPyq4LdFWHnropm.png" alt="SACK 机制"></p><p>如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。</p><h5 id="重复-SACK（D-SACK）">重复 SACK（D-SACK）</h5><p>D-SACK，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。</p><p>DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。</p><p>例如 ACK 丢包导致的数据包重复：</p><p><img src="https://s2.loli.net/2023/04/01/jEI1PmKd5v7GiFu.png" alt="ACK 丢包"></p><ul><li>接收⽅发给发送⽅的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~</li></ul><p>3499）</p><ul><li>于是接收⽅发现数据是重复收到的，于是回了⼀个 <strong>SACK = 3000~3500</strong>，告诉「发送⽅」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK 。这样发送⽅就知道了，数据没有丢，是接收⽅的 ACK 确认报⽂丢了。</li></ul><h3 id="43-说说-TCP-的粘包和拆包？">43.说说 TCP 的粘包和拆包？</h3><p>TCP 的粘包和拆包更多的是业务上的概念！</p><blockquote><p><strong>什么是 TCP 粘包和拆包？</strong></p></blockquote><p>TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，<strong>一个完整的包可能会被 TCP 拆分成多个包进行发送</strong>，<strong>也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是所谓的 TCP 粘包和拆包问题。</p><p><img src="https://s2.loli.net/2023/04/01/XVRdTIDB62Ajter.png" alt="TCP 的粘包和拆包"></p><blockquote><p><strong>为什么会产生粘包和拆包呢?</strong></p></blockquote><ul><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li></ul><blockquote><p><strong>那怎么解决呢？</strong></p></blockquote><ul><li>发送端将每个数据包封装为固定长度</li><li>在数据尾部增加特殊字符进行分割</li><li>将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。</li></ul><h2 id="UDP">UDP</h2><p>UDP 问的不多，基本上是被拿来和 TCP 比较。</p><h3 id="44-说说-TCP-和-UDP-的区别？">44.说说 TCP 和 UDP 的区别？</h3><p>最根本区别：<strong>TCP 是面向连接，而 UDP 是无连接</strong>。</p><p><img src="https://s2.loli.net/2023/04/01/qXmKeu6xfFOIGdR.png" alt="TCP 和 UDP 区别"></p><p>可以这么形容：TCP 是打电话，UDP 是大喇叭。</p><p><img src="https://s2.loli.net/2023/04/01/d9tfZeoEuYOQL6h.png" alt="TCP 和 UDP 比喻"></p><blockquote><p><strong>说说 TCP 和 UDP 的应用场景？</strong></p></blockquote><ul><li><strong>TCP 应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有 UDP 高。例如：文件传输（准确高要求高、但是速度可以相对慢）、收发邮件、远程登录。</li><li><strong>UDP 应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ 聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li></ul><h3 id="45-为什么-QQ-采用-UDP-协议？">45.为什么 QQ 采用 UDP 协议？</h3><div class="note info modern"><p>这是多年前的老题了，拉出来怀怀旧。</p></div><p><img src="https://s2.loli.net/2023/04/01/XhKpYGUZijMRaIb.png" alt="QQ 使用 UDP"></p><ul><li>首先，QQ 并不是完全基于 UDP 实现。比如在使用 QQ 进行文件传输等活动的时候，就会使用 TCP 作为可靠传输的保证。</li><li>使用 UDP 进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP 是一个全双工协议，需要建立连接，所以网络开销也会相对大。</li><li>如果使用 QQ 语音和 QQ 视频的话，UDP 的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。</li><li>由于 QQ 的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用 UDP 协议与客户端进行通讯才能保证这种超大规模的服务</li></ul><p>简单总结一下：UDP 协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ 采用的通信协议以 UDP 为主，辅以 TCP 协议。</p><h3 id="46-UDP-协议为什么不可靠？">46.UDP 协议为什么不可靠？</h3><p>UDP 在传输数据之前不需要先建立连接，远地主机的运输层在接收到 UDP 报文后，不需要确认，提供不可靠交付。总结就以下四点：</p><ul><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制</li></ul><h3 id="47-DNS-为什么要用-UDP">47.DNS 为什么要用 UDP?</h3><p>更准确地说，DNS 既使用 TCP 又使用 UDP。</p><p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p><p>当客户端想 DNS 服务器查询域名（域名解析）的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节，用 UDP 传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><h2 id="IP">IP</h2><h3 id="48-IP-协议的定义和作用？">48.IP 协议的定义和作用？</h3><blockquote><p><strong>IP 协议是什么？</strong></p></blockquote><p>IP 协议（Internet Protocol）又被称为互联网协议，是支持网间互联的数据包协议，工作在<strong>网际层</strong>，主要目的就是为了提高网络的可扩展性。</p><p>通过<strong>网际协议 IP</strong>，可以把参与互联的，性能各异的网络<strong>看作一个统一的网络</strong>。</p><p><img src="https://s2.loli.net/2023/04/01/qYzxJvKwACml8cD.png" alt="虚拟 IP 网"></p><p>和传输层 TCP 相比，IP 协议是一种无连接/不可靠、尽力而为的数据包传输服务，和 TCP 协议一起构成了 TCP/IP 协议的核心。</p><blockquote><p><strong>IP 协议有哪些作用？</strong></p></blockquote><p>IP 协议主要有以下几个作用：</p><ul><li><strong>寻址和路由</strong>：在 IP 数据包中，携带源 IP 地址和目的 IP 地址，来表示该数据包的源主机和目标主机。IP 数据包在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至目标主机。</li><li><strong>分段和重组</strong>：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够被传输，被分段后的 IP 数据包可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的 IP 数据包。</li></ul><blockquote><p><strong>传输层协议和网络层协议有什么区别？</strong></p></blockquote><p>网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。</p><h3 id="49-IP-地址有哪些分类？">49.IP 地址有哪些分类？</h3><p>一个 IP 地址在这整个互联网范围内是惟一的，一般可以这么认为，IP 地址 = {&lt;网络号&gt;，&lt;主机号&gt;}。</p><ol><li><strong>网络号</strong>：它标志主机所连接的网络地址表示属于互联网的哪一个网络。</li><li><strong>主机号</strong>：它标志主机地址表示其属于该网络中的哪一台主机。</li></ol><p>IP 地址分为 A，B，C，D，E 五大类：</p><ul><li>A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。</li><li>B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。</li><li>C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。</li><li>D 类地址 (224~239)：以 1110 开头，保留为多播地址。</li><li>E 类地址 (240~255)：以 1111 开头，保留位为将来使用</li></ul><p><img src="https://s2.loli.net/2023/04/01/Opt5GwMuW1PVBFz.png" alt="IP 地址分类"></p><h3 id="50-域名和-IP-的关系？一个-IP-可以对应多个域名吗？">50.域名和 IP 的关系？一个 IP 可以对应多个域名吗？</h3><ul><li>IP 地址在同一个网络中是惟一的，用来标识每一个网络上的设备，其相当于一个人的身份证号</li><li>域名在同一个网络中也是惟一的，就像是一个人的名字、绰号</li></ul><p>假如你有多个不用的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是惟一的。但同时你的绰号也可能和别人重复，假如你不在，有人叫你的绰号，其它人可能就答应了。</p><p>一个域名可以对应多个 IP，但这种情况 DNS 做负载均衡的，在用户访问过程中，一个域名只能对应一个 IP。</p><p>而一个 IP 却可以对应多个域名，是一对多的关系。</p><h3 id="51-IPV4-地址不够如何解决？">51.IPV4 地址不够如何解决？</h3><p>我们知道，IP 地址有 32 位，可以标记 2 的 32 次方个地址，听起来很多，但是全球的网络设备数量已经远远超过这个数字，所以 IPV4 地址已经不够用了，那怎么解决呢？</p><p><img src="https://s2.loli.net/2023/04/01/raOS9qTW5pbXlAB.png" alt="IPV4 不够解决办法"></p><ul><li>DHCP：动态主机配置协议，动态分配 IP 地址，只给接入网络的设备分配 IP 地址，因此同一个 MAC 地址的设备，每次接入互联网时，得到的 IP 地址不一定是相同的，该协议使得空闲的 IP 地址可以得到充分利用。</li><li>CIDR：无类别域间路由。CIDR 消除了传统的 A 类、B 类、C 类地址以及划分子网的概念，因而更加有效地分配 IPv4 的地址空间，但无法从根本上解决地址耗尽的问题。</li><li>NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的 IP 地址，从而一定程度上缓解了 IP 资源枯竭的问题，然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT 方法可以将该主机 IP 地址转换为全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</li><li>IPv6：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个 IP 地址也够用，该协议能够从根本上解决 IPv4 地址不够用的问题。</li></ul><h3 id="52-说下-ARP-协议的工作过程？">52.说下 ARP 协议的工作过程？</h3><p>ARP 协议，<strong>Address Resolution Protocol</strong>，地址解析协议，它是用于实现 IP 地址到 MAC 地址的映射。</p><p><img src="https://s2.loli.net/2023/04/01/pzjeyRoCQH1Oc9W.png" alt="ARP 协议作用"></p><ol><li>首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。</li><li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。</li><li>网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。</li><li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li></ol><h3 id="53-为什么既有-IP-地址，又有-MAC-地址？">53.为什么既有 IP 地址，又有 MAC 地址？</h3><blockquote><p><strong>MAC 地址和 IP 地址都有什么作用？</strong></p></blockquote><ul><li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li></ul><blockquote><p><strong>为什么有了 MAC 地址还需要 IP 地址？</strong></p></blockquote><p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是最多共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256T 的内存，显然是不现实的。</p><p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p><blockquote><p><strong>为什么有了 IP 地址还需要 MAC 地址？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/04/01/OdNu6ihmDeSrno3.png" alt="IP 地址和 MAC 地址"></p><ul><li>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候，或者在分配 IP 的过程中。我们需要 MAC 地址来区分不同的设备。</li><li>IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。</li></ul><h3 id="54-ICMP-协议的功能？">54.ICMP 协议的功能？</h3><p>ICMP（Internet Control Message Protocol） ，网际控制报文协议。</p><ul><li>ICMP 协议是一种面向无连接的协议，用于传输出错报告控制信息。</li><li>它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括<strong>报告错误、交换受限控制和状态信息</strong>等。</li><li>当遇到 IP 数据无法访问目标、IP 路由器无法按当前的传输速率转发数据包等情况时，会自动发送 ICMP 消息。</li></ul><p>比如我们日常使用得比较多的 <strong>ping</strong>，就是基于 ICMP 的。</p><h3 id="55-说下-ping-的原理？">55.说下 ping 的原理？</h3><p>ping，<strong>Packet Internet Groper</strong>，是一种因特网包探索器，用于测试网络连接量的程序。Ping 是工作在 TCP/IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态。</p><p><img src="https://s2.loli.net/2023/04/01/yHpY84kXu7PcivR.png" alt="ping 百度"></p><p>一般来说，ping 可以用来检测网络通不通。它是基于<code>ICMP</code>协议工作的。假设<strong>机器 A</strong> ping <strong>机器 B</strong>，工作过程如下：</p><ol><li>ping 通知系统，新建一个固定格式的 ICMP 请求数据包</li><li>ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层</li><li>IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包</li><li>先获取目标机器 B 的 MAC 地址。</li><li>数据链路层构建一个数据帧，目的地址是 IP 层传过来的 <strong>MAC 地址</strong>，源地址是本机的 <strong>MAC 地址</strong></li><li>机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃。</li><li>根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间</li><li>最终显示结果有这几项：发送到目的主机的 IP 地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小、最大 &amp; 平均值</li></ol><h2 id="网络安全">网络安全</h2><h3 id="56-说说有哪些安全攻击？">56.说说有哪些安全攻击？</h3><p>网络安全攻击主要分为两种类型，<strong>被动攻击</strong>和<strong>主动攻击</strong>：</p><p><img src="https://s2.loli.net/2023/04/01/DUz18WgcPMFI7NG.png" alt="主动攻击和被动攻击"></p><ul><li><p><strong>被动攻击</strong>：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者没有修改数据，使得这种攻击很难被检测到。</p></li><li><p><strong>主动攻击</strong>：直接对现有的数据和服务造成影响，常见的主动攻击类型有：</p></li><li><p><strong>篡改</strong>：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。</p></li><li><p><strong>恶意程序</strong>：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。</p></li><li><p><strong>拒绝服务 Dos</strong>：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。</p></li></ul><h3 id="57-DNS-劫持了解吗？">57.DNS 劫持了解吗？</h3><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换，从而使用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。</p><p><img src="https://s2.loli.net/2023/04/01/PRfZd7Yw1DFqt3E.png" alt="DNS 劫持示意图"></p><p>域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它主持，并将新的域名信息保存在所指定的 DNS 服务器中，从而使用户无法对原域名来进行解析以访问目标地址。</p><blockquote><p><strong>DNS 劫持的步骤是什么样的？</strong></p></blockquote><ol><li>获取要劫持的域名信息：攻击者会首先访问域名查询要劫持的站点的域名信息。</li><li>控制域名响应的 E-Mail 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码，更高级的攻击者甚至能够直接对 E-Mail 进行信息窃取。</li><li>修改注册信息：当攻击者破解了 E-Mail 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。</li><li>使用 E-Mail 收发确认函：在修改完注册信息后，攻击者 E-Mail 在真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。</li></ol><blockquote><p><strong>怎么应对 DNS 劫持？</strong></p></blockquote><ul><li>直接通过 IP 地址访问网站，避开 DNS 劫持</li><li>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选 DNS 服务器的地址固定为 8.8.8.8。</li></ul><h3 id="58-什么是-CSRF-攻击？如何避免？">58.什么是 CSRF 攻击？如何避免？</h3><blockquote><p><strong>什么是 CSRF 攻击？</strong></p></blockquote><p>CSRF，跨站请求伪造（英文全称是 Cross-site request forgery），是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p><blockquote><p><strong>CSRF 是如何攻击的呢？</strong></p></blockquote><p>来看一个例子：</p><p><img src="https://s2.loli.net/2023/04/01/pKTNZQC5R2gLXO6.png" alt="CSRF 典型例子"></p><ol><li>用户登陆银行，没有退出，浏览器包含了 用户 在银行的身份认证信息。</li><li>攻击者将伪造的转账请求，包含在在帖子</li><li>用户在银行网站保持登陆的情况下，浏览帖子</li><li>将伪造的转账请求连同身份认证信息，发送到银行网站</li><li>银行网站看到身份认证信息，以为就是 用户的合法操作，最后造成用户资金损失。</li></ol><blockquote><p><strong>怎么应对 CSRF 攻击呢？</strong></p></blockquote><ul><li><p><strong>检查 Referer 字段</strong></p><p>HTTP 头中的 Referer 字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证 Referer 值来防御 CSRF 攻击。</p></li><li><p><strong>添加校验 token</strong></p><p>以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p></li><li><p><strong>敏感操作多重校验</strong></p><p>对一些敏感的操作，除了需要校验用户的认证信息，还可以通过邮箱确认、验证码确认这样的方式多重校验。</p></li></ul><h3 id="59-什么是-DoS、DDoS、DRDoS-攻击？">59.什么是 DoS、DDoS、DRDoS 攻击？</h3><p><img src="https://s2.loli.net/2023/04/01/RijVIPGAUXMQufe.png" alt="请求太多服务器着不住"></p><ul><li><p><strong>DOS</strong>: (Denial of Service), 翻译过来就是拒绝服务, 一切能引起拒绝 行为的攻击都被称为 DOS 攻击。最常见的 DoS 攻击就有<strong>计算机网络宽带攻击</strong>、<strong>连通性攻击</strong>。</p></li><li><p><strong>DDoS</strong>: (Distributed Denial of Service)，翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器，并利用这些机器对受害者同时实施攻击。主要形式有流量攻击和资源耗尽攻击，常见的 DDoS 攻击有：<strong>SYN Flood、Ping of Death、ACK Flood、UDP Flood</strong> 等。</p></li><li><p><strong>DRDoS</strong>: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者 IP 地址的数据包给攻击主机，然后攻击主机对 IP 地址源做出大量回应，从而形成拒绝服务攻击。</p></li></ul><blockquote><p><strong>如何防范 DDoS?</strong></p></blockquote><p>针对 DDoS 中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。</p><p>针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的 SYN 攻击包。我们也可以安装专业的抗 DDoS 防火墙，从而对抗 SYN Flood 等流量型攻击。瓷碗，负载均衡，CDN 等技术都能有效对抗 DDos 攻击。</p><h3 id="60-什么是-XSS-攻击，如何避免">60.什么是 XSS 攻击，如何避免?</h3><p>XSS 攻击也是比较常见，XSS，叫<strong>跨站脚本攻击（Cross-Site Scripting）</strong>，因为会与层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，因此有人将跨站脚本攻击缩写为 XSS。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览网页的时候，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。</p><p>XSS 攻击一般分三种类型：<strong>存储型 、反射型 、DOM 型 XSS</strong></p><blockquote><p><strong>XSS 是如何攻击的呢？</strong></p></blockquote><p>简单说，XSS 的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。</p><p>拿反射型举个例子吧，流程图如下：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，访问正常网站服务器</li><li>网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行，请求恶意服务器，发送用户数据</li><li>攻击者就可以窃取用户的数据，以此冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p><img src="https://s2.loli.net/2023/04/01/9UX1kmqpob2QBYv.png" alt="一个典型的 XSS"></p><blockquote><p><strong>如何应对 XSS 攻击？</strong></p></blockquote><ul><li>对输入进行过滤，过滤标签等，只允许合法值。</li><li>HTML 转义</li><li>对于链接跳转，如<code>&lt;a href=&quot;xxx&quot;</code> 等，要校验内容，禁止以 script 开头的非法链接。</li><li>限制输入长度</li></ul><h3 id="61-对称加密与非对称加密有什么区别？">61.对称加密与非对称加密有什么区别？</h3><p><strong>对称加密</strong>：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES 等。</p><p><img src="https://s2.loli.net/2023/04/01/sVI3Y6CqNjrvFl1.png" alt="对称加密"></p><p><strong>非对称加密</strong>：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。</p><p><img src="https://s2.loli.net/2023/04/01/h1im9NonXWGLEPb.png" alt="非对称加密"></p><h3 id="62-RSA-和-AES-算法有什么区别？">62.RSA 和 AES 算法有什么区别？</h3><ul><li><strong>RSA</strong></li></ul><p>采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，由于需要大数的乘幂求模等运算，其运算速度较慢，不合适大量数据文件加密。</p><ul><li><strong>AES</strong></li></ul><p>采用对称加密的方式，其秘钥长度最长只有 256 个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。</p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql篇(修正版)</title>
      <link href="/posts/70ea7d93.html"/>
      <url>/posts/70ea7d93.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="1-什么是内连接、外连接、交叉连接、笛卡尔积呢？">1. 什么是内连接、外连接、交叉连接、笛卡尔积呢？</h3><ul><li>内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。</li><li>外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。</li><li>交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在 SQL 中的实现，如果 A 表有 m 行，B 表有 n 行，那么 A 和 B 交叉连接的结果就有 m*n 行。</li><li>笛卡尔积：是数学中的一个概念，例如集合 A={a,b}，集合 B={1,2,3}，那么 A✖️B=<code>&#123;&lt;a,o&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,&#125;</code>。</li></ul><h3 id="2-那-MySQL-的内连接、左连接、右连接有有什么区别？">2. 那 MySQL 的内连接、左连接、右连接有有什么区别？</h3><p>MySQL 的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。</p><p><img src="https://s2.loli.net/2023/04/03/H3sjK8ngrpOeCam.png" alt=""></p><p>MySQL-joins-来源菜鸟教程</p><ul><li>inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul><h3 id="3-说一下数据库的三大范式？">3.说一下数据库的三大范式？</h3><p><img src="https://s2.loli.net/2023/03/31/LzSa2wfCon1lIyT.png" alt="数据库三范式"></p><ul><li>第一范式：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品 ID 和订单 ID 作为联合主键，才满足第二范式。</li><li>第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。</li></ul><p><img src="https://s2.loli.net/2023/03/31/yFj7TfoVex1r9i4.gif" alt="你设计遵守范式吗？"></p><p>三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p><h3 id="4-varchar-与-char-的区别？">4.varchar 与 char 的区别？</h3><p><img src="https://s2.loli.net/2023/03/31/EsBuYMUo6Pt835n.png" alt="varchar"></p><p><strong>char</strong>：</p><ul><li>char 表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比 varchar 快很多，甚至能快 50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li><li>对于 char 来说，最多能存放的字符个数为 255，和编码无关</li></ul><p><strong>varchar</strong>：</p><ul><li>varchar 表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar 在存取方面与 char 相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于 varchar 来说，最多能存放的字符个数为 65532</li></ul><p>日常的设计，对于长度相对固定的字符串，可以使用 char，对于长度不确定的，使用 varchar 更合适一些。</p><h3 id="5-blob-和-text-有什么区别？">5.blob 和 text 有什么区别？</h3><ul><li>blob 用于存储二进制数据，而 text 用于存储大字符串。</li><li>blob 没有字符集，text 有一个字符集，并且根据字符集的校对规则对值进行排序和比较</li></ul><h3 id="6-DATETIME-和-TIMESTAMP-的异同？">6.DATETIME 和 TIMESTAMP 的异同？</h3><p><strong>相同点</strong>：</p><ol><li>两个数据类型存储时间的表现格式一致。均为 <code>YYYY-MM-DD HH:MM:SS</code></li><li>两个数据类型都包含「日期」和「时间」部分。</li><li>两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）</li></ol><p><strong>区别</strong>：</p><p><img src="https://s2.loli.net/2023/04/03/GWPfnKyo3bZgHTh.png" alt="GWPfnKyo3bZgHTh.png"></p><p>DATETIME 和 TIMESTAMP 的区别</p><ol><li><strong>日期范围</strong>：DATETIME 的日期范围是 <code>1000-01-01 00:00:00.000000</code> 到 <code>9999-12-31 23:59:59.999999</code>；TIMESTAMP 的时间范围是<code>1970-01-01 00:00:01.000000</code> UTC到 <code>2038-01-09 03:14:07.999999</code> UTC</li><li><strong>存储空间</strong>：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节</li><li><strong>时区相关</strong>：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区</li><li><strong>默认值</strong>：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)</li></ol><h3 id="7-MySQL-中-in-和-exists-的区别？">7.MySQL 中 in 和 exists 的区别？</h3><p>MySQL 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。我们可能认为 exists 比 in 语句的效率要高，这种说法其实是不准确的，要区分情景：</p><ol><li>如果查询的两个表大小相当，那么用 in 和 exists 差别不大。</li><li>如果两个表中一个较小，一个是大表，则子查询表大的用 exists，子查询表小的用 in。</li><li>not in 和 not exists：如果查询语句使用了 not in，那么内外表都进行全表扫描，没有用到索引；而 not exists 的子查询依然能用到表上的索引。所以无论那个表大，用 not exists 都比 not in 要快。</li></ol><h3 id="8-MySQL-里记录货币用什么字段类型比较好？">8.MySQL 里记录货币用什么字段类型比较好？</h3><p>货币在数据库中 MySQL 常用 Decimal 和 Numric 类型表示，这两种类型被 MySQL 实现为同样的类型。他们被用于保存与货币有关的数据。</p><p>例如 salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代表将被用于存储小数点后的位数。存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。</p><p>DECIMAL 和 NUMERIC 值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。</p><p>之所以不使用 float 或者 double 的原因：因为 float 和 double 是以二进制存储的，所以有一定的误差。</p><h3 id="9-MySQL-怎么存储-emoji😊">9.MySQL 怎么存储 emoji😊?</h3><p>MySQL 可以直接使用字符串存储 emoji。</p><p>但是需要注意的，utf8 编码是不行的，MySQL 中的 utf8 是阉割版的 utf8，它最多只用 3 个字节存储字符，所以存储不了表情。那该怎么办？</p><p>需要使用 utf8mb4 编码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> blogs modify content text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="10-drop、delete-与-truncate-的区别？">10.drop、delete 与 truncate 的区别？</h3><p>三者都表示删除，但是三者有一些差别：</p><table><thead><tr><th>关键字</th><th>delete</th><th>truncate</th><th>drop</th></tr></thead><tbody><tr><td>类型</td><td>属于 DML</td><td>属于 DDL</td><td>属于 DDL</td></tr><tr><td>回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td>删除内容</td><td>表结构还在，删除表的全部或者一部分数据行</td><td>表结构还在，删除表中的所有数据</td><td>删除表结构和数据</td></tr><tr><td>删除速度</td><td>删除速度慢，需要逐行删除</td><td>删除速度快</td><td>删除速度最快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，用 drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用 truncate。</p><h3 id="11-UNION-与-UNION-ALL-的区别？">11.UNION 与 UNION ALL 的区别？</h3><ul><li>如果使用 UNION，会在表链接后筛选掉重复的记录行</li><li>如果使用 UNION ALL，不会合并重复的记录行</li><li>从效率上说，UNION ALL 要比 UNION 快很多，如果合并没有刻意要删除重复行，那么就使用 UNION All</li></ul><h3 id="12-count-1-、count-与-count-列名-的区别？">12.count(1)、count(*) 与 count(列名) 的区别？</h3><p><img src="https://s2.loli.net/2023/03/31/mB7V9euCQIdcoDG.png" alt="三种计数方式"></p><p><strong>执行效果</strong>：</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为 NULL</li><li>count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为 NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0，而是表示 null）的计数，即某个字段值为 NULL 时，不统计。</li></ul><p><strong>执行速度</strong>：</p><ul><li>列名为主键，count(列名)会比 count(1)快</li><li>列名不为主键，count(1)会比 count(列名)快</li><li>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count（*）最优。</li></ul><h3 id="13-一条-SQL-查询语句的执行顺序？">13.一条 SQL 查询语句的执行顺序？</h3><p><img src="https://s2.loli.net/2023/03/31/lJkHcIDhZQTyfvM.png" alt="查询语句执行顺序"></p><ol><li><strong>FROM</strong>：对 FROM 子句中的左表&lt;left_table&gt;和右表&lt;right_table&gt;执行笛卡儿积（Cartesianproduct），产生虚拟表 VT1</li><li><strong>ON</strong>：对虚拟表 VT1 应用 ON 筛选，只有那些符合&lt;join_condition&gt;的行才被插入虚拟表 VT2 中</li><li><strong>JOIN</strong>：如果指定了 OUTER JOIN（如 LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表 VT2 中，产生虚拟表 VT3。如果 FROM 子句包含两个以上表，则对上一个连接生成的结果表 VT3 和下一个表重复执行步骤 1）～步骤 3），直到处理完所有的表为止</li><li><strong>WHERE</strong>：对虚拟表 VT3 应用 WHERE 过滤条件，只有符合&lt;where_condition&gt;的记录才被插入虚拟表 VT4 中</li><li><strong>GROUP BY</strong>：根据 GROUP BY 子句中的列，对 VT4 中的记录进行分组操作，产生 VT5</li><li><strong>CUBE|ROLLUP</strong>：对表 VT5 进行 CUBE 或 ROLLUP 操作，产生表 VT6</li><li><strong>HAVING</strong>：对虚拟表 VT6 应用 HAVING 过滤器，只有符合&lt;having_condition&gt;的记录才被插入虚拟表 VT7 中。</li><li><strong>SELECT</strong>：第二次执行 SELECT 操作，选择指定的列，插入到虚拟表 VT8 中</li><li><strong>DISTINCT</strong>：去除重复数据，产生虚拟表 VT9</li><li><strong>ORDER BY</strong>：将虚拟表 VT9 中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表 VT10。11）</li><li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表 VT11，并返回给查询用户</li></ol><h2 id="数据库架构">数据库架构</h2><h3 id="14-说说-MySQL-的基础架构">14.说说 MySQL 的基础架构?</h3><p><img src="https://s2.loli.net/2023/04/01/OR7iwLknJUKM8bV.png" alt=""></p><p>MySQL 逻辑架构图主要分三层：</p><ul><li>客户端：最上层的服务并不是 MySQL 所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</li><li>Server 层：大多数 MySQL 的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</li><li>存储引擎层：第三层包含了存储引擎。存储引擎负责 MySQL 中数据的存储和提取。Server 层通过 API 与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。</li></ul><h3 id="15-一条-SQL-查询语句在-MySQL-中如何执行的？">15.一条 SQL 查询语句在 MySQL 中如何执行的？</h3><ul><li>先检查该语句<code>是否有权限</code>，如果没有权限，直接返回错误信息，如果有权限会先查询缓存 (MySQL8.0 版本以前)。</li><li>如果没有缓存，分析器进行<code>语法分析</code>，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。</li><li>语法解析之后，MySQL 的服务器会对查询的语句进行优化，确定执行的方案。</li><li>完成查询优化后，按照生成的执行计划<code>调用数据库引擎接口</code>，返回执行结果。</li></ul><h2 id="存储引擎">存储引擎</h2><h3 id="16-MySQL-有哪些常见存储引擎？">16.MySQL 有哪些常见存储引擎？</h3><p><img src="https://s2.loli.net/2023/03/31/nResuIxyTQU14Jh.png" alt="主要存储引擎"></p><p>主要存储引擎以及功能如下：</p><table><thead><tr><th>功能</th><th>MylSAM</th><th>MEMORY</th><th>InnoDB</th></tr></thead><tbody><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td></tr><tr><td>支持事务</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>支持全文索引</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>支持树索引</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>支持哈希索引</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>支持数据缓存</td><td>No</td><td>N/A</td><td>Yes</td></tr><tr><td>支持外键</td><td>No</td><td>No</td><td>Yes</td></tr></tbody></table><p>MySQL5.5 之前，默认存储引擎是 MylSAM，5.5 之后变成了 InnoDB。</p><blockquote><p>InnoDB 支持的哈希索引是自适应的，InnoDB 会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p></blockquote><blockquote><p>MySQL 5.6 开始 InnoDB 支持全文索引。</p></blockquote><h3 id="17-那存储引擎应该怎么选择？">17.那存储引擎应该怎么选择？</h3><p>大致上可以这么选择：</p><ul><li>大多数情况下，使用默认的 InnoDB 就够了。如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。</li><li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li><li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li></ul><p>使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</p><h3 id="18-InnoDB-和-MylSAM-主要有什么区别？">18.InnoDB 和 MylSAM 主要有什么区别？</h3><p>PS:MySQL8.0 都开始慢慢流行了，如果不是面试，MylSAM 其实可以不用怎么了解。</p><div class="tabs" id="myisam和innodb的区别答案"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#myisam和innodb的区别答案-1"><i class="fa fa-leaf"></i>答案1</button></li><li class="tab active"><button type="button" data-href="#myisam和innodb的区别答案-2"><i class="fa-regular fa-thumbs-up"></i>答案2</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="myisam和innodb的区别答案-1"><p><img src="https://s2.loli.net/2023/03/31/mOAUMh3wuZyx4SN.png" alt="InnoDB 和 MylSAM 主要有什么区别"></p><p><strong>1. 存储结构</strong>：每个 MyISAM 在磁盘上存储成三个文件；InnoDB 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB。</p><p><strong>2. 事务支持</strong>：MyISAM 不提供事务支持；InnoDB 提供事务支持事务，具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全特性。</p><p><strong>3.最小锁粒度</strong>：MyISAM 只支持表级锁，更新时会锁住整张表，导致其它查询和更新都会被阻塞 InnoDB 支持行级锁。</p><p><strong>4. 索引类型</strong>：MyISAM 的索引为非聚簇索引，数据结构是 B 树；InnoDB 的索引是聚簇索引，数据结构是 B+树。</p><p><strong>5. 主键必需</strong>：MyISAM 允许没有任何索引和主键的表存在；InnoDB 如果没有设定主键或者非空唯一索引，<strong>就会自动生成一个6字节的主键(用户不可见)</strong> ，数据是主索引的一部分，附加索引保存的是主索引的值。</p><p><strong>6. 表的具体行数</strong>：MyISAM 保存了表的总行数，如果 select count(*) from table;会直接取出出该值; InnoDB 没有保存表的总行数，如果使用 select count(*) from table；就会遍历整个表;但是在加了 where 条件后，MyISAM 和 InnoDB 处理的方式都一样。</p><p><strong>7.   外键支持</strong>：MyISAM 不支持外键；InnoDB 支持外键。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="myisam和innodb的区别答案-2"><div>    <style>        table th, table td {            padding: 6px 12px;            border: 1px solid var(--light-grey);            vertical-align: middle;            width: 30px        }    </style><table><thead><tr><th style="text-align:left">存储引擎</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td style="text-align:left">存储结构</td><td>在磁盘上存储成<code>三个文件</code>，MYD文件（数据）、MYI文件（索引）和frm文件（表结构）</td><td>只有一个数据文件，本身就是索引</td></tr><tr><td style="text-align:left">事务支持</td><td>不支持</td><td>支持 <code>ACID</code> 事务</td></tr><tr><td style="text-align:left">索引类型</td><td><code>非聚簇索引</code>，数据结构为<code>B树</code>，只支持表级索引</td><td><code>聚簇索引</code>，数据结构为<code>B+树</code>，支持行级索引</td></tr><tr><td style="text-align:left">并发控制</td><td>表级锁，所以在高并发读写情况下会出现较大的性能瓶颈</td><td>采用行级锁，可以更好地处理并发访问</td></tr><tr><td style="text-align:left">外键约束</td><td>不支持</td><td>支持</td></tr><tr><td style="text-align:left">可靠性</td><td>不提供强制性的数据完整性检查机制</td><td>具有严格的数据完整性检查机制</td></tr><tr><td style="text-align:left">全文检索</td><td>支持</td><td>只支持线性搜索</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="日志">日志</h2><h3 id="19-MySQL-日志文件有哪些？分别介绍下作用？">19.MySQL 日志文件有哪些？分别介绍下作用？</h3><p><img src="https://s2.loli.net/2023/03/31/9uQmSGk2psLiWy8.png" alt="MySQL 主要日志"></p><p>MySQL 日志文件有很多，包括 ：</p><ul><li><strong>错误日志</strong>（error log）：错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录，能帮助定位 MySQL 问题。</li><li><strong>慢查询日志</strong>（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。</li><li><strong>一般查询日志</strong>（general log）：一般查询日志记录了所有对 MySQL 数据库请求的信息，无论请求是否正确执行。</li><li><strong>二进制日志</strong>（bin log）：关于二进制日志，它记录了数据库所有执行的 DDL 和 DML 语句（除了数据查询语句 select、show 等），以事件形式记录并保存在二进制文件中。</li></ul><p>还有两个 InnoDB 存储引擎特有的日志文件：</p><ul><li><strong>重做日志</strong>（redo log）：重做日志至关重要，因为它们记录了对于 InnoDB 存储引擎的事务日志。</li><li><strong>回滚日志</strong>（undo log）：回滚日志同样也是 InnoDB 引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB 引擎不仅会记录 redo log，还会生成对应的 undo log 日志；如果事务执行失败或调用了 rollback，导致事务需要回滚，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。</li></ul><h3 id="20-binlog-和-redo-log-有什么区别？">20.binlog 和 redo log 有什么区别？</h3><ul><li>bin log 会记录所有与数据库有关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志，而 redo log 只记 InnoDB 存储引擎的日志。</li><li>记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。</li><li>写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。</li><li>写入的方式也不相同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写的文件。</li></ul><h3 id="21-一条更新语句怎么执行的了解吗？">21.一条更新语句怎么执行的了解吗？</h3><p>更新语句的执行是 Server 层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。</p><p><img src="https://s2.loli.net/2023/03/31/lc13AkSb5DzVqxC.png" alt="update 执行"></p><ol><li>执行器先找引擎获取 ID=2 这一行。ID 是主键，存储引擎检索数据，找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p>从上图可以看出，MySQL 在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对 binlog 进行写入，在 InnoDB 内进行 redo log 的写入。</p><p>不仅如此，在对 redo log 写入时有两个阶段的提交，一是 binlog 写入之前<code>prepare</code>状态的写入，二是 binlog 写入之后<code>commit</code>状态的写入。</p><h3 id="22-那为什么要两阶段提交呢？">22.那为什么要两阶段提交呢？</h3><p>为什么要两阶段提交呢？直接提交不行吗？</p><p>我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入 redo log，后写入 binlog；要么先写入 binlog，后写入 redo log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。</p><p><strong>先写入 redo log，后写入 binlog：</strong></p><p>在写完 redo log 之后，数据此时具有<code>crash-safe</code>能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在 redo log 写完时候，binlog 写入之前，系统发生了宕机。此时 binlog 没有对上面的更新语句进行保存，导致当使用 binlog 进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得<code>id=2</code>这一行的数据没有被更新。</p><p><img src="https://s2.loli.net/2023/03/31/J9pLj24Y8eywm1K.png" alt="先写 redo log，后写 bin log 的问题"></p><p><strong>先写入 binlog，后写入 redo log：</strong></p><p>写完 binlog 之后，所有的语句都被保存，所以通过 binlog 复制或恢复出来的数据库中 id=2 这一行的数据会被更新为 a=1。但是如果在 redo log 写入之前，系统崩溃，那么 redo log 中记录的这个事务会无效，导致实际数据库中<code>id=2</code>这一行的数据并没有更新。</p><p><img src="https://s2.loli.net/2023/03/31/tkMgsC8xKforP5L.png" alt="先写 bin log，后写 redo log 的问题"></p><p>简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h3 id="23-redo-log-怎么刷入磁盘的知道吗？">23.redo log 怎么刷入磁盘的知道吗？</h3><p>redo log 的写入不是直接落到磁盘，而是在内存中设置了一片称之为<code>redo log buffer</code>的连续内存空间，也就是<code>redo 日志缓冲区</code>。</p><p><img src="https://s2.loli.net/2023/03/31/VlC9FUeEIQcSims.png" alt="redo log 缓冲"></p><blockquote><p><strong>什么时候会刷入磁盘？</strong></p></blockquote><p>在如下的一些情况中，log buffer 的数据会刷入磁盘：</p><ul><li><p>log buffer 空间不足时</p><blockquote><p>log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。如果当前写入 log buffer 的 redo 日志量已经占满了 log buffer 总容量的大约<strong>一半</strong>左右，就需要把这些日志刷新到磁盘上。</p></blockquote></li><li><p>事务提交时</p><blockquote><p>在事务提交时，为了保证持久性，会把 log buffer 中的日志全部刷到磁盘。注意，这时候，除了本事务的，可能还会刷入其它事务的日志。</p></blockquote></li><li><p>后台线程输入</p><blockquote><p>有一个后台线程，大约每秒都会刷新一次<code>log buffer</code>中的<code>redo log</code>到磁盘。</p></blockquote></li><li><p>正常关闭服务器时</p></li><li><p><strong>触发 checkpoint 规则</strong></p><p>重做日志缓存、重做日志文件都是以<strong>块（block）<strong>的方式进行保存的，称之为</strong>重做日志块（redo log block）</strong>,块的大小是固定的 512 字节。我们的 redo log 它是固定大小的，可以看作是一个逻辑上的 <strong>log group</strong>，由一定数量的<strong>log block</strong> 组成。</p><p><img src="https://s2.loli.net/2023/03/31/ANlrUkIFL9RgBEC.png" alt="redo log 分块和写入"></p><p>它的写入方式是从头到尾开始写，写到末尾又回到开头循环写。</p><p>其中有两个标记位置：</p><p><code>write pos</code>是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。<code>checkpoint</code>是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘。</p><p><img src="https://s2.loli.net/2023/03/31/MuadWspirh28fo4.png" alt="write pos 和 checkpoint"></p><p>当<code>write_pos</code>追上<code>checkpoint</code>时，表示 redo log 日志已经写满。这时候就不能接着往里写数据了，需要执行<code>checkpoint</code>规则腾出可写空间。</p><p>所谓的<strong>checkpoint 规则</strong>，就是 checkpoint 触发后，将 buffer 中日志页都刷到磁盘。</p></li></ul><h2 id="SQL-优化">SQL 优化</h2><h3 id="24-慢-SQL-如何定位呢？">24.慢 SQL 如何定位呢？</h3><p>慢 SQL 的监控主要通过两个途径：</p><p><img src="https://s2.loli.net/2023/03/31/duzXJtAy6i5raw1.png" alt="发现慢 SQL"></p><ul><li><strong>慢查询日志</strong>：开启 MySQL 的慢查询日志，再通过一些工具比如 mysqldumpslow 去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。</li><li><strong>服务监控</strong>：可以在业务的基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架过程，对服务运行中的慢 SQL 进行监控和告警。</li></ul><h3 id="25-有哪些方式优化慢-SQL？">25.有哪些方式优化慢 SQL？</h3><p>慢 SQL 的优化，主要从两个方面考虑，SQL 语句本身的优化，以及数据库设计的优化。</p><p><img src="https://s2.loli.net/2023/03/31/7VmApMyjSYsw9Rl.png" alt="SQL 优化"></p><h4 id="避免不必要的列">避免不必要的列</h4><p>这个是老生常谈，但还是经常会出的情况，SQL 查询的时候，应该只查询需要的列，而不要包含额外的列，像<code>slect *</code> 这种写法应该尽量避免。</p><h4 id="分页优化">分页优化</h4><p>在数据量比较大，分页比较深的情况下，需要考虑分页的优化。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> level <span class="operator">=</span> <span class="number">9</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">190289</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>优化方案：</p><ul><li><p><strong>延迟关联</strong></p><p>先通过 where 条件提取出主键，在将该表与原数据表关联，通过主键 id 提取数据行，而不是通过原来的二级索引提取数据行</p><p>例如：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> a, </span><br><span class="line"> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> level <span class="operator">=</span> <span class="number">9</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">190289</span>,<span class="number">10</span> ) b</span><br><span class="line"> <span class="keyword">where</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure></li><li><p><strong>书签方式</strong></p><p>书签方式就是找到 limit 第一个参数对应的主键值，根据这个主键值再去过滤并 limit</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> type <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> level <span class="operator">=</span> <span class="number">9</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">asc</span> limit <span class="number">190289</span>,<span class="number">1</span>) limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="索引优化">索引优化</h4><p>合理地设计和使用索引，是优化慢 SQL 的利器。</p><p><strong>利用覆盖索引</strong></p><p>InnoDB 使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p><p>例如对于如下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> test <span class="keyword">where</span> city<span class="operator">=</span><span class="string">&#x27;上海&#x27;</span></span><br></pre></td></tr></table></figure><p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> index idx_city_name (city, name);</span><br></pre></td></tr></table></figure><p><strong>低版本避免使用 or 查询</strong></p><p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p><p><strong>避免使用 != 或者 &lt;&gt; 操作符</strong></p><p>SQL 中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引</p><p>解决方法：通过把不等于操作符改成 or，可以使用索引，避免全表扫描</p><p>例如，把<code>column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’</code>，就可以使用索引了</p><p><strong>适当使用前缀索引</strong></p><p>适当地使用前缀索引，可以降低索引的空间占用，提高索引的查询效率。</p><p>比如，邮箱的后缀都是固定的“<code>@xxx.com</code>”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> index index2(email(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>PS:需要注意的是，前缀索引也存在缺点，MySQL 无法利用前缀索引做 order by 和 group by 操作，也无法作为覆盖索引</p><p><strong>避免列上函数运算</strong></p><p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> <span class="keyword">month</span>(updateTime) <span class="operator">=</span> <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><strong>正确使用联合索引</strong></p><p>使用联合索引的时候，注意最左匹配原则。</p><h4 id="JOIN-优化">JOIN 优化</h4><ul><li><p><strong>优化子查询</strong></p><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p></li><li><p><strong>小表驱动大表</strong></p><p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL 内部会遍历驱动表，再去连接被驱动表。</p><p>比如 left join，左表就是驱动表，A 表小于 B 表，建立连接的次数就少，查询速度就被加快了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B;</span><br></pre></td></tr></table></figure></li><li><p><strong>适当增加冗余字段</strong></p><p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p></li><li><p><strong>避免使用 JOIN 关联太多的表</strong></p><p>《阿里巴巴 Java 开发手册》规定不要 join 超过三张表，第一 join 太多降低查询的速度，第二 join 的 buffer 会占用更多的内存。</p><p>如果不可避免要 join 多张表，可以考虑使用数据异构的方式异构到 ES 中查询。</p></li></ul><h4 id="排序优化">排序优化</h4><p><strong>利用索引扫描做排序</strong></p><p>MySQL 有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p><p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机 IO，通常会比顺序全表扫描还慢</p><p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建立索引（date,staff_id,customer_id）</span></span><br><span class="line"><span class="keyword">select</span> staff_id, customer_id <span class="keyword">from</span> test <span class="keyword">where</span> <span class="type">date</span> <span class="operator">=</span> <span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> staff_id,customer_id;</span><br></pre></td></tr></table></figure><p>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p><h4 id="UNION-优化">UNION 优化</h4><p><strong>条件下推</strong></p><p>MySQL 处理 union 的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在 union 查询中都会失效，因为它无法利用索引</p><p>最好手工将 where、limit 等子句下推到 union 的各个子查询中，以便优化器可以充分利用这些条件进行优化</p><p>此外，除非确实需要服务器去重，一定要使用 union all，如果不加 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表做唯一性检查，代价很高。</p><h3 id="26-怎么看执行计划（explain），如何理解其中各个字段的含义？">26.怎么看执行计划（explain），如何理解其中各个字段的含义？</h3><p>explain 是 sql 优化的利器，除了优化慢 sql，平时的 sql 编写，也应该先 explain，查看一下执行计划，看看是否还有优化的空间。</p><p>直接在 select 语句之前增加<code>explain</code> 关键字，就会返回执行计划的信息。</p><p><img src="https://s2.loli.net/2023/04/01/8hRrwi9LEMl7YWu.png" alt=""></p><ol><li><strong>id</strong> 列：MySQL 会为每个 select 语句分配一个唯一的 id 值</li><li><strong>select_type</strong> 列，查询的类型，根据关联、union、子查询等等分类，常见的查询类型有 SIMPLE、PRIMARY。</li><li><strong>table</strong> 列：表示 explain 的一行正在访问哪个表。</li><li><strong>type</strong> 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。</li></ol><p>性能从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ul><li><p><code>system</code>：当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘 IO，速度非常快</p></li><li><p><code>const</code>：表示查询时命中 <code>primary key</code> 主键或者 <code>unique</code> 唯一索引，或者被连接的部分是一个常量(<code>const</code>)值。这类扫描效率极高，返回数据量少，速度非常快。</p></li><li><p><code>eq_ref</code>：查询时命中主键<code>primary key</code> 或者 <code>unique key</code>索引， <code>type</code> 就是 <code>eq_ref</code>。</p></li><li><p><code>ref_or_null</code>：这种连接类型类似于 ref，区别在于 <code>MySQL</code>会额外搜索包含<code>NULL</code>值的行。</p></li><li><p><code>index_merge</code>：使用了索引合并优化方法，查询使用了两个以上的索引。</p></li><li><p><code>unique_subquery</code>：替换下面的 <code>IN</code>子查询，子查询返回不重复的集合。</p></li><li><p><code>index_subquery</code>：区别于<code>unique_subquery</code>，用于非唯一索引，可以返回重复值。</p></li><li><p><code>range</code>：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在<code>where</code>语句中使用 <code>bettween...and</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>in</code> 等条件查询 <code>type</code> 都是 <code>range</code>。</p></li><li><p><code>index</code>：<code>Index</code> 与<code>ALL</code> 其实都是读全表，区别在于<code>index</code>是遍历索引树读取，而<code>ALL</code>是从硬盘中读取。</p></li><li><p>ALL就不用多说了，全表扫描。</p></li></ul><ol start="5"><li><p><strong>possible_keys</strong> 列：显示查询可能使用哪些索引来查找，使用索引优化 sql 的时候比较重要。</p></li><li><p><strong>key</strong> 列：这一列显示 MySql实际采用哪个索引来优化对该表的访问，判断索引是否失效的时候常用。</p></li><li><p><strong>key_len</strong> 列：MySql使用的索引的长度。该值越小越好</p></li><li><p><strong>ref</strong> 列：ref 列展示的就是与索引列作等值匹配的值，常见的有：const（常量），func，NULL，字段名。</p></li><li><p><strong>rows</strong> 列：这也是一个重要的字段，MySQL 查询优化器根据统计信息，估算 SQL 要查到结果集需要扫描读取的数据行数，这个值非常直观显示 SQL 的效率好坏，原则上 rows 越少越好。</p></li><li><p><strong>Extra</strong> 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：</p></li></ol><ul><li>Using index：表示 MySQL 将使用覆盖索引，以避免回表</li><li>Using where：表示会在存储引擎检索之后再进行过滤</li><li>Using temporary ：表示对查询结果排序时会使用一个临时表。</li></ul><ol start="11"><li><strong>filtered</strong>列：表示返回的结果的行数占需要读取行数的百分比，越大越好</li></ol><h2 id="索引">索引</h2><p>索引可以说是 MySQL 面试中的重中之重，一定要彻底拿下。</p><h3 id="27-能简单说一下索引的分类吗？">27.能简单说一下索引的分类吗？</h3><p>从三个不同维度对索引分类：</p><p><img src="https://s2.loli.net/2023/03/31/q5xmctdp4PzhGLy.png" alt="索引分类"></p><p>例如从基本使用使用的角度来讲：</p><ul><li>主键索引: InnoDB 主键是默认的索引，数据列不允许重复，不允许为 NULL，一个表只能有一个主键。</li><li>唯一索引: 数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值。</li><li>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</li></ul><h3 id="28-为什么使用索引会加快查询？">28.为什么使用索引会加快查询？</h3><p>没加索引的查询是按表的顺序遍历找数据，加了索引可以快速定位数据，减少读取次数。</p><ul><li><p><strong>减少数据的读取量</strong>：索引存储了列值与对应行的物理位置的映射关系。通过使用索引，数据库引擎可以直接定位到包含所需数据的物理位置，而不需要扫描全部数据。这样可以大大减少磁盘IO操作的次数，从而提高查询性能。</p></li><li><p><strong>快速定位数据</strong>：索引按照特定的数据结构（例如B树或哈希表）组织数据，具有快速查找的特性。数据库引擎可以利用这些数据结构进行快速的二分查找、哈希查找等操作，从而在数据量较大的情况下也能够快速定位到所需数据。</p></li><li><p><strong>避免全表扫描</strong>：没有索引的情况下，数据库引擎需要对整个表进行全表扫描来满足查询条件。而使用索引后，数据库引擎可以根据索引中的信息快速缩小范围，只针对满足条件的索引项进行数据检索，从而避免了全表扫描的开销。</p></li></ul><h3 id="29-创建索引有哪些注意点？">29.创建索引有哪些注意点？</h3><p>索引虽然是 sql 性能优化的利器，但是索引的维护也是需要成本的，所以创建索引，也要注意：</p><ol><li><p>索引应该建在查询应用频繁的字段</p><blockquote><p>在用于 where 判断、 order 排序和 join 的(on)字段上创建索引。</p></blockquote></li><li><p>索引的个数应该适量</p><blockquote><p>索引需要占用空间；更新时候也需要维护。</p></blockquote></li><li><p>区分度低的字段，例如性别，不要建索引。</p><blockquote><p>离散度太低的字段，扫描的行数降低的有限。</p></blockquote></li><li><p>频繁更新的值，不要作为主键或者索引</p><blockquote><p>维护索引文件需要成本；还会导致页分裂，IO 次数增多。</p></blockquote></li><li><p>组合索引把散列性高(区分度高)的值放在前面</p><blockquote><p>为了满足最左前缀匹配原则</p></blockquote></li><li><p>创建组合索引，而不是修改单列索引。</p><blockquote><p>组合索引代替多个单列索引（对于单列索引，MySQL 基本只能使用一个索引，所以经常使用多个条件查询时更适合使用组合索引）</p></blockquote></li><li><p>过长的字段，使用前缀索引。</p><blockquote><p>当字段值比较长的时候，建立索引会消耗很多的空间，搜索起来也会很慢。我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。</p></blockquote></li><li><p>不建议用无序的值(例如身份证、UUID )作为索引</p><blockquote><p>当主键具有不确定性，会造成叶子节点频繁分裂，出现磁盘存储的碎片化</p></blockquote></li></ol><h3 id="30-索引哪些情况下会失效呢？">30.索引哪些情况下会失效呢？</h3><ul><li>查询条件包含 or，可能导致索引失效（低版本的MySql）</li><li>如果字段类型是字符串，where 时一定用引号括起来，否则会因为隐式类型转换，索引失效</li><li>like 通配符可能导致索引失效，如<code>name like '%张三%'</code>。</li><li>联合索引不符合<code>最左匹配原则</code>，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用 mysql 的内置函数，索引失效。</li><li>对索引列运算（如，+、-、*、/），索引失效。</li><li>索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li><li>索引字段上使用 is null， is not null，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>MySQL 优化器估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><h3 id="31-索引不适合哪些场景呢？">31.索引不适合哪些场景呢？</h3><ul><li>数据量比较少的表不适合加索引</li><li>更新比较频繁的字段也不适合加索引</li><li>离散低的字段不适合加索引（如性别）</li></ul><h3 id="32-索引是不是建的越多越好呢？">32.索引是不是建的越多越好呢？</h3><p>当然不是。</p><ul><li><strong>索引会占据磁盘空间</strong></li><li><strong>索引虽然会提高查询效率，但是会降低更新表的效率</strong>。比如每次对表进行增删改操作，MySQL 不仅要保存数据，还有保存或者更新对应的索引文件。</li></ul><h3 id="33-MySQL-索引用的什么数据结构了解吗？">33.MySQL 索引用的什么数据结构了解吗？</h3><p>MySQL 的默认存储引擎是 InnoDB，它采用的是 B+树结构的索引。</p><ul><li>B+树：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。</li></ul><p><img src="https://s2.loli.net/2023/03/31/rdVJI5Y78kgjDta.png" alt="B+树索引"></p><p>在这张图里，有两个重点：</p><ul><li>最外面的方块，的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（粉色所示）和指针（黄色/灰色所示），如根节点磁盘包含数据项 17 和 35，包含指针 P1、P2、P3，P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。真实的数据存在于叶子节点即 3、4、5……、65。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。</li><li>叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表，可以进行范围查询。</li></ul><h3 id="34-那一棵-B-树能存储多少条数据呢？">34.那一棵 B+树能存储多少条数据呢？</h3><p><img src="https://s2.loli.net/2023/03/31/tXhxNoeVBsM5GJE.png" alt="B+树存储数据条数"></p><p>假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。非叶子节点(一页)可以存储 16384/14=1170 个这样的 单元(键值+指针)，代表有 1170 个指针。</p><p>树深度为 2 的时候，有 1170^2 个叶子节点，可以存储的数据为 1170*1170*16=<strong>21902400</strong>。</p><p>在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询数据最多需要访问 3 次磁盘。</p><p>所以在 InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。</p><h3 id="35-为什么要用-B-树，而不用普通二叉树？">35.为什么要用 B+ 树，而不用普通二叉树？</h3><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数。</p><div class="note orange icon-padding modern"><i class="note-icon fa-solid fa-circle-question"></i><p><strong>为什么不用普通二叉树？</strong></p></div><p>在关系型数据库中，为了提高读取数据的效率，通常需要在表上建立索引。而索引的实现和数据结构密切相关，常用的索引结构之一就是 B+ 树。</p><p>相比于普通的二叉树，B+ 树具有以下几个优点：</p><ol><li><p><strong>磁盘 IO 次数更少</strong>：B+ 树的节点大小通常等于一页的大小，而磁盘是按页（通常是4KB或8KB）单位读写的。因此，B+ 树可以最大程度地利用磁盘的顺序读写特性，减少磁盘 IO 次数。</p></li><li><p><strong>内存使用效率更高</strong>：对于 n 个节点的 B+ 树，其高度通常为 log(n)，因此占用内存的节点数相对于其他树结构要小得多。而普通的二叉树在极端情况下可能会退化成链表，导致占用内存的节点数达到 n，不利于节约内存。</p></li><li><p><strong>范围查询效率更高</strong>：B+ 树的叶子节点都是按顺序排列的，因此扫描某个范围内的数据只需要在 B+ 树上进行一次顺序遍历即可，而不需要像普通二叉树那样需要对每个节点都进行判断。</p></li><li><p><strong>支持更高的并发度</strong>：由于 B+ 树的节点是按页存储的，因此多个线程可以同时读取同一个页面，从而提高了并发度。而普通的二叉树则需要锁定整棵树或者某个节点，对并发度的支持较差。</p></li></ol><p>综上所述，B+ 树作为一种高效的索引结构，可以大幅度减少磁盘 IO 次数，提高查询速度，并且内存使用效率更高，支持更高的并发度，因此被广泛应用于数据库和文件系统等领域。</p><div class="note orange icon-padding modern"><i class="note-icon fa-solid fa-circle-question"></i><p><strong>为什么不用平衡二叉树呢？</strong></p></div><p>平衡二叉树也是一种常见的搜索树结构，对于查询，其复杂度也是 O(log n)，所以为什么要用 B+ 树呢？原因如下：</p><ol><li><p><strong>磁盘 IO 次数</strong>：平衡二叉树通常是存储在内存中的，而当数据量过大时，需要使用硬盘等外部存储器进行读写。但是由于硬盘 IO 是非常慢的，所以为了减少磁盘 IO 次数，需要将多个节点合并为一个块，这就是 B+ 树的特点之一：可以将多个节点合并为一个块，从而减少磁盘 IO 操作次数，提高磁盘 IO 效率。</p></li><li><p><strong>存储容量</strong>：平衡二叉树中，每个节点不仅需要记录自身的信息，还需要记录左右子树的信息，因此整个树的存储空间要比 B+ 树大得多。</p></li><li><p><strong>数据范围查询</strong>：B+ 树的叶子节点都是按顺序排列的，因此扫描某个范围内的数据只需要在 B+ 树上进行一次顺序遍历即可，而平衡二叉树无法支持这样的操作。</p></li><li><p><strong>并发性</strong>：由于 B+ 树的数据分布在不同的块中，所以多个线程可以同时读取不同的块，提高了并发度。但是平衡二叉树由于每个节点都链接着其他节点，因此在多线程情况下读取可能会出现阻塞等问题，降低了系统的并发性。</p></li></ol><p>综上所述，B+ 树相比平衡二叉树具有更好的磁盘 IO 性能、更小的存储空间、更好的范围查询性能和更好的并发性，因此在大规模数据库的场景中，B+ 树是更为合适的选择。</p><h3 id="36-为什么用-B-树而不用-B-树呢？">36.为什么用 B+ 树而不用 B 树呢？</h3><p>B+相比较 B 树，有这些优势：</p><ul><li><p>它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。B Tree 解决的两大问题：每个节点存储更多关键字；路数更多</p></li><li><p>扫库、扫表能力更强。如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵 B+Tree 拿到所有的数据。</p></li><li><p>B+Tree 的磁盘读写能力相对于 B Tree 来说更强，IO 次数更少。根节点和枝节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多，IO 次数更少。</p></li><li><p>排序能力更强。因为叶子节点上有下一个数据区的指针，数据形成了链表。</p></li><li><p>效率更加稳定。B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的。</p></li></ul><h3 id="以下是为什么要用B-Tree的问题概括版">以下是为什么要用B+ Tree的问题概括版</h3><div class="note default modern"><p>Tree的数据结构：</p><ol><li><p><strong>二叉查找树</strong>：（Binary Search Tree）</p><img src="https://s2.loli.net/2023/04/17/ypdDJ1V5BTkIHxb.webp" alt="2845835-1fcd26c6adac6786.webp" style="zoom: 50%;" /><p>缺点：树的高度没有约束，导致查询效率时间复杂度较高O(n)。</p></li><li><p><strong>平衡二叉树（AVL树）</strong>：（Balance Binary Search Tree）</p><img src="https://s2.loli.net/2023/04/17/qWcsof8O5RjbKT3.webp" alt="2845835-4fa8592a60867bed.webp" style="zoom:50%;" /><p>缺点：改善了查询的复杂度问题（约束了左右子树相差高度不能大于1），但是树的高度==IO次数，即使左右子树拉平了，但是高度带来的IO问题依然无法接收，而且每块磁盘块（节点/页）太小，没有利用好IO数据交换特性。</p></li><li><p><strong>B Tree结构</strong>（多路平衡树）：</p><p><img src="https://s2.loli.net/2023/04/17/wHKze2aBvcIDRM6.jpg" alt="2845835-bbc3bc9f8455867e.webp"></p><blockquote><p>B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点，子节点的个数一般称为阶，<strong>上述图中的B树为3阶B树，高度也会很低</strong>。 基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p><p><strong>要点：</strong> 降低树的高度，增加路数</p></blockquote></li><li><p><strong>B+ Tree结构</strong>：</p><p><img src="https://s2.loli.net/2023/04/17/Bkpi9AcdLSb2O5Y.webp" alt="2845835-1914f82a8143f0ae.webp"></p><ul><li><p><strong>B+ Tree和B Tree的区别</strong></p><blockquote><ol><li>B+节点关键字搜索采用闭合区间。</li><li>B+非叶节点不保存数据相关信息，只保存关键字和子节点的引用，这样使得B+树每个非叶子节点所能保存的关键字大大增加。</li><li>B+关键字对应的数据保存在叶子节点中，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样。</li><li>B+叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系。</li></ol></blockquote></li><li><p><strong>B+ Tree的优势</strong></p><blockquote><ol><li>B+树是B-树的变种（PLUS版）多路绝对平衡查找树，他拥有B-树的优势。</li><li>B+树扫库、表能力更强。</li><li>B+树的磁盘读写能力更强。</li><li>B+树的排序能力更强。</li><li>B+树的查询效率更加稳定（仁者见仁、智者见智）。</li></ol></blockquote></li></ul></li></ol></div><div class="note danger flat"><p>一个有用的冷知识，用于提高你的B格：<a href="https://www.zhihu.com/question/478187330/answer/2050494617">mysql B+树中为什么同层的非叶子节点所在的页也使用双向链表连接?</a></p></div><h3 id="37-Hash-索引和-B-树索引区别是什么？">37.Hash 索引和 B+ 树索引区别是什么？</h3><ul><li>B+ 树可以进行范围查询，Hash 索引不能。</li><li>B+ 树支持联合索引的最左侧原则，Hash 索引不支持。</li><li>B+ 树支持 order by 排序，Hash 索引不支持。</li><li>Hash 索引在等值查询上比 B+ 树效率更高。</li><li>B+ 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</li></ul><blockquote><p>又来概括了</p><p>Hash索引是无序的，适合等值查询和随机访问数据，所有有序的操作都不支持。</p><p>B+ Tree是有序的，有序操作都支持，如排序和范围查找。</p></blockquote><h3 id="38-聚簇索引与非聚簇索引的区别？">38.聚簇索引与非聚簇索引的区别？</h3><p>首先理解聚簇索引不是一种新的索引，而是而是一种<strong>数据存储方式</strong>。聚簇表示数据行和相邻的键值紧凑地存储在一起。我们熟悉的两种存储引擎——MyISAM 采用的是非聚簇索引，InnoDB 采用的是聚簇索引。</p><p>可以这么说：</p><ul><li>索引的数据结构是树，聚簇索引的索引和数据存储在一棵树上，树的叶子节点就是数据，非聚簇索引索引和数据不在一棵树上。</li></ul><p><img src="https://s2.loli.net/2023/03/31/MSnFpXC5dxzjUZ1.png" alt="聚簇索引和非聚簇索引"></p><ul><li>一个表中只能拥有一个聚簇索引，而非聚簇索引一个表可以存在多个。</li><li>聚簇索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li><li>聚簇索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</li></ul><h3 id="39-回表了解吗？">39.回表了解吗？</h3><p>在 InnoDB 存储引擎里，利用辅助索引查询，先通过辅助索引找到主键索引的键值，再通过主键值查出主键索引里面没有符合要求的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。</p><p>例如:<code>select * from user where name = '张三';</code></p><p><img src="https://s2.loli.net/2023/03/31/MGNm7O2wQXcYLaE.png" alt="InnoDB 回表"></p><blockquote><p>简单的来说，就是一个表table(id, name, age,school)，索引 name，根据索引只能查到这行数据<code>id=1，name='张三'</code>，其他字段需要根据id查出来，等于扫描了name索引，又扫描主键索引</p></blockquote><h3 id="40-覆盖索引了解吗？">40.覆盖索引了解吗？</h3><p>在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。</p><p>比如，<code>select name from user where name = '张三';</code></p><p><img src="https://s2.loli.net/2023/03/31/EWjILanTrQoOe6K.png" alt="覆盖索引"></p><blockquote><p>简单的说就是要查询的列值，就是索引值。联合索引 (name, age)，<code>select name, age from user where name = '张三'</code>也成立，符合最左匹配原则。</p></blockquote><h3 id="41-什么是最左前缀原则-最左匹配原则？">41.什么是最左前缀原则/最左匹配原则？</h3><p>注意：最左前缀原则、最左匹配原则、最左前缀匹配原则这三个都是一个概念。</p><p><strong>最左匹配原则</strong>：在 InnoDB 的联合索引中，查询的时候只有匹配了前一个/左边的值之后，才能匹配下一个。</p><p>根据最左匹配原则，我们创建了一个组合索引，如 (a1,a2,a3)，相当于创建了（a1）、(a1,a2)和 (a1,a2,a3) 三个索引。</p><p>为什么不从最左开始查，就无法匹配呢？</p><p>比如有一个 user 表，我们给 name 和 age 建立了一个组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">add</span> INDEX comidx_name_phone (name,age);</span><br></pre></td></tr></table></figure><p>组合索引在 B+Tree 中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的 (name 在左边，age 在右边)。</p><p><img src="https://s2.loli.net/2023/03/31/WkjUBI7Du36TsCi.png" alt="组合索引"></p><p>从这张图可以看出来，name 是有序的，age 是无序的。当 name 相等的时候， age 才是有序的。</p><p>这个时候我们使用 <code>where name= ‘张三‘ and age = ‘20 ‘</code>去查询数据的时候， B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name 相同的时候再比较 age。但是如果查询条件没有 name，就不知道下一步应该查哪个 节点，因为建立搜索树的时候 name 是第一个比较因子，所以就没用上索引。</p><h3 id="42-什么是索引下推优化？">42.什么是索引下推优化？</h3><p>索引条件下推优化<code>（Index Condition Pushdown (ICP) ）</code>是 MySQL5.6 添加的，用于优化数据查询。</p><ul><li>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给 MySQL Server，MySQL Server 进行过滤条件的判断。</li><li>当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server 将这一部分判断条件<strong>下推</strong>给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL Server 传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。</li></ul><p>例如一张表，建了一个联合索引（name, age），查询语句：<code>select * from t_user where name like '张%' and age=10;</code>，由于<code>name</code>使用了范围查询，根据最左匹配原则：</p><p>不使用 ICP，引擎层查找到<code>name like '张%'</code>的数据，再由 Server 层去过滤<code>age=10</code>这个条件，这样一来，就回表了两次，浪费了联合索引的另外一个字段<code>age</code>。</p><p><img src="https://s2.loli.net/2023/03/31/cfeTHU5OzZ3ahdp.png" alt="没有使用 ICP"></p><p>但是，使用了索引下推优化，把 where 的条件放到了引擎层执行，直接根据<code>name like '张%' and age=10</code>的条件进行过滤，减少了回表的次数。</p><p><img src="https://s2.loli.net/2023/03/31/XuIABgLC6TQPtsK.png" alt="使用 ICP"></p><p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</p><h2 id="锁">锁</h2><h3 id="43-MySQL-中有哪几种锁，列举一下？">43.MySQL 中有哪几种锁，列举一下？</h3><p><img src="https://s2.loli.net/2023/03/31/OcrFJdT1yuz9Dfq.png" alt="MySQL 中的锁"></p><p>如果按锁粒度划分，有以下 3 种：</p><ul><li>表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</li><li>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li><li>页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><p>如果按照兼容性，有两种，</p><ul><li>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。</li><li>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</li></ul><h3 id="44-说说-InnoDB-里的行锁实现">44.说说 InnoDB 里的行锁实现?</h3><p>我们拿这么一个用户表来表示行级锁，其中插入了 4 行数据，主键值分别是 1,6,8,12，现在简化它的聚簇索引结构，只保留数据记录。</p><p><img src="https://s2.loli.net/2023/03/31/JB4I7wKNafvy18p.png" alt="简化的主键索引"></p><p>InnoDB 的行锁的主要实现如下：</p><ul><li><strong>Record Lock 记录锁</strong></li></ul><p>记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如<code>select * from t where id =6 for update;</code>就会将<code>id=6</code>的记录锁定。</p><p><img src="https://s2.loli.net/2023/03/31/D8E2YUvecwzKyiT.png" alt="记录锁"></p><ul><li><strong>Gap Lock 间隙锁</strong></li></ul><p>间隙锁(Gap Locks) 的间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个<strong>左开右开空间</strong>。</p><p><img src="https://s2.loli.net/2023/03/31/Za5jOwmJTl96ARY.png" alt="间隙锁"></p><p>间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个<code>record</code>，此时就会将对应的间隙区间锁定。例如<code>select * from t where id =3 for update;</code>或者<code>select * from t where id &gt; 1 and id &lt; 6 for update;</code>就会将(1,6)区间锁定。</p><ul><li><strong>Next-key Lock 临键锁</strong></li></ul><p>临键指的是间隙加上它右边的记录组成的<strong>左开右闭区间</strong>。比如上述的(1,6]、(6,8]等。</p><p><img src="https://s2.loli.net/2023/03/31/3cLCekuMsaomKfb.png" alt="临键锁"></p><p>临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分<code>record</code>记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个 record 的右边的临键区间。例如<code>select * from t where id &gt; 5 and id &lt;= 7 for update;</code>会锁住(4,7]、(7,+∞)。mysql 默认行锁类型就是<code>临键锁(Next-Key Locks)</code>。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。</p><blockquote><p><code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都是用来解决幻读问题的，在<code>已提交读（READ COMMITTED）</code>隔离级别下，<code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都会失效！</p></blockquote><p>上面是行锁的三种实现算法，除此之外，在行上还存在插入意向锁。</p><ul><li><strong>Insert Intention Lock 插入意向锁</strong></li></ul><p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap 锁 的那个事务提交。但是事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。这种类型的锁命名为 Insert Intention Locks ，也就是插入意向锁 。</p><p>假如我们有个 T1 事务，给(1,6)区间加上了意向锁，现在有个 T2 事务，要插入一个数据，id 为 4，它会获取一个（1,6）区间的插入意向锁，又有有个 T3 事务，想要插入一个数据，id 为 3，它也会获取一个（1,6）区间的插入意向锁，但是，这两个插入意向锁锁不会互斥。</p><p><img src="https://s2.loli.net/2023/03/31/7bN9wPAEVHrjzlG.png" alt="插入意向锁"></p><h3 id="45-意向锁是什么知道吗？">45.意向锁是什么知道吗？</h3><p>意向锁是一个表级锁，不要和插入意向锁搞混。</p><p>意向锁的出现是为了支持 InnoDB 的多粒度锁，它解决的是表锁和行锁共存的问题。</p><p>当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。</p><p>假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；</p><p>有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。</p><p>有了意向锁之后，要执行的事务 A 在申请行锁（写锁）之前，数据库会自动先给事务 A 申请表的意向排他锁。当事务 B 去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的互斥锁时会被阻塞。</p><p><img src="https://s2.loli.net/2023/03/31/y6eE3zKB4YZqv1I.png" alt="意向锁"></p><h3 id="46-MySQL-的乐观锁和悲观锁了解吗？">46.MySQL 的乐观锁和悲观锁了解吗？</h3><ul><li><strong>悲观锁</strong>（Pessimistic Concurrency Control）：</li></ul><p>悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p><p>数据库中的行锁，表锁，读锁，写锁均为悲观锁。</p><ul><li><strong>乐观锁（Optimistic Concurrency Control）</strong></li></ul><p>乐观锁认为数据的变动不会太频繁。</p><p>乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。</p><p>事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本 v1 与数据中最新的版本 v2 相对比，如果 v1=v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时 version 会加 1，以此来表明数据已被变动。</p><p>如果，v1 不等于 v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</p><h3 id="47-MySQL-遇到过死锁问题吗，你是如何解决的？">47.MySQL 遇到过死锁问题吗，你是如何解决的？</h3><p>排查死锁的一般步骤是这样的：</p><p>（1）查看死锁日志 show engine innodb status;</p><p>（2）找出死锁 sql</p><p>（3）分析 sql 加锁情况</p><p>（4）模拟死锁案发</p><p>（5）分析死锁日志</p><p>（6）分析死锁结果</p><p>当然，这只是一个简单的流程说明，实际上生产中的死锁千奇百怪，排查和解决起来没那么简单。</p><h2 id="事务">事务</h2><h3 id="48-MySQL-事务的四大特性说一下？">48.MySQL 事务的四大特性说一下？</h3><p><img src="https://s2.loli.net/2023/03/31/f3mWJtLRvHbSI7M.png" alt="事务四大特性"></p><ul><li><strong>原子性</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li><strong>一致性</strong>：指在事务开始之前和事务结束以后，数据不会被破坏，假如 A 账户给 B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。</li><li><strong>隔离性</strong>：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是井水不犯河水的。</li><li><strong>持久性</strong>：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h3 id="49-那-ACID-靠什么保证的呢？">49.那 ACID 靠什么保证的呢？</h3><ul><li>事务的<strong>隔离性</strong>是通过数据库锁的机制实现的。</li><li>事务的<strong>一致性</strong>由 undo log 来保证：undo log 是逻辑日志，记录了事务的 insert、update、deltete 操作，回滚的时候做相反的 delete、update、insert 操作来恢复数据。</li><li>事务的<strong>原子性</strong>和<strong>持久性</strong>由 redo log 来保证：redolog 被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入 redo log 持久化，到事务的提交操作才算完成。</li></ul><p><img src="https://s2.loli.net/2023/03/31/EkOLxybzdmFA2U4.png" alt="ACID 靠什么保证"></p><h3 id="50-事务的隔离级别有哪些？MySQL-的默认隔离级别是什么？">50.事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？</h3><p><img src="https://s2.loli.net/2023/04/01/CoAEbmcWTPxVire.png" alt=""></p><p>事务的四个隔离级别</p><ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行化（Serializable）</li></ul><p>MySQL 默认的事务隔离级别是可重复读 (Repeatable Read)。</p><h3 id="51-什么是幻读，脏读，不可重复读呢？">51.什么是幻读，脏读，不可重复读呢？</h3><ul><li>事务 A、B 交替执行，事务 A 读取到事务 B 未提交的数据，这就是<strong>脏读</strong>。</li><li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是<strong>不可重复读</strong>。</li><li>事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入 / 删除了数据，并静悄悄地提交，然后事务 A 再次查询相同的范围，两次读取得到的结果集不一样了，这就是<strong>幻读</strong>。</li></ul><p>不同的隔离级别，在并发事务下可能会发生的问题：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommited 读取未提交</td><td>是</td><td>是</td><td>是</td></tr><tr><td>Read Commited 读取已提交</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Repeatable Read 可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td>Serialzable 可串行化</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h3 id="52-事务的各个隔离级别都是如何实现的？">52.事务的各个隔离级别都是如何实现的？</h3><p><strong>读未提交</strong></p><p>读未提交，就不用多说了，采取的是读不加锁原理。</p><ul><li>事务读不加锁，不阻塞其他事务的读和写</li><li>事务写阻塞其他事务写，但不阻塞其他事务读；</li></ul><p><strong>读取已提交&amp;可重复读</strong></p><p>读取已提交和可重复读级别利用了<code>ReadView</code>和<code>MVCC</code>，也就是每个事务只能读取它能看到的版本（ReadView）。</p><ul><li>READ COMMITTED：每次读取数据前都生成一个 ReadView</li><li>REPEATABLE READ ：在第一次读取数据时生成一个 ReadView</li></ul><p><strong>串行化</strong></p><p>串行化的实现采用的是读写都加锁的原理。</p><p>串行化的情况下，对于同一行事务，<code>写</code>会加<code>写锁</code>，<code>读</code>会加<code>读锁</code>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><h3 id="53-MVCC-了解吗？怎么实现的？">53.MVCC 了解吗？怎么实现的？</h3><p>MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。关于它的实现，要抓住几个关键点，<strong>隐式字段、undo 日志、版本链、快照读&amp;当前读、Read View</strong>。</p><p><strong>版本链</strong></p><p>对于 InnoDB 存储引擎，每一行记录都有两个隐藏列<strong>DB_TRX_ID、DB_ROLL_PTR</strong></p><ul><li><code>DB_TRX_ID</code>，事务 ID，每次修改时，都会把该事务 ID 复制给<code>DB_TRX_ID</code>；</li><li><code>DB_ROLL_PTR</code>，回滚指针，指向回滚段的 undo 日志。</li></ul><p><img src="https://s2.loli.net/2023/03/31/lUIR4CVvJ9oBt2s.png" alt="表隐藏列"></p><p>假如有一张<code>user</code>表，表中只有一行记录，当时插入的事务 id 为 80。此时，该条记录的示例图如下：</p><p><img src="https://s2.loli.net/2023/04/01/OwtpkoUeTB59Ris.png" alt=""></p><p>接下来有两个<code>DB_TRX_ID</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>update</code>操作，整个过程如下：</p><p><img src="https://s2.loli.net/2023/03/31/mP7QbDIGf9oF6Lj.png" alt="update 操作"></p><p>由于每次变动都会先把<code>undo</code>日志记录下来，并用<code>DB_ROLL_PTR</code>指向<code>undo</code>日志地址。因此可以认为，<strong>对该条记录的修改日志串联起来就形成了一个<code>版本链</code>，版本链的头节点就是当前记录最新的值</strong>。如下：</p><p><img src="https://s2.loli.net/2023/03/31/fShlt6aqvpmOjAw.png" alt="MVCC"></p><p><strong>ReadView</strong></p><blockquote><p>对于<code>Read Committed</code>和<code>Repeatable Read</code>隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在<code>Read Committed</code>和<code>Repeatable Read</code>隔离级别下，版本链中哪个版本是能被当前事务读取的。于是就引入了<code>ReadView</code>这个概念来解决这个问题。</p></blockquote><p>Read View 就是事务执行<strong>快照读</strong>时，产生的读视图，相当于某时刻表记录的一个快照，通过这个快照，我们可以获取：</p><p><img src="https://s2.loli.net/2023/03/31/FHtazyXAT97VMbm.png" alt="事务和 ReadView"></p><ul><li>m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的事务 id 列表。</li><li>min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务 id ，也就是 m_ids 中的最小值。</li><li>max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。</li><li>creator_trx_id ：表示生成该 ReadView 的事务的 事务 id</li></ul><p>有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>如果被访问版本的 DB_TRX_ID 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 DB_TRX_ID 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 DB_TRX_ID 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的 DB_TRX_ID 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p><p>在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成 ReadView 的时机不同。</p><p>READ COMMITTED 是<strong>每次读取数据前都生成一个 ReadView</strong>，这样就能保证自己每次都能读到其它事务提交的数据；REPEATABLE READ 是在<strong>第一次读取数据时生成一个 ReadView</strong>，这样就能保证后续读取的结果完全一致。</p><h2 id="高可用-性能">高可用/性能</h2><h3 id="54-数据库读写分离了解吗？">54.数据库读写分离了解吗？</h3><p>读写分离的基本原理是将数据库读写操作分散到不同的节点上，下面是基本架构图：</p><p><img src="https://s2.loli.net/2023/03/31/SjA6Oo2TRLexti3.png" alt="读写分离"></p><p>读写分离的基本实现是:</p><ul><li>数据库服务器搭建主从集群，一主一从、一主多从都可以。</li><li>数据库主机负责读写操作，从机只负责读操作。</li><li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</li><li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机。</li></ul><h3 id="55-那读写分离的分配怎么实现呢？">55.那读写分离的分配怎么实现呢？</h3><p>将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。</p><ol><li>程序代码封装</li></ol><p>程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为 “中间层封装” ） ，实现读写操作分离和数据库服务器连接的管理。例如，基于 Hibernate 进行简单封装，就可以实现读写分离：</p><p><img src="https://s2.loli.net/2023/03/31/2pnlCSvNJ7zsfb9.png" alt="业务代码封装"></p><p>目前开源的实现方案中，淘宝的 TDDL (Taobao Distributed Data Layer, 外号：头都大了）是比较有名的。</p><ol start="2"><li>中间件封装</li></ol><p>中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。</p><p>对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。</p><p>其基本架构是：</p><p><img src="https://s2.loli.net/2023/03/31/lUMcw8dOpxhFPiA.png" alt="数据库中间件"></p><h3 id="56-主从复制原理了解吗？">56.主从复制原理了解吗？</h3><ul><li>master 数据写入，更新 binlog</li><li>master 创建一个 dump 线程向 slave 推送 binlog</li><li>slave 连接到 master 的时候，会创建一个 IO 线程接收 binlog，并记录到 relay log 中继日志中</li><li>slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行，完成同步</li><li>slave 记录自己的 binlog</li></ul><p><img src="https://s2.loli.net/2023/03/31/fFM7ZXmrODtcSWp.png" alt="主从复制"></p><div class="note info flat"><p><strong>拓展</strong>：<a href="https://blog.csdn.net/qq_45206551/article/details/105632284">主从同步的时候宕机了怎么办</a></p><ol><li><p><strong>主库宕机</strong>：使用 <code>show processlist</code> 确认同步最多数据的从库，将其设置为主库，修改其他从库同步新主库的数据。</p></li><li><p><strong>从库宕机</strong>：从库宕机不影响主库写入，查看错误日志确认 <strong>binlog</strong> 和 <strong>position</strong> 信息，使用 <code>CHANGE MASTER TO</code> 命令重新同步数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_LOG_FILE = &#x27;主库的binlog文件名&#x27;,</span><br><span class="line">MASTER_LOG_POS = 主库的binlog位置;</span><br></pre></td></tr></table></figure></li></ol></div><h3 id="57-主从同步延迟怎么处理？">57.主从同步延迟怎么处理？</h3><p><strong>主从同步延迟的原因</strong></p><ul><li>主从复制都是单线程操作，主库对所有DDL和DML产生binlog，binlog是顺序写，效率很高。从库的Slave_IO_Running 线程到主库取binlog，效率也很高。下一步从库的Slave_Sql_Running 将主库的 DDL和DML在从库上执行，DDL 和 DML 是随机写，成本很高，还有可能从库上其他查询产生的lock争用。由于Slave_Sql_Running是单线程的，所以一个DDL卡住了，需要10分钟，那么之后的DDL都需要等这个DDL执行完了才会执行，所以导致了主从延时。</li><li>还有一个原因：主库支持并发操作，从库的Slavr_Sql_Running 不可以</li></ul><p><strong>主从同步延迟的解决办法</strong></p><p>解决主从复制延迟有几种常见的方法:</p><ol><li>写操作后的读操作指定发给数据库主服务器</li></ol><p>例如，注册账号完成后，登录时读取账号的读操作也发给数据库主服务器。这种方式和业务强绑定，对业务的侵入和影响较大，如果哪个新来的程序员不知道这样写代码，就会导致一个 bug。</p><ol start="2"><li>读从机失败后再读一次主机</li></ol><p>这就是通常所说的 “二次读取” ，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。</p><ol start="3"><li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li></ol><p>例如，对于一个用户管理系统来说，注册 + 登录的业务读写操作全部访问主机，用户的介绍、爰好、等级等业务，可以采用读写分离，因为即使用户改了自己的自我介绍，在查询时却看到了自我介绍还是旧的，业务影响与不能登录相比就小很多，还可以忍受。</p><h3 id="58-你们一般是怎么分库的呢？">58.你们一般是怎么分库的呢？</h3><ul><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li></ul><p><img src="https://s2.loli.net/2023/03/31/XYjAc6EMKmtw3oV.png" alt="垂直分库"></p><ul><li>水平分库：以字段为依据，按照一定策略（hash、range 等），将一个库中的数据拆分到多个库中。</li></ul><p><img src="https://s2.loli.net/2023/03/31/AXMPRiODoBerjad.png" alt="水平分库"></p><h3 id="59-那你们是怎么分表的？">59.那你们是怎么分表的？</h3><ul><li>水平分表：以字段为依据，按照一定策略（hash、range 等），将一个表中的数据拆分到多个表中。</li><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li></ul><p><img src="https://s2.loli.net/2023/03/31/HK8sewhCDRnTYXy.png" alt="表拆分"></p><h3 id="60-水平分表有哪几种路由方式？">60.水平分表有哪几种路由方式？</h3><p>什么是路由呢？就是数据应该分到哪一张表。</p><p>水平分表主要有三种路由方式：</p><ul><li><strong>范围路由</strong>：选取有序的数据列 （例如，整形、时间戳等） 作为路由的条件，不同分段分散到不同的数据库表中。</li></ul><p>我们可以观察一些支付系统，发现只能查一年范围内的支付记录，这个可能就是支付公司按照时间进行了分表。</p><p><img src="https://s2.loli.net/2023/03/31/bcjgk2W1QePsLIU.png" alt="范围路由"></p><p>范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。</p><p>范围路由的优点是可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。范围路由的一个比较隐含的缺点是分布不均匀，假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1000 条，而另外一个分段实际存储的数据量有 900 万条。</p><ul><li><strong>Hash 路由</strong>：选取某个列 （或者某几个列组合也可以） 的值进行 Hash 运算，然后根据 Hash 结果分散到不同的数据库表中。</li></ul><p>同样以订单 id 为例，假如我们一开始就规划了 4 个数据库表，路由算法可以简单地用 id % 4 的值来表示数据所属的数据库表编号，id 为 12 的订单放到编号为 50 的子表中，id 为 13 的订单放到编号为 61 的字表中。</p><p><img src="https://s2.loli.net/2023/03/31/4Y8amqnubtQwBIz.png" alt="Hash 路由"></p><p>Hash 路由设计的复杂点主要体现在初始表数量的选取上，表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。而用了 Hash 路由后，增加子表数量是非常麻烦的，所有数据都要重分布。Hash 路由的优缺点和范围路由基本相反，Hash 路由的优点是表分布比较均匀，缺点是扩充新的表很麻烦，所有数据都要重分布。</p><ul><li><strong>配置路由</strong>：配置路由就是路由表，用一张独立的表来记录路由信息。同样以订单 id 为例，我们新增一张 order_router 表，这个表包含 orderjd 和 tablejd 两列 , 根据 orderjd 就可以查询对应的 table_id。</li></ul><p>配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。</p><p><img src="https://s2.loli.net/2023/03/31/ekuY9ZmHw2bP4q8.png" alt="配置路由"></p><p>配置路由的缺点就是必须多查询一次，会影响整体性能；而且路由表本身如果太大（例如，几亿条数据） ，性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则又面临一个死循环式的路由算法选择问题。</p><h3 id="61-不停机扩容怎么实现？">61.不停机扩容怎么实现？</h3><p>实际上，不停机扩容，实操起来是个非常麻烦而且很有风险的操作，当然，面试回答起来就简单很多。</p><ul><li><strong>第一阶段：在线双写，查询走老库</strong></li></ul><ol><li>建立好新的库表结构，数据写入旧库的同时，也写入拆分的新库</li><li>数据迁移，使用数据迁移程序，将旧库中的历史数据迁移到新库</li><li>使用定时任务，新旧库的数据对比，把差异补齐</li></ol><p><img src="https://s2.loli.net/2023/04/01/DnfbEmArkSdI7B6.png" alt=""></p><ul><li><strong>第二阶段：在线双写，查询走新库</strong></li></ul><ol><li>完成了历史数据的同步和校验</li><li>把对数据的读切换到新库</li></ol><p><img src="https://s2.loli.net/2023/04/01/MH4fxitUskWJzvI.png" alt=""></p><ul><li><strong>第三阶段：旧库下线</strong></li></ul><ol><li>旧库不再写入新的数据</li><li>经过一段时间，确定旧库没有请求之后，就可以下线老库</li></ol><p><img src="https://s2.loli.net/2023/04/01/rJPZtgj5pbmY1Ni.png" alt=""></p><h3 id="62-常用的分库分表中间件有哪些？">62.常用的分库分表中间件有哪些？</h3><ul><li>sharding-jdbc</li><li>Mycat</li></ul><h3 id="63-那你觉得分库分表会带来什么问题呢？">63.那你觉得分库分表会带来什么问题呢？</h3><p>从分库的角度来讲：</p><ul><li><p><strong>事务的问题</strong></p><p>使用关系型数据库，有很大一点在于它保证事务完整性。而分库之后单机事务就用不上了，必须使用分布式事务来解决。</p></li><li><p><strong>跨库 JOIN 问题</strong></p><p>在一个库中的时候我们还可以利用 JOIN 来连表查询，而跨库了之后就无法使用 JOIN 了。</p><p>此时的解决方案就是<strong>在业务代码中进行关联</strong>，也就是先把一个表的数据查出来，然后通过得到的结果再去查另一张表，然后利用代码来关联得到最终的结果。</p><p>这种方式实现起来稍微比较复杂，不过也是可以接受的。</p><p>还有可以<strong>适当的冗余一些字段</strong>。比如以前的表就存储一个关联 ID，但是业务时常要求返回对应的 Name 或者其他字段。这时候就可以把这些字段冗余到当前表中，来去除需要关联的操作。</p><p>还有一种方式就是<strong>数据异构</strong>，通过 binlog 同步等方式，把需要跨库 join 的数据异构到 ES 等存储结构中，通过 ES 进行查询。</p></li></ul><p>从分表的角度来看：</p><ul><li><p><strong>跨节点的 count,order by,group by 以及聚合函数问题</strong></p><p>只能由业务代码来实现或者用中间件将各表中的数据汇总、排序、分页然后返回。</p></li><li><p><strong>数据迁移，容量规划，扩容等问题</strong></p><p>数据的迁移，容量如何规划，未来是否可能再次需要扩容，等等，都是需要考虑的问题。</p></li><li><p><strong>ID 问题</strong></p><p>数据库表被切分后，不能再依赖数据库自身的主键生成机制，所以需要一些手段来保证全局主键唯一。</p><ol><li>还是自增，只不过自增步长设置一下。比如现在有三张表，步长设置为 3，三张表 ID 初始值分别是 1、2、3。这样第一张表的 ID 增长是 1、4、7。第二张表是 2、5、8。第三张表是 3、6、9，这样就不会重复了。</li><li>UUID，这种最简单，但是不连续的主键插入会导致严重的页分裂，性能比较差。</li><li>分布式 ID，比较出名的就是 Twitter 开源的 sonwflake 雪花算法</li></ol></li></ul><h2 id="运维">运维</h2><h3 id="64-百万级别以上的数据如何删除？">64.百万级别以上的数据如何删除？</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作，这些操作需要消耗额外的 IO,会降低增/改/删的执行效率。</p><p>所以，在我们删除数据库百万级别数据的时候，查询 MySQL 官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引</li><li>然后删除其中无用数据</li><li>删除完成后重新创建索引创建索引也非常快</li></ol><h3 id="65-百万千万级大表如何添加字段？">65.百万千万级大表如何添加字段？</h3><p>当线上的数据库数据量到达几百万、上千万的时候，加一个字段就没那么简单，因为可能会长时间锁表。</p><p>大表添加字段，通常有这些做法：</p><ul><li><p>通过中间表转换过去</p><p>创建一个临时的新表，把旧表的结构完全复制过去，添加字段，再把旧表数据复制过去，删除旧表，新表命名为旧表的名称，这种方式可能回丢掉一些数据。</p></li><li><p>用 pt-online-schema-change</p><p><code>pt-online-schema-change</code>是 percona 公司开发的一个工具，它可以在线修改表结构，它的原理也是通过中间表。</p></li><li><p>先在从库添加 再进行主从切换</p></li></ul><p>如果一张表数据量大且是热表（读写特别频繁），则可以考虑先在从库添加，再进行主从切换，切换后再将其他几个节点上添加字段。</p><h3 id="66-MySQL-数据库-cpu-飙升的话，要怎么处理呢？">66.MySQL 数据库 cpu 飙升的话，要怎么处理呢？</h3><p>排查过程：</p><p>（1）使用 top 命令观察，确定是 mysqld 导致还是其他原因。</p><p>（2）如果是 mysqld 导致的，show processlist，查看 session 情况，确定是不是有消耗资源的 sql 在运行。</p><p>（3）找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</p><p>处理：</p><p>（1）kill 掉这些线程 (同时观察 cpu 使用率是否下降)，</p><p>（2）进行相应的调整 (比如说加索引、改 sql、改内存参数)</p><p>（3）重新跑这些 SQL。</p><p>其他情况：</p><p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p><h2 id="分区">分区</h2><div class="note info flat"><p>分区表很少被问到，分区表的局限在于分区之后还是单节点，如果数据增长趋势可预知的快的话，还是会有瓶颈，还不如一步到位做分库分表。关于分区表的知识可以看这篇博客</p><p><a class="btn-beautify blue" href="https://blog.csdn.net/weixin_44462773/article/details/128013794"   title="mysql创建表分区详细介绍及示例" target="_blank"><i class="fa-solid fa-blog"></i><span>mysql创建表分区详细介绍及示例</span></a></p></div><h3 id="67-什么是分区？和分表有什么异同点？">67. 什么是分区？和分表有什么异同点？</h3><p>通俗的讲<strong>分区</strong>就是将一个大表根据条件切割分成一个个小表（分块存储），比如一个仓储表根据地区进行分区，用户表根据性别进行分区等。mysql从5.1版本开始支持分区。</p><p>和分表的异同点：</p><h4 id="相同点：">相同点：</h4><ol><li>都可以提高查询效率，都是根据特定条件对表进行切分</li><li>从处理方式上来讲都是对大数据量级的表进行切分</li><li>都能提高表运维的效率和降低成本</li></ol><h4 id="不同点：">不同点：</h4><ol><li>存储方式：<ul><li>分区表是在磁盘持久化上对数据进行分块存储，可以存储到不同的物理磁盘上，本质上还是一个表。</li><li>分表处理后的每个小表都是一个完整的表，既可以存储到不同的服务器上，也可以存储到不同的物理磁盘上。</li><li>总结：架构上可以认为分区表还是一主N从，分表则是多主N从</li></ul></li><li>性能对比：分区表是存取操作是单节点，分表则是可以多节点并发执行然后汇总。分区表的本质是想通过对文件进行切割突破磁盘IO瓶颈，分表不仅提高了单表的并发性能，同时提高了IO性能。</li><li>实现难易：<ul><li>分表的方案成熟并且丰富，但是实现上说比较复杂</li><li>分区实现简单，建表和单表是一样的，对客户端来说是透明的</li></ul></li></ol><h3 id="68-为什么要对表进行分区">68. 为什么要对表进行分区</h3><p>为了改善大型表以及具有各种访问模式的表的可伸缩性，可管理性以及提高数据库效率。分区表的优点有：</p><ol><li>存储更多。与单个磁盘或文件系统分区相比，可以存储更多的数据。</li><li>便于删除。删除数据时，可以通过删除与那些数据有关的分区，很容易地删除那些数据。相反地，在某些情况下，添加新数据的过程又可以通过为那些新数据专门增加一个新的分区，来很方便地实现。</li><li>查询优化。<ul><li>满足一个给定WHERE语句的数据可以只保存在一个或多个分区内，在查找时无需查找其他分区。因为分区可以在创建了分区表后进行修改，所以在第一次配置分区方案还不曾这么做时，可以重新组织数据，来提高常用查询的效率。</li><li>聚合函数（例如SUM()、COUNT()）的查询，可以很容易地进行并行处理。这种查询的一个简单例子如 “SELECT salesperson_id, COUNT (orders) as order_total FROM sales GROUP BY salesperson_id；”。通过“并行”，这意味着该查询可以在每个分区上同时进行，最终结果为总计所有分区得到的结果。</li><li>通过跨多个磁盘来分散数据查询，获得更大的查询吞吐量。</li></ul></li></ol><h3 id="69-分区表的限制因素？">69. 分区表的限制因素？</h3><ol><li><p>单表支持的分区数量。5.7以前一个表只支持<strong>1024</strong>个分区，5.7开始支持<strong>8196</strong>个分区。</p><div class="note info flat"><p>分区不是越多越好。linux中cd proc/1064/fd 文件描述符太多会影响io效率；还有ulimit -a 中open files最大可以同时打开1024个文件。可以修改，但是要和内存匹配，1G内存最多打开10万个文件。</p></div></li><li><p>MySQL5.1中，分区表达式必须是<strong>整数或者是返回整数表达式</strong>，mysql5.5中，可以<strong>直接使用列进行分区</strong>。</p></li><li><p><strong>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</strong>。</p><div class="note info flat"><p>实操试了一下，分区表必须包含主键或主键的一部分。</p></div></li><li><p>分区表中无法使用外键约束。</p></li><li><p>MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分区。</p></li><li><p>查询必须使用分区字段，否则分区查询就会失败，走所有分区。</p></li></ol><h3 id="70-基本分区类型有哪些？">70. 基本分区类型有哪些？</h3><ul><li><p><strong>Range分区</strong>：基于一个连续区间的列值进行分区。这些区间要连续且不能相互重叠。使用<code>value less than</code>来定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> titles</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(<span class="keyword">year</span>(from_date))</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">partition</span> p01 <span class="keyword">values</span> less than (<span class="number">1985</span>),</span><br><span class="line">    <span class="keyword">partition</span> p02 <span class="keyword">values</span> less than (<span class="number">1986</span>),</span><br><span class="line">    <span class="keyword">partition</span> p03 <span class="keyword">values</span> less than (<span class="number">1987</span>),</span><br><span class="line">    <span class="keyword">partition</span> p03 <span class="keyword">values</span> less than (MAXVALUE)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 或者建表时分好</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales (</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    product_name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    sale_date <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(sale_date)) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p2019 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2020</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2020 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2021</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2021 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2022</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2022 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2023</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> future <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p><strong>List分区</strong>：类似于Range分区，区别在于它是基于列值一个离散集合中的某个值进行分区。通过 <code>partition by LIST(expr)</code>和<code>values in</code>来实现。假设有这样一个表：有20个音像店，分布在4个有经销权的地区</p><table><thead><tr><th>地区</th><th>商店id</th></tr></thead><tbody><tr><td>北区</td><td>3,5,6,9,17</td></tr><tr><td>东区</td><td>1,2,10,11,19,20</td></tr><tr><td>西区</td><td>4,12,13,14,18</td></tr><tr><td>中心区</td><td>7,8,15,16</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> staff;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> staff(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  fname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  lname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  hired <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">  separated <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">  job_code <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  store_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> list(store_id)(</span><br><span class="line">  <span class="keyword">partition</span> pNorth <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">17</span>),</span><br><span class="line">  <span class="keyword">partition</span> pEast <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">19</span>,<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">partition</span> pWest <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">18</span>),</span><br><span class="line">  <span class="keyword">partition</span> pCentral <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="note info flat"><ul><li>这使得在表中增加或删除指定地区的雇员记录变得容易起来。例如，假定西区的所有音像店都卖给了其他公司。那么与在西区音像店工作雇员相关的所有记录（行）可以使用查询<code>ALTER TABLE staff DROP PARTITION pWest;</code>来进行删除，它与具有同样作用的DELETE（删除）<code>DELETE FROM staff WHERE store_id IN (4,12,13,14,18);</code>比起来，要有效得多。</li><li>如果试图插入列值（或分区表达式的返回值）不在分区值列表中的一行时，那么“INSERT”查询将失败并报错。</li><li><strong>当插入多条数据出错时</strong>，<strong>如果表的引擎支持事务</strong>（Innodb），<strong>则不会插入任何数据</strong>；<strong>如果不支持事务</strong>，<strong>则出错前的数据会插入</strong>，<strong>后面的不会执行</strong>。</li><li>与Range分区相同，添加COLUMNS关键字可支持非整数和多列。</li></ul></div></li><li><p><strong>Hash分区</strong>：基于用户定义的表达式返回值来进行分区。该表达式通过给定列值计算。HASH分区主要用来确保数据在预先确定数目的分区中平均分布，Hash括号内只能是整数列或返回确定整数的函数，实际上就是使用返回的整数对分区数取模。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> staff;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> staff(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  fname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  lname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  hired <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">  separated <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">  job_code <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  store_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> hash(<span class="keyword">year</span>(hired))</span><br><span class="line">partitions <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>Key分区</strong>：类似Hash分区，区别在于Key分区只支持计算一列或多列且只有mysql本身自带的hash函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> staff;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> staff(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  fname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  lname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  hired <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">  separated <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">  job_code <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  store_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> key(store_id)</span><br><span class="line">partitions <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> staff;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> staff(</span><br><span class="line">  id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  fname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  lname <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  hired <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;1970-01-01&#x27;</span>,</span><br><span class="line">  separated <span class="type">date</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;9999-12-31&#x27;</span>,</span><br><span class="line">  job_code <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  store_id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> key(store_id)</span><br><span class="line">partitions <span class="number">4</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>组合分区</strong>：分区之下再分区，关键字是 <code>SUBPARTITION</code>（了解就行）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ts (id <span class="type">INT</span>, purchased <span class="type">DATE</span>)</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(purchased) )</span><br><span class="line">    SUBPARTITION <span class="keyword">BY</span> HASH( TO_DAYS(purchased) ) (</span><br><span class="line">        <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1990</span>) (</span><br><span class="line">            SUBPARTITION s0,</span><br><span class="line">            SUBPARTITION s1</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2000</span>) (</span><br><span class="line">            SUBPARTITION s2,</span><br><span class="line">            SUBPARTITION s3</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN MAXVALUE (</span><br><span class="line">            SUBPARTITION s4,</span><br><span class="line">            SUBPARTITION s5</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li></ul><h3 id="71-分区查询操作">71. 分区查询操作</h3><p>MySQL 5.7支持显式选择分区和子分区，在执行语句时，应检查是否有与给定WHERE条件匹配的行。分区选择与分区精简相似，分区选择只检查特定分区的匹配情况，但在两个关键方面有所不同：</p><ol><li><p>分区选择要检查的分区由语句的发布者指定，而分区精简它是自动的。</p></li><li><p>尽管分区精简仅适用于查询，但查询和许多DML语句都支持分区的显式选择。</p></li><li><p>支持显式分区选择的SQL语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名  <span class="keyword">PARTITION</span> (分区名称<span class="number">1</span>,分区名称<span class="number">2</span>,分区名称n) <span class="keyword">WHERE</span> 查询条件;</span><br></pre></td></tr></table></figure></li><li><p>隐式分区要注意where条件中需要包含分区的关键字，以确保查询时是通过分区查询，而不是全表扫描，查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名  <span class="keyword">WHERE</span> 查询条件;</span><br></pre></td></tr></table></figure></li><li><p>执行计划查询时需要加上关键字 <code>partitions</code>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN PARTITIONS <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dev_date <span class="keyword">WHERE</span> Partition_Date <span class="operator">=</span> ‘<span class="number">2022</span><span class="number">-02</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">07</span>:<span class="number">00</span>’;</span><br></pre></td></tr></table></figure></li></ol><h3 id="72-分区增删改操作">72. 分区增删改操作</h3><h4 id="新增分区">新增分区</h4><ul><li><p>非分区表转换成分区表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">partition</span> <span class="keyword">by</span> 分区逻辑;</span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> results <span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">RANGE</span> (<span class="keyword">month</span>(ttime)) (</span><br><span class="line"><span class="keyword">PARTITION</span> p5 <span class="keyword">VALUES</span> LESS THAN (<span class="number">6</span>) , </span><br><span class="line"><span class="keyword">PARTITION</span> p11 <span class="keyword">VALUES</span> LESS THAN (<span class="number">12</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> P12 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>分区表增加分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">partition</span> (<span class="keyword">partition</span> 分区名称 <span class="keyword">values</span> less than (逻辑));</span><br><span class="line"><span class="comment">-- RANGE</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> less than MAXVALUE);</span><br><span class="line"><span class="comment">-- LIST</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> list_part <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">25</span>,<span class="number">26</span>,<span class="number">28</span>));</span><br><span class="line"><span class="comment">-- HASH</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> hash_part <span class="keyword">add</span> <span class="keyword">partition</span> partitions <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- KEY</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> key_part <span class="keyword">add</span> <span class="keyword">partition</span> partitions <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="重新分区">重新分区</h4><p><code>Range</code>和<code>List</code>分区类型关键字为 <code>REORGANIZE </code>。但是<code>Hash</code>和 <code>Key</code>都不能这样用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- RANGE</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN MAXVALUE);</span><br><span class="line"><span class="comment">-- LIST</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> list_part REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h4 id="分区删除操作">分区删除操作</h4><p>指定分区的删除动作，更加高效。</p><ul><li><p>删除分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名  <span class="keyword">drop</span> <span class="keyword">partition</span> 分区名称;</span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> staff  <span class="keyword">drop</span> <span class="keyword">partition</span> p0;</span><br></pre></td></tr></table></figure></li><li><p>删除指定分区中的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  表名  <span class="keyword">PARTITION</span>  (分区名称<span class="number">1</span>,分区名称<span class="number">2</span>,分区名称n)</span><br><span class="line"><span class="keyword">WHERE</span> 子句</span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dev_fac <span class="keyword">PARTITION</span>(p1000000000000001) <span class="keyword">WHERE</span> devName <span class="operator">=</span> ‘D10000000000000011名称’</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> mysql篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis篇(修正版)</title>
      <link href="/posts/c841c453.html"/>
      <url>/posts/c841c453.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="1-说说什么是MyBatis">1. 说说什么是MyBatis?</h3><p><img src="https://s2.loli.net/2023/03/31/eF5lCpkMc4hafBv.png" alt="MyBatis logo"></p><p><strong>先吹一下</strong>：</p><ul><li>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。</li><li>MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li></ul><p><strong>再说一下缺点</strong></p><ul><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul><blockquote><p><strong>ORM是什么?</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/31/y4KZFzNOChQp9Mt.png" alt="ORM简单示意图"></p><ul><li>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单来说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</li></ul><blockquote><p><strong>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</strong></p></blockquote><ul><li>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</li><li>而Mybatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，被称之为半自动ORM映射工具。</li></ul><blockquote><p><strong>JDBC编程有哪些不足之处，MyBatis是如何解决的？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/31/aeVhs1gvlFCB2fI.png" alt="JDBC编程的不足"></p><ul><li>1、数据连接创建、释放频繁造成系统资源浪费从而影响系统性能，在mybatis-config.xml中配置数据链接池，使用连接池统一管理数据库连接。</li><li>2、sql语句写在代码中造成代码不易维护，将sql语句配置在XXXXmapper.xml文件中与java代码分离。</li><li>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。Mybatis自动将java对象映射至sql语句。</li><li>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。Mybatis自动将sql执行结果映射至java对象。</li></ul><h3 id="2-Hibernate-和-MyBatis-有什么区别？">2. Hibernate 和 MyBatis 有什么区别？</h3><p><strong>相同点</strong></p><ul><li>都是对jdbc的封装，都是应用于持久层的框架。</li></ul><p><img src="https://s2.loli.net/2023/03/31/sxZqkpNbG6MXFnT.gif" alt="这还用说？"></p><p><strong>不同点</strong></p><p>1）映射关系</p><ul><li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li><li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li></ul><p>2）<strong>SQL优化和移植性</strong></p><ul><li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li><li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li></ul><p>3）<strong>MyBatis和Hibernate的适用场景不同</strong></p><p><img src="https://s2.loli.net/2023/03/31/GYvEqLgodTXeBjn.png" alt="Mybatis vs Hibernate"></p><ul><li>Hibernate 是标准的ORM框架，SQL编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统</li><li>MyBatis 是半ORM框架，需要编写较多SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站</li></ul><h3 id="3-MyBatis使用过程？生命周期？">3. MyBatis使用过程？生命周期？</h3><p>MyBatis基本使用的过程大概可以分为这么几步：</p><p><img src="https://s2.loli.net/2023/03/31/jeG2z6bQ9Roax3u.png" alt="Mybatis基本使用步骤"></p><ul><li>1）创建SqlSessionFactory</li></ul><p>可以从配置或者直接编码来创建SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><ul><li>2）通过SqlSessionFactory创建SqlSession</li></ul><p>SqlSession（会话）可以理解为程序和数据库之间的桥梁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure><ul><li>3）通过sqlsession执行数据库操作</li></ul><p>可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> (Blog)session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>更常用的方式是先获取Mapper(映射)，然后再执行SQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure><ul><li>4）调用session.commit()提交事务</li></ul><p>如果是更新、删除语句，我们还需要提交一下事务。</p><ul><li>5）调用session.close()关闭会话</li></ul><p>最后一定要记得关闭会话。</p><blockquote><p><strong>MyBatis生命周期？</strong></p></blockquote><p>上面提到了几个MyBatis的组件，一般说的MyBatis生命周期就是这些组件的生命周期。</p><ul><li>SqlSessionFactoryBuilder</li></ul><p>一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的生命周期只存在于方法的内部。</p><ul><li>SqlSessionFactory</li></ul><p>SqlSessionFactory 是用来创建SqlSession的，相当于一个数据库连接池，每次创建SqlSessionFactory都会使用数据库资源，多次创建和销毁是对资源的浪费。所以SqlSessionFactory是应用级的生命周期，而且应该是单例的。</p><ul><li>SqlSession</li></ul><p>SqlSession相当于JDBC中的Connection，SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的生命周期是一次请求或一个方法。</p><ul><li>Mapper</li></ul><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的，它的生命周期在sqlsession事务方法之内，一般会控制在方法级。</p><p><img src="https://s2.loli.net/2023/03/31/GnRQgq76sH8u1oM.png" alt="MyBatis主要组件生命周期"></p><p>当然，万物皆可集成Spring，MyBatis通常也是和Spring集成使用，Spring可以帮助我们创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到我们的 bean 中，我们不需要关心它们的创建过程和生命周期，那就是另外的故事了。</p><p><img src="https://s2.loli.net/2023/03/31/q5FKL6Q43y9EicV.jpg" alt="这个应该会"></p><h3 id="4-在mapper中如何传递多个参数？">4. 在mapper中如何传递多个参数？</h3><p><img src="https://s2.loli.net/2023/03/31/cCtdYwrhUmonKMZ.png" alt="mapper传递多个参数方法"></p><p><strong>方法1：顺序传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(String name, <span class="type">int</span> deptId)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;<span class="number">0</span>&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;<span class="number">1</span>&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的数字代表传入参数的顺序。</li><li>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</li></ul><p><strong>方法2：@Param注解传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String name, <span class="type">int</span> <span class="meta">@Param(&quot;deptId&quot;)</span> deptId)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的名称对应的是注解@Param括号里面修饰的名称。</li><li>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</li></ul><p><strong>方法3：Map传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;java.util.Map&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的名称对应的是Map里面的key名称。</li><li>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</li></ul><p><strong>方法4：Java Bean传参法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">selectUser</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;selectUser&quot;</span> parameterType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span> resultMap=<span class="string">&quot;UserResultMap&quot;</span>&gt;</span><br><span class="line">    select * from user</span><br><span class="line">    <span class="type">where</span> <span class="variable">user_name</span> <span class="operator">=</span> #&#123;userName&#125; <span class="type">and</span> <span class="variable">dept_id</span> <span class="operator">=</span> #&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><code>\#&#123;&#125;</code>里面的名称对应的是User类里面的成员属性。</li><li>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。（推荐使用）。</li></ul><h3 id="5-实体类属性名和表中字段名不一样-，怎么办">5. 实体类属性名和表中字段名不一样 ，怎么办?</h3><ul><li>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span><br><span class="line">       select order_id id, order_no orderno ,order_price price form orders where order_id=#&#123;id&#125;;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>第2种： 通过resultMap  中的&lt;result&gt;来映射字段名和实体类属性名的一一对应的关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getOrder&quot;</span> parameterType=<span class="string">&quot;int&quot;</span> resultMap=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">  select * from orders where order_id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;resultMap type=<span class="string">&quot;com.jourwon.pojo.Order&quot;</span> id=<span class="string">&quot;orderResultMap&quot;</span>&gt;</span><br><span class="line">    &lt;!–用id属性来映射主键字段–&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;id&quot;</span> column=<span class="string">&quot;order_id&quot;</span>&gt;</span><br><span class="line">    &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;</span><br><span class="line">  &lt;<span class="type">result</span> <span class="variable">property</span> <span class="operator">=</span><span class="string">&quot;orderno&quot;</span> column =<span class="string">&quot;order_no&quot;</span>/&gt;</span><br><span class="line">  &lt;result property=<span class="string">&quot;price&quot;</span> column=<span class="string">&quot;order_price&quot;</span> /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><h3 id="6-Mybatis是否可以映射Enum枚举类？">6. Mybatis是否可以映射Enum枚举类？</h3><ul><li>Mybatis当然可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</li><li>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</li></ul><h3 id="7-和-的区别">7. <code>#&#123;&#125;和$&#123;&#125;的区别</code>?</h3><p><img src="https://s2.loli.net/2023/03/31/FTcdbqDVOafrP3e.png" alt=""></p><ul><li><code>#&#123;&#125;</code>是占位符，预编译处理；<code>$&#123;&#125;</code>是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理<code>#&#123;&#125;</code>时，<code>#&#123;&#125;</code>传入参数是以字符串传入，会将SQL中的<code>#&#123;&#125;</code>替换为?号，调用PreparedStatement的set方法来赋值。</li><li><code>#&#123;&#125;</code> 可以有效的防止SQL注入，提高系统安全性；<code>$&#123;&#125;</code> 不能防止SQL 注入</li><li><code>#&#123;&#125;</code> 的变量替换是在DBMS 中；<code>$&#123;&#125;</code> 的变量替换是在 DBMS 外</li></ul><h3 id="8-模糊查询like语句该怎么写">8. 模糊查询like语句该怎么写?</h3><p><img src="https://s2.loli.net/2023/03/31/jaSWcYPRvfqQbMB.png" alt="concat拼接like"></p><ul><li>1 ’<code>%$&#123;question&#125;%</code>’ 可能引起SQL注入，不推荐</li><li>2 <code>&quot;%&quot;#&#123;question&#125;&quot;%&quot;</code> 注意：因为<code>#&#123;…&#125;</code>解析成sql语句时候，会在变量外侧自动加单引号’ '，所以这里 % 需要使用双引号&quot; &quot;，不能使用单引号 ’ '，不然会查不到任何结果。</li><li>3 <code>CONCAT('%',#&#123;question&#125;,'%')</code> 使用CONCAT()函数，（推荐✨）</li><li>4 使用bind标签（不推荐）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;listUserLikeUsername&quot;</span> resultType=<span class="string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;&lt;bind name=<span class="string">&quot;pattern&quot;</span> value=<span class="string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span><br><span class="line">&amp;emsp;&amp;emsp;select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="9-Mybatis能执行一对一、一对多的关联查询吗？">9. Mybatis能执行一对一、一对多的关联查询吗？</h3><p>当然可以，不止支持一对一、一对多的关联查询，还支持多对多、多对一的关联查询。</p><p><img src="https://s2.loli.net/2023/03/31/GZVhqoH92EA7kvT.png" alt="MyBatis级联"></p><ul><li><strong>一对一&lt;association&gt;</strong></li></ul><p>比如订单和支付是一对一的关系，这种关联的实现：</p><p>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Pay pay;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 订单resultMap --&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;peopleResultMap&quot;</span> type=<span class="string">&quot;cn.fighter3.entity.Order&quot;</span>&gt;</span><br><span class="line">    &lt;id property=<span class="string">&quot;orderId&quot;</span> column=<span class="string">&quot;order_id&quot;</span> /&gt;</span><br><span class="line">    &lt;result property=<span class="string">&quot;orderDesc&quot;</span> column=<span class="string">&quot;order_desc&quot;</span>/&gt;</span><br><span class="line">    &lt;!--一对一结果映射--&gt;</span><br><span class="line">    &lt;association property=<span class="string">&quot;pay&quot;</span> javaType=<span class="string">&quot;cn.fighter3.entity.Pay&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;payId&quot;</span> property=<span class="string">&quot;pay_id&quot;</span>/&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;account&quot;</span> property=<span class="string">&quot;account&quot;</span>/&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>查询就是普通的关联查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getTeacher&quot;</span> resultMap=<span class="string">&quot;getTeacherMap&quot;</span> parameterType=<span class="string">&quot;int&quot;</span>&gt;</span><br><span class="line">    select * from order o </span><br><span class="line">     left join pay p on o.order_id=p.order_id</span><br><span class="line">    where  o.order_id=#&#123;orderId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>一对多<code>&lt;collection&gt;</code></strong></li></ul><p>比如商品分类和商品，是一对多的关系。</p><ul><li>实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> categoryId;</span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 商品列表</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    List&lt;Product&gt; products;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><ul><li>结果映射</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">&quot;Category&quot;</span> id=<span class="string">&quot;categoryBean&quot;</span>&gt;</span><br><span class="line">    &lt;id column=<span class="string">&quot;categoryId&quot;</span> property=<span class="string">&quot;category_id&quot;</span> /&gt;</span><br><span class="line">    &lt;result column=<span class="string">&quot;categoryName&quot;</span> property=<span class="string">&quot;category_name&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 一对多的关系 --&gt;</span><br><span class="line">    &lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类型 --&gt;</span><br><span class="line">    &lt;collection property=<span class="string">&quot;products&quot;</span> ofType=<span class="string">&quot;Product&quot;</span>&gt;</span><br><span class="line">        &lt;id column=<span class="string">&quot;product_id&quot;</span> property=<span class="string">&quot;productId&quot;</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;productName&quot;</span> property=<span class="string">&quot;productName&quot;</span> /&gt;</span><br><span class="line">        &lt;result column=<span class="string">&quot;price&quot;</span> property=<span class="string">&quot;price&quot;</span> /&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><ul><li>查询</li></ul><p>查询就是一个普通的关联查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 关联查询分类和产品表 --&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;listCategory&quot;</span> resultMap=<span class="string">&quot;categoryBean&quot;</span>&gt;</span><br><span class="line">    select c.*, p.* from category_ c left join product_ p on c.id = p.cid</span><br><span class="line">&lt;/select&gt;  </span><br></pre></td></tr></table></figure><pre><code>那么多对一、多对多怎么实现呢？还是利用\&lt;association&gt;和\&lt;collection&gt;，篇幅所限，这里就不展开了。</code></pre><h3 id="10-Mybatis是否支持延迟加载？原理？">10. Mybatis是否支持延迟加载？原理？</h3><ul><li>Mybatis支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</li><li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li><li>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</li></ul><h3 id="11-如何获取生成的主键">11. 如何获取生成的主键?</h3><ul><li>新增标签中添加：keyProperty=&quot; ID &quot;  即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">&quot;insert&quot;</span> useGeneratedKeys=<span class="string">&quot;true&quot;</span> keyProperty=<span class="string">&quot;userId&quot;</span> &gt;</span><br><span class="line">    insert into <span class="title function_">user</span><span class="params">( </span></span><br><span class="line"><span class="params">    user_name, user_password, create_time)</span> </span><br><span class="line">    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType= TIMESTAMP&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><ul><li>这时候就可以完成回填主键</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapper.insert(user);</span><br><span class="line">user.getId;</span><br></pre></td></tr></table></figure><h3 id="12-MyBatis支持动态SQL吗？">12. MyBatis支持动态SQL吗？</h3><p>MyBatis中有一些支持动态SQL的标签，它们的原理是使用OGNL从SQL参数对象中计算表达式的值，根据表达式的值动态拼接SQL，以此来完成动态SQL的功能。</p><p><img src="https://s2.loli.net/2023/03/31/mk2fWTyoPFcdOC3.png" alt="MyBatis"></p><ul><li>if</li></ul><p>根据条件来组成where子句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogWithTitleLike&quot;</span></span><br><span class="line">   resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">SELECT * FROM BLOG</span><br><span class="line"><span class="type">WHERE</span> <span class="variable">state</span> <span class="operator">=</span> ‘ACTIVE’</span><br><span class="line">&lt;<span class="keyword">if</span> test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">  AND title like #&#123;title&#125;</span><br><span class="line">&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>choose (when, otherwise)</li></ul><p>这个和Java 中的 switch 语句有点像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">   resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">SELECT * FROM BLOG <span class="type">WHERE</span> <span class="variable">state</span> <span class="operator">=</span> ‘ACTIVE’</span><br><span class="line">&lt;choose&gt;</span><br><span class="line">  &lt;when test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/when&gt;</span><br><span class="line">  &lt;when test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  &lt;/when&gt;</span><br><span class="line">  &lt;otherwise&gt;</span><br><span class="line">    <span class="type">AND</span> <span class="variable">featured</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  &lt;/otherwise&gt;</span><br><span class="line">&lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li><p>trim (where, set)</p></li><li><p>&lt;where&gt;可以用在所有的查询条件都是动态的情况</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;findActiveBlogLike&quot;</span></span><br><span class="line">   resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">SELECT * FROM BLOG</span><br><span class="line">&lt;where&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;state != null&quot;</span>&gt;</span><br><span class="line">       state = #&#123;state&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;title != null&quot;</span>&gt;</span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">if</span> test=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">  &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><ul><li>&lt;set&gt; 可以用在动态更新的时候</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br><span class="line">  update Author</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;username != null&quot;</span>&gt;username=#&#123;username&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;password != null&quot;</span>&gt;password=#&#123;password&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;email != null&quot;</span>&gt;email=#&#123;email&#125;,&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">if</span> test=<span class="string">&quot;bio != null&quot;</span>&gt;bio=#&#123;bio&#125;&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><ul><li><p>foreach</p><p>看到名字就知道了，这个是用来循环的，可以对集合进行遍历</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPostIn&quot;</span> resultType=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span><br><span class="line">SELECT *</span><br><span class="line">FROM POST P</span><br><span class="line">&lt;where&gt;</span><br><span class="line">  &lt;foreach item=<span class="string">&quot;item&quot;</span> index=<span class="string">&quot;index&quot;</span> collection=<span class="string">&quot;list&quot;</span></span><br><span class="line">      open=<span class="string">&quot;ID in (&quot;</span> separator=<span class="string">&quot;,&quot;</span> close=<span class="string">&quot;)&quot;</span> nullable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><h3 id="13-MyBatis如何执行批量操作？">13. MyBatis如何执行批量操作？</h3><p><img src="https://s2.loli.net/2023/03/31/qj3uXVRnxwZt7Kb.png" alt="MyBatis批量操作"></p><p><strong>第一种方法：使用foreach标签</strong></p><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p><ul><li>item      表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li><li>index    指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li><li>open    表示该语句以什么开始，常用“(”；</li><li>separator 表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li><li>close    表示以什么结束，常用“)”。</li></ul><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有以下3种情况：</p><ol><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</li></ol><p>看看批量保存的两种用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt; <span class="comment">//推荐使用</span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    INSERT INTO <span class="title function_">emp</span><span class="params">(ename,gender,email,did)</span></span><br><span class="line">    VALUES</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;,&quot;</span>&gt;</span><br><span class="line">        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=<span class="literal">true</span>的支持</span><br><span class="line"> 如jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/mybatis?allowMultiQueries=true --&gt;  </span></span><br><span class="line">&lt;insert id=<span class="string">&quot;addEmpsBatch&quot;</span>&gt;</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;emps&quot;</span> item=<span class="string">&quot;emp&quot;</span> separator=<span class="string">&quot;;&quot;</span>&gt;                                 </span><br><span class="line">        INSERT INTO <span class="title function_">emp</span><span class="params">(ename,gender,email,did)</span></span><br><span class="line">        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p><strong>第二种方法：使用ExecutorType.BATCH</strong></p><ul><li>Mybatis内置的ExecutorType有3种，默认为simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作时，在事务没有提交之前，是没有办法获取到自增的id，在某些情况下不符合业务的需求。</li></ul><p>具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量保存方法测试</span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//可以执行批量操作的sqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">openSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量保存执行前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> openSession.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            mapper.addEmp(<span class="keyword">new</span> <span class="title class_">Employee</span>(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">5</span>), <span class="string">&quot;b&quot;</span>, <span class="string">&quot;1&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        openSession.commit();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//批量保存执行后的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时长&quot;</span> + (end - start));</span><br><span class="line">        <span class="comment">//批量 预编译sql一次==》设置参数==》10000次==》执行1次   677</span></span><br><span class="line">        <span class="comment">//非批量  （预编译=设置参数=执行 ）==》10000次   1121</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapper和mapper.xml如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;   </span><br><span class="line">    <span class="comment">//批量保存员工</span></span><br><span class="line">    Long <span class="title function_">addEmp</span><span class="params">(Employee employee)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=<span class="string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span></span><br><span class="line">     &lt;!--批量保存员工 --&gt;</span><br><span class="line">    &lt;insert id=<span class="string">&quot;addEmp&quot;</span>&gt;</span><br><span class="line">        insert into <span class="title function_">employee</span><span class="params">(lastName,email,gender)</span></span><br><span class="line">        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><h3 id="14-说说Mybatis的一级、二级缓存？">14. 说说Mybatis的一级、二级缓存？</h3><ol><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为SqlSession，各个SqlSession之间的缓存相互隔离，当 Session flush 或 close 之后，该 SqlSession 中的所有 Cache 就将清空，MyBatis默认打开一级缓存。</li></ol><p><img src="https://s2.loli.net/2023/03/31/kxLtbENHQADRncV.png" alt="Mybatis一级缓存"></p><ol start="2"><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同之处在于其存储作用域为 Mapper(Namespace)，可以在多个SqlSession之间共享，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置。</li></ol><p><img src="https://s2.loli.net/2023/03/31/IQry29WTfha7RBv.png" alt="Mybatis二级缓存示意图"></p><h2 id="原理">原理</h2><h3 id="15-能说说MyBatis的工作原理吗？">15. 能说说MyBatis的工作原理吗？</h3><p>我们已经大概知道了MyBatis的工作流程，按工作原理，可以分为两大步：<code>生成会话工厂</code>、<code>会话运行</code>。</p><p><img src="https://s2.loli.net/2023/03/31/SepNBbPZmDaMl5L.png" alt="MyBatis的工作流程"></p><p>MyBatis是一个成熟的框架，篇幅限制，这里抓大放小，来看看它的主要工作流程。</p><blockquote><p><strong>构建会话工厂</strong></p></blockquote><p>构造会话工厂也可以分为两步：</p><p><img src="https://s2.loli.net/2023/03/31/YtABaZ154Tmypvq.png" alt="构建会话工厂"></p><ul><li>获取配置</li></ul><p>获取配置这一步经过了几步转化，最终由生成了一个配置类Configuration实例，这个配置类实例非常重要，主要作用包括：</p><ul><li>读取配置文件，包括基础配置文件和映射文件</li><li>初始化基础配置，比如MyBatis的别名，还有其它的一些重要的类对象，像插件、映射器、ObjectFactory等等</li><li>提供一个单例，作为会话工厂构建的重要参数</li><li>它的构建过程也会初始化一些环境变量，比如数据源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">      SqlSessionFactory var5;</span><br><span class="line">      <span class="comment">//省略异常处理</span></span><br><span class="line">          <span class="comment">//xml配置构建器</span></span><br><span class="line">          <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">          <span class="comment">//通过转化的Configuration构建SqlSessionFactory</span></span><br><span class="line">          var5 = <span class="built_in">this</span>.build(parser.parse());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><ul><li>构建SqlSessionFactory</li></ul><p>SqlSessionFactory只是一个接口，构建出来的实际上是它的实现类的实例，一般我们用的都是它的实现类DefaultSqlSessionFactory，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>会话运行</strong></p></blockquote><p>会话运行是MyBatis最复杂的部分，它的运行离不开四大组件的配合：</p><p><img src="https://s2.loli.net/2023/03/31/UndOxobM3wz9sBy.png" alt="MyBatis会话运行四大关键组件"></p><ul><li>Executor（执行器）</li></ul><p>Executor起到了至关重要的作用，SqlSession只是一个门面，相当于客服，真正干活的是是Executor，就像是默默无闻的工程师。它提供了相应的查询和更新方法，以及事务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.configuration.getEnvironment();</span><br><span class="line"><span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line"><span class="comment">//通过Configuration创建executor</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="built_in">this</span>.configuration.newExecutor(tx, execType);</span><br><span class="line">var8 = <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(<span class="built_in">this</span>.configuration, executor, autoCommit);</span><br></pre></td></tr></table></figure><ul><li>StatementHandler（数据库会话器）</li></ul><p>StatementHandler，顾名思义，处理数据库会话的。我们以SimpleExecutor为例，看一下它的查询方法，先生成了一个StatementHandler实例，再拿这个handler去执行query。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List var9;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> ms.getConfiguration();</span><br><span class="line">        <span class="type">StatementHandler</span> <span class="variable">handler</span> <span class="operator">=</span> configuration.newStatementHandler(<span class="built_in">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        stmt = <span class="built_in">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">        var9 = handler.query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再以最常用的PreparedStatementHandler看一下它的query方法，其实在上面的<code>prepareStatement</code>已经对参数进行了预编译处理，到了这里，就直接执行sql，使用ResultHandler处理返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement)statement;</span><br><span class="line">    ps.execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ParameterHandler （参数处理器）</li></ul><p>PreparedStatementHandler里对sql进行了预编译处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="built_in">this</span>.parameterHandler.setParameters((PreparedStatement)statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用的就是ParameterHandler，setParameters的作用就是设置预编译SQL语句的参数。</p><p>里面还会用到typeHandler类型处理器，对类型进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParameterHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">getParameterObject</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setParameters</span><span class="params">(PreparedStatement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ResultSetHandler（结果处理器）</p><p>我们前面也看到了，最后的结果要通过ResultSetHandler来进行处理，handleResultSets这个方法就是用来包装结果集的。Mybatis为我们提供了一个DefaultResultSetHandler，通常都是用这个实现类去进行结果的处理的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultSetHandler</span> &#123;</span><br><span class="line">  &lt;E&gt; List&lt;E&gt; <span class="title function_">handleResultSets</span><span class="params">(Statement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">handleCursorResultSets</span><span class="params">(Statement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleOutputParameters</span><span class="params">(CallableStatement var1)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会使用typeHandle处理类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。</p><p>整体上总结一下会话运行：</p><p><img src="https://s2.loli.net/2023/03/31/vzWlfXJ6ymhkiFa.png" alt="会话运行的简单示意图"></p><blockquote><p>我们最后把整个的工作流程串联起来，简单总结一下：</p></blockquote><p><img src="https://s2.loli.net/2023/03/31/bNFGOeRwTvQWqEU.png" alt="MyBatis整体工作原理图"></p><ol><li>读取 MyBatis 配置文件——mybatis-config.xml 、加载映射文件——映射文件即 SQL 映射文件，文件中配置了操作数据库的 SQL 语句。最后生成一个配置对象。</li><li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li><li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li><li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li><li>StatementHandler：数据库会话器，串联起参数映射的处理和运行结果映射的处理。</li><li>参数处理：对输入参数的类型进行处理，并预编译。</li><li>结果处理：对返回结果的类型进行处理，根据对象映射规则，返回相应的对象。</li></ol><h3 id="16-MyBatis的功能架构是什么样的？">16. MyBatis的功能架构是什么样的？</h3><p><img src="https://s2.loli.net/2023/03/31/nzcFb8qsBLTZeaP.png" alt="MyBatis功能架构"></p><p>我们一般把Mybatis的功能架构分为三层：</p><ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul><h3 id="17-为什么Mapper接口不需要实现类？">17. 为什么Mapper接口不需要实现类？</h3><p>四个字回答：<strong>动态代理</strong>，我们来看一下获取Mapper的过程：</p><p><img src="https://s2.loli.net/2023/03/31/3YXZF1zvjM7q9Q8.png" alt="Mapper代理"></p><ul><li>获取Mapper</li></ul><p>我们都知道定义的Mapper接口是没有实现类的，Mapper映射其实是通过<strong>动态代理</strong>实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br></pre></td></tr></table></figure><p>七拐八绕地进去看一下，发现获取Mapper的过程，需要先获取MapperProxyFactory——Mapper代理工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="built_in">this</span>.knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + var5, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MapperProxyFactory</li></ul><p>MapperProxyFactory的作用是生成MapperProxy（Mapper代理对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;<span class="built_in">this</span>.mapperInterface&#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">      MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>(sqlSession, <span class="built_in">this</span>.mapperInterface, <span class="built_in">this</span>.methodCache);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到动态代理对接口的绑定，它的作用就是生成动态代理对象（占位），而代理的方法被放到了MapperProxy中。</p><ul><li>MapperProxy</li></ul><p>MapperProxy里，通常会生成一个MapperMethod对象，它是通过cachedMapperMethod方法对其进行初始化的，然后执行excute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class.equals(method.getDeclaringClass()) ? method.invoke(<span class="built_in">this</span>, args) : <span class="built_in">this</span>.cachedInvoker(method).invoke(proxy, method, args, <span class="built_in">this</span>.sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MapperMethod</li></ul><p>MapperMethod里的excute方法，会真正去执行sql。这里用到了命令模式，其实绕一圈，最终它还是通过SqlSession的实例去运行对象的sql。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> &#123;</span><br><span class="line">      Object result;</span><br><span class="line">      Object param;</span><br><span class="line">      ……</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsVoid() &amp;&amp; <span class="built_in">this</span>.method.hasResultHandler()) &#123;</span><br><span class="line">              <span class="built_in">this</span>.executeWithResultHandler(sqlSession, args);</span><br><span class="line">              result = <span class="literal">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsMany()) &#123;</span><br><span class="line">              result = <span class="built_in">this</span>.executeForMany(sqlSession, args);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsMap()) &#123;</span><br><span class="line">              result = <span class="built_in">this</span>.executeForMap(sqlSession, args);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsCursor()) &#123;</span><br><span class="line">              result = <span class="built_in">this</span>.executeForCursor(sqlSession, args);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              param = <span class="built_in">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">              result = sqlSession.selectOne(<span class="built_in">this</span>.command.getName(), param);</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="literal">null</span> || !<span class="built_in">this</span>.method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">                  result = Optional.ofNullable(result);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">         ……</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="18-Mybatis都有哪些Executor执行器？">18.Mybatis都有哪些Executor执行器？</h3><p><img src="https://s2.loli.net/2023/03/31/NdYBphoTx9lzO5K.png" alt="Mybatis Executor类型"></p><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><ul><li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><blockquote><p><strong>Mybatis中如何指定使用哪一种Executor执行器？</strong></p></blockquote><ul><li>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如<code>SqlSession openSession(ExecutorType execType)</code>。</li><li>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</li></ul><h2 id="插件">插件</h2><h3 id="19-说说Mybatis的插件运行原理，如何编写一个插件？">19. 说说Mybatis的插件运行原理，如何编写一个插件？</h3><blockquote><p><strong>插件的运行原理？</strong></p></blockquote><p>Mybatis会话的运行需要ParameterHandler、ResultSetHandler、StatementHandler、Executor这四大对象的配合，插件的原理就是在这四大对象调度的时候，插入一些我我们自己的代码。</p><p><img src="https://s2.loli.net/2023/03/31/9Me4gh5QBbUOlVv.png" alt="MyBatis插件原理简图"></p><p>Mybatis使用JDK的动态代理，为目标对象生成代理对象。它提供了一个工具类<code>Plugin</code>，实现了<code>InvocationHandler</code>接口。</p><p><img src="https://s2.loli.net/2023/03/31/ptvL1miOrSB83NH.png" alt="Plugin中调用插件方法"></p><p>使用<code>Plugin</code>生成代理对象，代理对象在调用方法的时候，就会进入invoke方法，在invoke方法中，如果存在签名的拦截方法，插件的intercept方法就会在这里被我们调用，然后就返回结果。如果不存在签名方法，那么将直接反射调用我们要执行的方法。</p><blockquote><p><strong>如何编写一个插件？</strong></p></blockquote><p>我们自己编写MyBatis 插件，只需要实现拦截器接口 <code>Interceptor (org.apache.ibatis. plugin Interceptor ）</code>，在实现类中对拦截对象和方法进行处理。</p><ul><li>实现Mybatis的Interceptor接口并重写intercept()方法</li></ul><p>这里我们只是在目标对象执行目标方法的前后进行了打印；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    Properties props=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before……&quot;</span>);</span><br><span class="line">        <span class="comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span></span><br><span class="line">        <span class="comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span></span><br><span class="line">        Object obj=invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;after……&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后再给插件编写注解，确定要拦截的对象，要拦截的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(</span></span><br><span class="line"><span class="meta">        type = Executor.class,  //确定要拦截的对象</span></span><br><span class="line"><span class="meta">        method = &quot;update&quot;,        //确定要拦截的方法</span></span><br><span class="line"><span class="meta">        args = &#123;MappedStatement.class,Object.class&#125;   //拦截方法的参数</span></span><br><span class="line"><span class="meta">)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    Properties props=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before……&quot;</span>);</span><br><span class="line">        <span class="comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span></span><br><span class="line">        <span class="comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span></span><br><span class="line">        Object obj=invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;after……&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后，再MyBatis配置文件里面配置插件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=<span class="string">&quot;xxx.MyPlugin&quot;</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">&quot;dbType&quot;</span>,value=<span class="string">&quot;mysql&quot;</span>/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;    </span><br></pre></td></tr></table></figure><h3 id="20-MyBatis是如何进行分页的？分页插件的原理是什么？">20. MyBatis是如何进行分页的？分页插件的原理是什么？</h3><blockquote><p><strong>MyBatis是如何分页的？</strong></p></blockquote><p>MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><blockquote><p><strong>分页插件的原理是什么？</strong></p></blockquote><ul><li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，拦截Executor的query方法</li><li>在执行查询的时候，拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</li><li>举例：<code>select * from student</code>，拦截sql后重写为：<code>select t.* from (select * from student) t limit 0, 10</code></li></ul><p>可以看一下一个大概的MyBatis通用分页拦截器：</p><p><img src="https://s2.loli.net/2023/03/31/SqXnwORK32i6j5T.png" alt="Mybatis-通用分页拦截器"></p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> mybatis篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统(修正版)</title>
      <link href="/posts/bfedca0c.html"/>
      <url>/posts/bfedca0c.html</url>
      
        <content type="html"><![CDATA[<h2 id="分布式理论">分布式理论</h2><h3 id="1-说说CAP原则？">1. 说说CAP原则？</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）这3个基本需求，最多只能同时满足其中的2个。</p><p><img src="https://s2.loli.net/2023/04/01/wcpOAzRQS49B7eC.png" alt=""></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>Consistency（一致性）</td><td>指数据在多个副本之间能够保持一致的特性（严格的一致性）</td></tr><tr><td>Availability（可用性）</td><td>指系统提供的服务必须一直处于可用的状态，每次请求都能获取到非错的响应（不保证获取的数据为最新数据）</td></tr><tr><td>Partition tolerance（分区容错性）</td><td>分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障</td></tr></tbody></table><h3 id="2-为什么CAP不可兼得呢？">2. 为什么CAP不可兼得呢？</h3><p>首先对于分布式系统，分区是必然存在的，所谓分区指的是分布式系统可能出现的字区域网络不通，成为孤立区域的的情况。</p><p><img src="https://s2.loli.net/2023/04/01/jUZd78cJoptOPMz.png" alt=""></p><p>那么分区容错性（<strong>P</strong>）就必须要满足，因为如果要牺牲分区容错性，就得把服务和资源放到一个机器，或者一个“同生共死”的集群，那就违背了分布式的初衷。</p><p>那么满足分区容错的基础上，能不能同时满足<code>一致性</code>和<code>可用性</code>？</p><p>假如现在有两个分区<code>N1</code>和<code>N2</code>，N1和N2分别有不同的分区存储D1和D2，以及不同的服务S1和S2。</p><ul><li>在满足<code>一致性</code> 的时候，N1和N2的数据要求值一样的，D1=D2。</li><li>在满足<code>可用性</code>的时候，无论访问N1还是N2，都能获取及时的响应。</li></ul><p><img src="https://s2.loli.net/2023/04/01/lQG4Zx1EkMmHenD.png" alt=""></p><p>假如现在有这样的场景：</p><ul><li>用户访问了N1，修改了D1的数据。</li><li>用户再次访问，请求落在了N2。此时D1和D2的数据不一致。</li></ul><p>接下来：</p><ul><li>保证<code>一致性</code>：此时D1和D2数据不一致，要保证一致性就不能返回不一致的数据，<code>可用性</code>无法保证。</li><li>保证<code>可用性</code>：立即响应，可用性得到了保证，但是此时响应的数据和D1不一致，<code>一致性</code>无法保证。</li></ul><p>所以，可以看出，分区容错的前提下，<code>一致性</code>和<code>可用性</code>是矛盾的。</p><h3 id="3-CAP对应的模型和应用？">3. CAP对应的模型和应用？</h3><p><strong>CA without P</strong></p><p>理论上放弃P（分区容错性），则C（强一致性）和A（可用性）是可以保证的。实际上分区是不可避免的，严格上CA指的是允许分区后各子系统依然保持CA。</p><p>CA模型的常见应用：</p><ul><li>集群数据库</li><li>xFS文件系统</li></ul><p><strong>CP without A</strong></p><p>放弃A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。</p><p>CP模型的常见应用：</p><ul><li>分布式数据库</li><li>分布式锁</li></ul><p><strong>AP wihtout C</strong></p><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p><p>AP模型常见应用：</p><ul><li>Web缓存</li><li>DNS</li></ul><p>举个大家更熟悉的例子，像我们熟悉的注册中心<code>ZooKeeper</code>、<code>Eureka</code>、<code>Nacos</code>中：</p><ul><li>ZooKeeper 保证的是 CP</li><li>Eureka 保证的则是 AP</li><li>Nacos 不仅支持 CP 也支持 AP</li></ul><h3 id="4-BASE理论了解吗？">4. BASE理论了解吗？</h3><p>BASE（Basically Available、Soft state、Eventual consistency）是基于CAP理论逐步演化而来的，核心思想是即便不能达到强一致性（Strong consistency），也可以根据应用特点采用适当的方式来达到最终一致性（Eventual consistency）的效果。</p><p><img src="https://s2.loli.net/2023/04/01/PdinBHZmDw6OsEj.png" alt=""></p><p>BASE的主要含义：</p><ul><li><strong>Basically Available（基本可用）</strong></li></ul><p>什么是基本可用呢？假设系统出现了不可预知的故障，但还是能用，只是相比较正常的系统而言，可能会有响应时间上的损失，或者功能上的降级。</p><ul><li><strong>Soft State（软状态）</strong></li></ul><p>什么是硬状态呢？要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>软状态也称为弱状态，相比较硬状态而言，允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><ul><li><strong>Eventually Consistent（最终一致性）</strong></li></ul><p>上面说了软状态，但是不应该一直都是软状态。在一定时间后，应该到达一个最终的状态，保证所有副本保持数据一致性，从而达到数据的最终一致性。这个时间取决于网络延时、系统负载、数据复制方案设计等等因素。</p><h2 id="分布式锁">分布式锁</h2><p>单体时代，可以直接用本地锁来实现对竞争资源的加锁，分布式环境下就要用到分布式锁了。</p><h3 id="5-有哪些分布式锁的实现方案呢？">5. 有哪些分布式锁的实现方案呢？</h3><p>常见的分布式锁实现方案有三种：<code>MySQL分布式锁</code>、<code>ZooKepper分布式锁</code>、<code>Redis分布式锁</code>。</p><p><img src="https://s2.loli.net/2023/04/01/xceiCj7GtLWyMlQ.png" alt=""></p><h4 id="5-1-MySQL分布式锁如何实现呢？">5.1 MySQL分布式锁如何实现呢？</h4><p>用数据库实现分布式锁比较简单，就是创建一张锁表，数据库对字段作唯一性约束。</p><p>加锁的时候，在锁表中增加一条记录即可；释放锁的时候删除记录就行。</p><p>如果有并发请求同时提交到数据库，数据库会保证只有一个请求能够得到锁。</p><p>这种属于数据库 IO 操作，效率不高，而且频繁操作会增大数据库的开销，因此这种方式在高并发、高性能的场景中用的不多。</p><h4 id="5-2-ZooKeeper如何实现分布式锁？">5.2 ZooKeeper如何实现分布式锁？</h4><p>ZooKeeper也是常见分布式锁实现方法。</p><p>ZooKeeper的数据节点和文件目录类似，例如有一个lock节点，在此节点下建立子节点是可以保证先后顺序的，即便是两个进程同时申请新建节点，也会按照先后顺序建立两个节点。</p><p><img src="https://s2.loli.net/2023/04/01/aDGmlHRk2Ofnq7P.png" alt=""></p><p>所以我们可以用此特性实现分布式锁。以某个资源为目录，然后这个目录下面的节点就是我们需要获取锁的客户端，每个服务在目录下创建节点，如果它的节点，序号在目录下最小，那么就获取到锁，否则等待。释放锁，就是删除服务创建的节点。</p><p>ZK实际上是一个比较重的分布式组件，实际上应用没那么多了，所以用ZK实现分布式锁，其实相对也比较少。</p><h4 id="5-3-Redis怎么实现分布式锁？">5.3 Redis怎么实现分布式锁？</h4><p>Redis实现分布式锁，是当前应用最广泛的分布式锁实现方式。</p><p>Redis执行命令是单线程的，Redis实现分布式锁就是利用这个特性。</p><p>实现分布式锁最简单的一个命令：setNx(set if not exist)，如果不存在则更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setNx resourceName value</span><br></pre></td></tr></table></figure><p>加锁了之后如果机器宕机，那我这个锁就无法释放，所以需要加入过期时间，而且过期时间需要和setNx同一个原子操作，在Redis2.8之前需要用lua脚本，但是redis2.8之后redis支持nx和ex操作是同一原子操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set resourceName value ex 5 nx</span><br></pre></td></tr></table></figure><ul><li><strong>Redission</strong></li></ul><p>当然，一般生产中都是使用Redission客户端，非常良好地封装了分布式锁的api，而且支持RedLock。</p><h2 id="分布式事务">分布式事务</h2><h3 id="6-什么是分布式事务">6.什么是分布式事务?</h3><p>分布式事务是相对本地事务而言的，对于本地事务，利用数据库本身的事务机制，就可以保证事务的ACID特性。</p><p><img src="https://s2.loli.net/2023/04/01/UmcKG1jvrSuIRwb.png" alt=""></p><p>而在分布式环境下，会涉及到多个数据库。</p><p><img src="https://s2.loli.net/2023/04/01/nmQjKJvisWS8D9a.png" alt=""></p><p>分布式事务其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。</p><p>分布式事务处理的关键是：</p><ol><li>需要记录事务在任何节点所做的所有动作；</li><li>事务进行的所有操作要么全部提交，要么全部回滚。</li></ol><h3 id="7-分布式事务有哪些常见的实现方案？">7.分布式事务有哪些常见的实现方案？</h3><p>分布式常见的实现方案有 <strong>2PC</strong>、<strong>3PC</strong>、<strong>TCC</strong>、<strong>本地消息表</strong>、<strong>MQ消息事务</strong>、<strong>最大努力通知</strong>、<strong>SAGA事务</strong> 等等。</p><h4 id="7-1-说说2PC两阶段提交？">7.1 说说2PC两阶段提交？</h4><p>说到2PC，就不得先说分布式事务中的 XA 协议。</p><p>在这个协议里，有三个角色：</p><ul><li><strong>AP（Application）</strong>：应用系统（服务）</li><li><strong>TM（Transaction Manager）</strong>：事务管理器（全局事务管理）</li><li><strong>RM（Resource Manager）</strong>：资源管理器（数据库）</li></ul><p><img src="https://s2.loli.net/2023/04/01/BGHXqJrPRsfaod2.png" alt=""></p><p>XA协议采用<strong>两阶段提交</strong>方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。</p><p>两阶段提交的思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况决定各参与者是否要提交操作还是回滚操作。</p><p><img src="https://s2.loli.net/2023/04/01/UGSEF3nluT8MbpL.png" alt=""></p><ul><li>准备阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交</li><li>提交阶段：事务协调器要求每个数据库提交数据，或者回滚数据。</li></ul><p>优点：尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。</p><p>缺点:</p><ul><li>单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li><li>同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li><li>数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li></ul><h4 id="7-2-3PC（三阶段提交）了解吗？">7.2 3PC（三阶段提交）了解吗？</h4><p>三阶段提交（<code>3PC</code>）是二阶段提交（<code>2PC</code>）的一种改进版本 ，为解决两阶段提交协议的单点故障和同步阻塞问题。</p><p>三阶段提交有这么三个阶段：<code>CanCommit</code>，<code>PreCommit</code>，<code>DoCommit</code>三个阶段</p><p><img src="https://s2.loli.net/2023/04/01/A2Xwk9fFpvRyDtg.png" alt=""></p><ul><li><p><strong>CanCommit</strong>：准备阶段。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p></li><li><p><strong>PreCommit</strong>：预提交阶段。协调者根据参与者在<strong>准备阶段</strong>的响应判断是否执行事务还是中断事务，参与者执行完操作之后返回ACK响应，同时开始等待最终指令。</p></li><li><p><strong>DoCommit</strong>：提交阶段。协调者根据参与者在<strong>准备阶段</strong>的响应判断是否执行事务还是中断事务：</p></li><li><p>如果所有参与者都返回正确的<code>ACK</code>响应，则提交事务</p></li><li><p>如果参与者有一个或多个参与者收到错误的<code>ACK</code>响应或者超时，则中断事务</p></li><li><p>如果参与者无法及时接收到来自协调者的提交或者中断事务请求时，在等待超时之后，会继续进行事务提交</p></li></ul><p>可以看出，三阶段提交解决的只是两阶段提交中<strong>单体故障</strong>和<strong>同步阻塞</strong>的问题，因为加入了超时机制，这里的超时的机制作用于 <strong>预提交阶段</strong> 和 <strong>提交阶段</strong>。如果等待 <strong>预提交请求</strong> 超时，参与者直接回到准备阶段之前。如果等到<strong>提交请求</strong>超时，那参与者就会提交事务了。</p><p><strong>无论是2PC还是3PC都不能保证分布式系统中的数据100%一致</strong>。</p><h4 id="7-3-TCC了解吗？">7.3 TCC了解吗？</h4><p><strong>TCC（Try Confirm Cancel）</strong> ，是两阶段提交的一个变种，针对每个操作，都需要有一个其对应的确认和取消操作，当操作成功时调用确认操作，当操作失败时调用取消操作，类似于二阶段提交，只不过是这里的提交和回滚是针对业务上的，所以基于TCC实现的分布式事务也可以看做是对业务的一种补偿机制。</p><p><img src="https://s2.loli.net/2023/04/01/Y4D8rRgVcfdjxQK.png" alt=""></p><ul><li><strong>Try</strong>：尝试待执行的业务。订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于1，然后将可用库存数量设置为库存剩余数量-1，。</li><li><strong>Confirm</strong>：确认执行业务，如果Try阶段执行成功，接着执行Confirm 阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量。</li><li><strong>Cancel</strong>：取消待执行的业务，如果Try阶段执行失败，执行Cancel 阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量。</li></ul><p><strong>TCC</strong> 是业务层面的分布式事务，保证最终一致性，不会一直持有资源的锁。</p><ul><li><strong>优点：</strong> 把数据库层的二阶段提交交给应用层来实现，规避了数据库的 2PC 性能低下问题</li><li><strong>缺点</strong>：TCC 的 Try、Confirm 和 Cancel 操作功能需业务提供，开发成本高。TCC 对业务的侵入较大和业务紧耦合，需要根据特定的场景和业务逻辑来设计相应的操作</li></ul><h4 id="7-4-本地消息表了解吗？">7.4 本地消息表了解吗？</h4><p>本地消息表的核心思想是将分布式事务拆分成本地事务进行处理。</p><p>例如，可以在订单库新增一个消息表，将新增订单和新增消息放到一个事务里完成，然后通过轮询的方式去查询消息表，将消息推送到MQ，库存服务去消费MQ。</p><p><img src="https://s2.loli.net/2023/04/01/QtpHXvBkL2FiDPC.png" alt=""></p><p><strong>执行流程：</strong></p><ol><li>订单服务，添加一条订单和一条消息，在一个事务里提交</li><li>订单服务，使用定时任务轮询查询状态为未同步的消息表，发送到MQ，如果发送失败，就重试发送</li><li>库存服务，接收MQ消息，修改库存表，需要保证幂等操作</li><li>如果修改成功，调用rpc接口修改订单系统消息表的状态为已完成或者直接删除这条消息</li><li>如果修改失败，可以不做处理，等待重试</li></ol><p>订单服务中的消息有可能由于业务问题会一直重复发送，所以为了避免这种情况可以记录一下发送次数，当达到次数限制之后报警，人工接入处理；库存服务需要保证幂等，避免同一条消息被多次消费造成数据不一致。</p><p>本地消息表这种方案实现了最终一致性，需要在业务系统里增加消息表，业务逻辑中多一次插入的DB操作，所以性能会有损耗，而且最终一致性的间隔主要有定时任务的间隔时间决定</p><h4 id="7-5-MQ消息事务了解吗？">7.5 MQ消息事务了解吗？</h4><p>消息事务的原理是<strong>将两个事务通过消息中间件进行异步解耦</strong>。</p><p>订单服务执行自己的本地事务，并发送MQ消息，库存服务接收消息，执行自己的本地事务，乍一看，好像跟本地消息表的实现方案类似，只是省去 了对本地消息表的操作和轮询发送MQ的操作，但实际上两种方案的实现是不一样的。</p><p>消息事务一定要保证业务操作与消息发送的一致性，如果业务操作成功，这条消息也一定投递成功。</p><p><img src="https://s2.loli.net/2023/04/01/qv8FPgUV6TRoG3O.png" alt=""></p><p><strong>执行流程：</strong></p><ol><li>发送prepare消息到消息中间件</li><li>发送成功后，执行本地事务</li><li>如果事务执行成功，则commit，消息中间件将消息下发至消费端</li><li>如果事务执行失败，则回滚，消息中间件将这条prepare消息删除</li><li>消费端接收到消息进行消费，如果消费失败，则不断重试</li></ol><p>消息事务依赖于消息中间件的事务消息，例如我们熟悉的RocketMQ就支持事务消息（半消息），也就是只有收到发送方确定才会正常投递的消息。</p><p>这种方案也是实现了最终一致性，对比本地消息表实现方案，不需要再建消息表，对性能的损耗和业务的入侵更小。</p><h4 id="7-6-最大努力通知了解吗？">7.6 最大努力通知了解吗？</h4><p>最大努力通知相比实现会简单一些，适用于一些对最终一致性实时性要求没那么高的业务，比如支付通知，短信通知。</p><p>以支付通知为例，业务系统调用支付平台进行支付，支付平台进行支付，进行操作支付之后支付平台会去同步通知业务系统支付操作是否成功，如果不成功，会一直异步重试，但是会有一个最大通知次数，如果超过这个次数后还是通知失败，就不再通知，业务系统自行调用支付平台提供一个查询接口，供业务系统进行查询支付操作是否成功。</p><p><img src="https://s2.loli.net/2023/04/01/1e5BDRlNpd7h6vb.png" alt=""></p><p><strong>执行流程：</strong></p><ol><li>业务系统调用支付平台支付接口， 并在本地进行记录，支付状态为支付中</li><li>支付平台进行支付操作之后，无论成功还是失败，同步给业务系统一个结果通知</li><li>如果通知一直失败则根据重试规则异步进行重试，达到最大通知次数后，不再通知</li><li>支付平台提供查询订单支付操作结果接口</li><li>业务系统根据一定业务规则去支付平台查询支付结果</li></ol><h3 id="8-你们用什么？能说一下Seata吗？">8.你们用什么？能说一下Seata吗？</h3><p>我们用比较常用的是Seata——自己去实现分布式事务调度还是比较麻烦的。</p><p><strong>Seata</strong> 的设计目标是对业务无侵入，因此它是从业务无侵入的两阶段提交（全局事务）着手，在传统的两阶段上进行改进，他把一个分布式事务理解成一个包含了若干分支事务的全局事务。而全局事务的职责是协调它管理的分支事务达成一致性，要么一起成功提交，要么一起失败回滚。也就是一荣俱荣一损俱损~</p><p><img src="https://s2.loli.net/2023/04/01/vGlCMeSZnDqcUsH.png" alt=""></p><p><strong>Seata</strong> 中存在这么几种重要角色：</p><ul><li><strong>TC（Transaction Coordinator）</strong>：事务协调者。管理全局的分支事务的状态，用于全局性事务的提交和回滚。</li><li><strong>TM（Transaction Manager）</strong>：事务管理者。用于开启、提交或回滚事务。</li><li><strong>RM（Resource Manager）</strong>：资源管理器。用于分支事务上的资源管理，向 <strong>TC</strong> 注册分支事务，上报分支事务的状态，接收 <strong>TC</strong> 的命令来提交或者回滚分支事务。</li></ul><p><img src="https://s2.loli.net/2023/04/01/8EW3w5OUpdyjAH4.png" alt=""></p><p>S’eata整体执行流程：</p><ol><li>服务A中的 <strong>TM</strong> 向 <strong>TC</strong> 申请开启一个全局事务，<strong>TC</strong> 就会创建一个全局事务并返回一个唯一的 <strong>XID</strong></li><li>服务A中的 <strong>RM</strong> 向 <strong>TC</strong> 注册分支事务，然后将这个分支事务纳入 <strong>XID</strong> 对应的全局事务管辖中</li><li>服务A开始执行分支事务</li><li>服务A开始远程调用B服务，此时 <strong>XID</strong> 会根据调用链传播</li><li>服务B中的 <strong>RM</strong> 也向 <strong>TC</strong> 注册分支事务，然后将这个分支事务纳入 <strong>XID</strong> 对应的全局事务管辖中</li><li>服务B开始执行分支事务</li><li>全局事务调用处理结束后，<strong>TM</strong> 会根据有误异常情况，向 <strong>TC</strong> 发起全局事务的提交或回滚</li><li><strong>TC</strong> 协调其管辖之下的所有分支事务，决定是提交还是回滚</li></ol><h2 id="分布式一致性算法">分布式一致性算法</h2><h3 id="9-分布式算法paxos了解么-？">9.分布式算法paxos了解么 ？</h3><p><code>Paxos</code> 有点类似前面说的 <code>2PC</code>，<code>3PC</code>，但比这两种算法更加完善。在很多多大厂都得到了工程实践，比如阿里的 <code>OceanBase</code> 的 <strong>分布式数据库</strong>， <code>Google</code> 的 <code>chubby</code> <strong>分布式锁</strong> 。</p><h4 id="Paxos算法是什么？">Paxos算法是什么？</h4><p><code>Paxos</code> 算法是 <strong>基于消息传递</strong> 且具有 <strong>高效容错特性</strong> 的一致性算法，目前公认的解决 <strong>分布式一致性问题</strong> 最有效的算法之一。</p><h4 id="Paxos算法的工作流程？">Paxos算法的工作流程？</h4><h5 id="角色">角色</h5><p>在Paxos中有这么几个角色：</p><ol><li><strong>Proposer（提议者）</strong> : 提议者提出提案，用于投票表决。</li><li><strong>Accecptor（接受者）</strong> : 对提案进行投票，并接受达成共识的提案。</li><li><strong>Learner（学习者）</strong> : 被告知投票的结果，接受达成共识的提案。</li></ol><p>在实际中，一个节点可以同时充当不同角色。</p><p><img src="https://s2.loli.net/2023/04/01/aZtbDiHjSodhTAJ.png" alt=""></p><p>提议者提出提案，提案=编号+value，可以表示为[M,V]，每个提案都有唯一编号，而且编号的大小是趋势递增的。</p><h5 id="算法流程">算法流程</h5><p>Paxos算法包含两个阶段，第一阶段 <strong>Prepare(准备)</strong> 、第二阶段 <strong>Accept(接受)</strong> 。</p><p><img src="https://s2.loli.net/2023/04/01/p7neWxAwvqFgsZT.png" alt=""></p><h6 id="Prepare-准备-阶段">Prepare(准备)阶段</h6><ol><li>提议者提议一个新的提案 P[Mn,?]，然后向接受者的某个超过半数的子集成员发送编号为Mn的准备请求</li><li>如果一个接受者收到一个编号为Mn的准备请求，并且编号Mn大于它已经响应的所有准备请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给提议者，同时该接受者会承诺不会再批准任何编号小于Mn的提案。</li></ol><p>总结一下，接受者在收到提案后，会给与提议者<strong>两个承诺</strong>与<strong>一个应答</strong>：</p><ul><li><p>两个承诺：</p></li><li><p>承诺不会再接受提案号小于或等于 Mn 的 Prepare 请求</p></li><li><p>承诺不会再接受提案号小于Mn 的 Accept 请求</p></li><li><p>一个应答：</p></li><li><p>不违背以前作出的承诺的前提下，回复已经通过的提案中提案号最大的那个提案所设定的值和提案号Mmax，如果这个值从来没有被任何提案设定过，则返回空值。如果不满足已经做出的承诺，即收到的提案号并不是决策节点收到过的最大的，那允许直接对此 Prepare 请求不予理会。</p></li></ul><h6 id="Accept-接受-阶段">Accept(接受)阶段</h6><ol><li>如果提议者收到来自半数以上的接受者对于它发出的编号为Mn的准备请求的响应，那么它就会发送一个针对[Mn,Vn]的接受请求给接受者，注意Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它可以随意选定一个值。</li><li>如果接受者收到这个针对[Mn,Vn]提案的接受请求，只要该接受者尚未对编号大于Mn的准备请求做出响应，它就可以通过这个提案。</li></ol><p>当提议者收到了多数接受者的接受应答后，协商结束，共识决议形成，将形成的决议发送给所有学习节点进行学习。</p><p>所以Paxos算法的整体详细流程如下：</p><p><img src="https://s2.loli.net/2023/04/01/tBgwPvQ2ROmE1kL.png" alt=""></p><h4 id="Paxos算法有什么缺点吗？怎么优化？">Paxos算法有什么缺点吗？怎么优化？</h4><p>前面描述的可以称之为Basic Paxos 算法，在单提议者的前提下是没有问题的，但是假如有多个提议者互不相让，那么就可能导致整个提议的过程进入了死循环。</p><p>Lamport 提出了 Multi Paxos 的算法思想。</p><p>Multi Paxos算法思想，简单说就是在多个提议者的情况下，选出一个Leader（领导者），由领导者作为唯一的提议者，这样就可以解决提议者冲突的问题。</p><h3 id="10-说说Raft算法？">10.说说Raft算法？</h3><h4 id="Raft算法是什么？">Raft算法是什么？</h4><p><code>Raft</code> 也是一个 <strong>一致性算法</strong>，和 <code>Paxos</code> 目标相同。但它还有另一个名字 - <strong>易于理解的一致性算法</strong>。<code>Paxos</code> 和 <code>Raft</code> 都是为了实现 <strong>一致性</strong> 产生的。这个过程如同选举一样，<strong>参选者</strong> 需要说服 <strong>大多数选民</strong> (Server) 投票给他，一旦选定后就跟随其操作。<code>Paxos</code> 和 <code>Raft</code> 的区别在于选举的 <strong>具体过程</strong> 不同。</p><h4 id="Raft算法的工作流程？">Raft算法的工作流程？</h4><h5 id="Raft算法的角色">Raft算法的角色</h5><p><code>Raft</code> 协议将 <code>Server</code> 进程分为三种角色：</p><ul><li><strong>Leader（领导者）</strong></li><li><strong>Follower（跟随者）</strong></li><li><strong>Candidate（候选人）</strong></li></ul><p>就像一个民主社会，领导者由跟随者投票选出。刚开始没有 <strong>领导者</strong>，所有集群中的 <strong>参与者</strong> 都是 <strong>跟随者</strong>。</p><p>那么首先开启一轮大选。在大选期间 <strong>所有跟随者</strong> 都能参与竞选，这时所有跟随者的角色就变成了 <strong>候选人</strong>，民主投票选出领袖后就开始了这届领袖的任期，然后选举结束，所有除 <strong>领导者</strong> 的 <strong>候选人</strong> 又变回 <strong>跟随者</strong> 服从领导者领导。</p><p>这里提到一个概念 <strong>「任期」</strong>，用术语 <code>Term</code> 表达。</p><p>三类角色的变迁图如下：</p><p><img src="https://s2.loli.net/2023/04/01/xC3VBDE98pwsSAr.png" alt=""></p><h5 id="Leader选举过程">Leader选举过程</h5><p>Raft 使用心跳（heartbeat）触发Leader选举。当Server启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p><p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC 。结果有以下三种情况：</p><ul><li>赢得了多数（超过1/2）的选票，成功选举为Leader；</li><li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li><li>没有Server赢得多数的选票，Leader选举失败，等待选举时间超时（<code>Election Timeout</code>）后发起下一次选举。</li></ul><p><img src="https://s2.loli.net/2023/04/01/YFVkiLwBJ4yzXHO.png" alt=""></p><p>选出 <code>Leader</code> 后，<code>Leader</code> 通过 <strong>定期</strong> 向所有 <code>Follower</code> 发送 <strong>心跳信息</strong> 维持其统治。若 <code>Follower</code> 一段时间未收到 <code>Leader</code> 的 <strong>心跳</strong>，则认为 <code>Leader</code> 可能已经挂了，然后再次发起 <strong>选举</strong> 过程。</p><h2 id="分布式设计">分布式设计</h2><h3 id="11-说说什么是幂等性？">11.说说什么是幂等性？</h3><blockquote><p>什么是幂等性？</p></blockquote><p>幂等性是一个数学概念，用在接口上：用在接口上就可以理解为：<strong>同一个接口，多次发出同一个请求，请求的结果是一致的。</strong></p><p>简单说，就是多次调用如一次。</p><blockquote><p>什么是幂等性问题？</p></blockquote><p>在系统的运行中，可能会出现这样的问题：</p><ol><li>用户在填写某些<code>form表单</code>时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。</li><li>开发人员在项目中为了解决<code>接口超时</code>问题，通常会引入了<code>重试机制</code>。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），于是会对该请求重试几次，这样也会产生重复的数据。</li><li>mq消费者在读取消息时，有时候会读取到<code>重复消息</code>，也会产生重复的数据。</li></ol><p>这些都是常见的幂等性问题。</p><p>在分布式系统里，只要下游服务有写（保存、更新）的操作，都有可能会产生幂等性问题。</p><p>PS:幂等和防重有些不同，防重强调的防止数据重复，幂等强调的是多次调用如一次，防重包含幂等。</p><h3 id="怎么保证接口幂等性？">怎么保证接口幂等性？</h3><p><img src="https://s2.loli.net/2023/04/01/6wB45Do92d3gRuP.png" alt=""></p><ol><li>insert前先select</li></ol><p>在保存数据的接口中，在<code>insert</code>前，先根据<code>requestId</code>等字段先<code>select</code>一下数据。如果该数据已存在，则直接返回，如果不存在，才执行  <code>insert</code>操作。</p><ol start="2"><li>加唯一索引</li></ol><p>加唯一索引是个非常简单但很有效的办法，如果重复插入数据的话，就会抛出异常，为了保证幂等性，一般需要捕获这个异常。</p><p>如果是<code>java</code>程序需要捕获：<code>DuplicateKeyException</code>异常，如果使用了<code>spring</code>框架还需要捕获：<code>MySQLIntegrityConstraintViolationException</code>异常。</p><ol start="3"><li>加悲观锁</li></ol><p>更新逻辑，比如更新用户账户余额，可以加悲观锁，把对应用户的哪一行数据锁住。同一时刻只允许一个请求获得锁，其他请求则等待。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user id=123 for update;</span><br></pre></td></tr></table></figure><p>这种方式有一个缺点，获取不到锁的请求一般只能报失败，比较难保证接口返回相同值。</p><ol start="4"><li>加乐观锁</li></ol><p>更新逻辑，也可以用乐观锁，性能更好。可以在表中增加一个<code>timestamp</code>或者<code>version</code>字段，例如<code>version</code>:</p><p>在更新前，先查询一下数据，将version也作为更新的条件，同时也更新version：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set amount=amount+100,version=version+1 where id=123 and version=1;</span><br></pre></td></tr></table></figure><p>更新成功后，version增加，重复更新请求进来就无法更新了。</p><ol start="5"><li>建防重表</li></ol><p>有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，就可以使用防重表的方式。</p><p>例如消息消费中，创建防重表，存储消息的唯一ID，消费时先去查询是否已经消费，已经消费直接返回成功。</p><ol start="6"><li>状态机</li></ol><p>有些业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态，可以通过限制状态的流动来完成幂等。</p><ol start="7"><li>分布式锁</li></ol><p>直接在数据库上加锁的做法性能不够友好，可以使用分布式锁的方式，目前最流行的分布式锁实现是通过Redis，具体实现一般都是使用Redission框架。</p><ol start="8"><li>token机制</li></ol><p>请求接口之前，需要先获取一个唯一的token，再带着这个token去完成业务操作，服务端根据这个token是否存在，来判断是否是重复的请求。</p><h2 id="分布式限流">分布式限流</h2><h3 id="12-你了解哪些限流算法？">12.你了解哪些限流算法？</h3><ul><li>计数器</li></ul><p>计数器比较简单粗暴，比如我们要限制1s能够通过的请求数，实现的思路就是从第一个请求进来开始计时，在接下来的1s内，每个请求进来请求数就+1，超过最大请求数的请求会被拒绝，等到1s结束后计数清零，重新开始计数。</p><p>这种方式有个很大的弊端：比如前10ms已经通过了最大的请求数，那么后面的990ms的请求只能拒绝，这种现象叫做“突刺现象”。</p><ul><li>漏桶算法</li></ul><p>就是桶底出水的速度恒定，进水的速度可能快慢不一，但是当进水量大于出水量的时候，水会被装在桶里，不会直接被丢弃；但是桶也是有容量限制的，当桶装满水后溢出的部分还是会被丢弃的。</p><p><strong>算法实现</strong>：可以准备一个队列来保存暂时处理不了的请求，然后通过一个线程池定期从队列中获取请求来执行。</p><p><img src="https://s2.loli.net/2023/04/01/GsULYpKNJOxjRwv.png" alt=""></p><ul><li>令牌桶算法</li></ul><p>令牌桶就是生产访问令牌的一个地方，生产的速度恒定，用户访问的时候当桶中有令牌时就可以访问，否则将触发限流。</p><p><strong>实现方案</strong>：Guava RateLimiter限流</p><p>Guava RateLimiter是一个谷歌提供的限流，其基于令牌桶算法，比较适用于单实例的系统。</p><p><img src="https://s2.loli.net/2023/04/01/f7v4VpnDNYGRA38.png" alt=""></p><p>这一期的分布式面试题就整理到这里了，主要是偏理论的一些问题，分布式其实是个很大的类型，比如分布式调用、分布式治理……</p><p>所以，这篇文章只是个开始，后面还会有分布式调用（RPC）、微服务相关的主题文章，敬请期待。</p><hr>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq篇(修正版)</title>
      <link href="/posts/81f1d6e8.html"/>
      <url>/posts/81f1d6e8.html</url>
      
        <content type="html"><![CDATA[<a class="btn-beautify blue inline" href="https://www.aliyundrive.com/s/PMeQ22zKD1z"   title="点击获取《RocketMq大白话讲解》" target="_blank"><span>点击获取《RocketMq大白话讲解》</span></a><h2 id="基础">基础</h2><h3 id="1-为什么要使用消息队列呢？">1.为什么要使用消息队列呢？</h3><p>消息队列主要有三大用途，我们拿一个电商系统的下单举例：</p><ul><li><strong>解耦</strong>：引入消息队列之前，下单完成之后，需要订单服务去调用库存服务减库存，调用营销服务加营销数据……引入消息队列之后，可以把订单完成的消息丢进队列里，下游服务自己去调用就行了，这样就完成了订单服务和其它服务的解耦合。</li></ul><p><img src="https://s2.loli.net/2023/04/01/yCl64HImVEn1hXD.png" alt="消息队列解耦"></p><ul><li><strong>异步</strong>：订单支付之后，我们要扣减库存、增加积分、发送消息等等，这样一来这个链路就长了，链路一长，响应时间就变长了。引入消息队列，除了<code>更新订单状态</code>，其它的都可以<strong>异步</strong>去做，这样一来就来，就能降低响应时间。</li></ul><p><img src="https://s2.loli.net/2023/04/01/gLmDGlsy1w64TNk.png" alt="消息队列异步"></p><ul><li><strong>削峰</strong>：消息队列合一用来削峰，例如秒杀系统，平时流量很低，但是要做秒杀活动，秒杀的时候流量疯狂怼进来，我们的服务器，Redis，MySQL各自的承受能力都不一样，直接全部流量照单全收肯定有问题啊，严重点可能直接打挂了。</li></ul><p>我们可以把请求扔到队列里面，只放出我们服务能处理的流量，这样就能抗住短时间的大流量了。</p><p><img src="https://s2.loli.net/2023/04/01/uOQGtqh1bwsEzLN.png" alt="消息队列削峰"></p><p>解耦、异步、削峰，是消息队列最主要的三大作用。</p><h3 id="2-为什么要选择RocketMQ">2.为什么要选择RocketMQ?</h3><p>市场上几大消息队列对比如下：</p><p><img src="https://s2.loli.net/2023/04/01/ZrPKgweI4dsTmA2.png" alt="四大消息队列对比"></p><p><strong>总结一下</strong>：</p><p>选择中间件的可以从这些维度来考虑：可靠性，性能，功能，可运维行，可拓展性，社区活跃度。目前常用的几个中间件，ActiveMQ作为“老古董”，市面上用的已经不多，其它几种：</p><ul><li><p>RabbitMQ：</p></li><li><p>优点：轻量，迅捷，容易部署和使用，拥有灵活的路由配置</p></li><li><p>缺点：性能和吞吐量不太理想，不易进行二次开发</p></li><li><p>RocketMQ：</p></li><li><p>优点：性能好，高吞吐量，稳定可靠，有活跃的中文社区</p></li><li><p>缺点：兼容性上不是太好</p></li><li><p>Kafka：</p></li><li><p>优点：拥有强大的性能及吞吐量，兼容性很好</p></li><li><p>缺点：由于“攒一波再处理”导致延迟比较高</p></li></ul><p>我们的系统是面向用户的C端系统，具有一定的并发量，对性能也有比较高的要求，所以选择了低延迟、吞吐量比较高，可用性比较好的RocketMQ。</p><h3 id="3-RocketMQ有什么优缺点？">3.RocketMQ有什么优缺点？</h3><p>RocketMQ优点：</p><ul><li>单机吞吐量：十万级</li><li>可用性：非常高，分布式架构</li><li>消息可靠性：经过参数优化配置，消息可以做到0丢失</li><li>功能支持：MQ功能较为完善，还是分布式的，扩展性好</li><li>支持10亿级别的消息堆积，不会因为堆积导致性能下降</li><li>源码是Java，方便结合公司自己的业务二次开发</li><li>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况</li><li><strong>RoketMQ</strong>在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择<strong>RocketMQ</strong></li></ul><p>RocketMQ缺点：</p><ul><li>支持的客户端语言不多，目前是Java及c++，其中c++不成熟</li><li>没有在 MQ核心中去实现<strong>JMS</strong>等接口，有些系统要迁移需要修改大量代码</li></ul><h3 id="4-消息队列有哪些消息模型？">4.消息队列有哪些消息模型？</h3><p>消息队列有两种模型：<strong>队列模型</strong>和<strong>发布/订阅模型</strong>。</p><ul><li><strong>队列模型</strong></li></ul><p>这是最初的一种消息队列模型，对应着消息队列“发-存-收”的模型。生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，也就是说每条消息只能被一个消费者消费。</p><p><img src="https://s2.loli.net/2023/04/01/OiK1j6gBwaRkZHN.png" alt="队列模型"></p><ul><li><strong>发布/订阅模型</strong></li></ul><p>如果需要将一份消息数据分发给多个消费者，并且每个消费者都要求收到全量的消息。很显然，队列模型无法满足这个需求。解决的方式就是发布/订阅模型。</p><p>在发布 - 订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。</p><p><img src="https://s2.loli.net/2023/04/01/6w7WEB35zd4QOXg.png" alt="发布-订阅模型"></p><p>它和 “队列模式” 的异同：生产者就是发布者，队列就是主题，消费者就是订阅者，无本质区别。唯一的不同点在于：一份消息数据是否可以被多次消费。</p><h3 id="5-那RocketMQ的消息模型呢？">5.那RocketMQ的消息模型呢？</h3><p>RocketMQ使用的消息模型是标准的发布-订阅模型，在RocketMQ的术语表中，生产者、消费者和主题，与发布-订阅模型中的概念是完全一样的。</p><p>RocketMQ本身的消息是由下面几部分组成：</p><p><img src="https://s2.loli.net/2023/04/01/zyfpEKXqwlH5g1i.png" alt="RocketMQ消息的组成"></p><ul><li><strong>Message</strong></li></ul><p>​<strong>Message</strong>（消息）就是要传输的信息。</p><p>​一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。</p><p>​一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 Key 并在 Broker 上查找此消息以便在开发期间查找问题。</p><ul><li><strong>Topic</strong></li></ul><p>​<strong>Topic</strong>（主题）可以看做消息的归类，它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。</p><p>​<strong>Topic</strong> 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。</p><p>​一个 Topic 也可以被 0个、1个、多个消费者订阅。</p><ul><li><strong>Tag</strong>：<strong>Tag</strong>（标签）可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息。就可以用相同 Topic 而不同的 <strong>Tag</strong> 来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 <strong>Tag</strong> 。</li></ul><p>​标签有助于保持你的代码干净和连贯，并且还可以为 <strong>RocketMQ</strong> 提供的查询系统提供帮助。</p><ul><li><p><strong>Group</strong>：RocketMQ中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被Consumer Group1消费过，也会再给Consumer Group2消费。消费组中包含多个消费者，同一个组内的消费者是竞争消费的关系，每个消费者负责消费组内的一部分消息。默认情况，如果一条消息被消费者Consumer1消费了，那同组的其他消费者就不会再收到这条消息。</p></li><li><p><strong>Message Queue</strong>：<strong>Message Queue</strong>（消息队列），一个 Topic 下可以设置多个消息队列，Topic 包括多个 Message Queue ，如果一个 Consumer 需要获取 Topic下所有的消息，就要遍历所有的 Message Queue。RocketMQ还有一些其它的Queue——例如ConsumerQueue。</p></li><li><p><strong>Offset</strong>：在Topic的消费过程中，由于消息需要被不同的组进行多次消费，所以消费完的消息并不会立即被删除，这就需要RocketMQ为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。也可以这么说，<code>Queue</code> 是一个长度无限的数组，<strong>Offset</strong> 就是下标。</p></li></ul><p>RocketMQ的消息模型中，这些就是比较关键的概念了。画张图总结一下：</p><p><img src="https://s2.loli.net/2023/04/01/wSIyEOa7nckHFB6.png" alt=""></p><h3 id="6-消息的消费模式了解吗？">6.消息的消费模式了解吗？</h3><p>消息消费模式有两种：<strong>Clustering</strong>（集群消费）和<strong>Broadcasting</strong>（广播消费）。</p><p><img src="https://s2.loli.net/2023/04/01/YfLtu2lKQrhATH9.png" alt="两种消费模式"></p><p>默认情况下就是集群消费，这种模式下<code>一个消费者组共同消费一个主题的多个队列，一个队列只会被一个消费者消费</code>，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p><p>而广播消费消息会发给消费者组中的每一个消费者进行消费。</p><h3 id="7-RoctetMQ基本架构了解吗？">7.RoctetMQ基本架构了解吗？</h3><p>先看图，RocketMQ的基本架构：</p><p><img src="https://s2.loli.net/2023/04/01/rDth1Tsv5wFUKSl.png" alt="RocketMQ架构"></p><p>RocketMQ 一共有四个部分组成：NameServer，Broker，Producer 生产者，Consumer 消费者，它们对应了：发现、发、存、收，为了保证高可用，一般每一部分都是集群部署的。</p><h3 id="8-那能介绍一下这四部分吗？">8.那能介绍一下这四部分吗？</h3><p>类比一下我们生活的邮政系统——</p><p>邮政系统要正常运行，离不开下面这四个角色， 一是发信者，二 是收信者， 三是负责暂存传输的邮局， 四是负责协调各个地方邮局的管理机构。对应到 RocketMQ 中，这四个角色就是 Producer、 Consumer、 Broker 、NameServer。</p><p><img src="https://s2.loli.net/2023/04/01/NSfU4VOp1nXbQ3A.png" alt="RocketMQ类比邮政体系"></p><h4 id="NameServer">NameServer</h4><p>NameServer 是一个无状态的服务器，角色类似于 Kafka使用的 Zookeeper，但比 Zookeeper 更轻量。</p><p>特点：</p><ul><li>每个 NameServer 结点之间是相互独立，彼此没有任何信息交互。</li><li>Nameserver 被设计成几乎是无状态的，通过部署多个结点来标识自己是一个伪集群，Producer 在发送消息前从 NameServer 中获取 Topic 的路由信息也就是发往哪个 Broker，Consumer 也会定时从 NameServer 获取 Topic 的路由信息，Broker 在启动时会向 NameServer 注册，并定时进行心跳连接，且定时同步维护的 Topic 到 NameServer。</li></ul><p>功能主要有两个：</p><ul><li>1、和Broker 结点保持长连接。</li><li>2、维护 Topic 的路由信息。</li></ul><h4 id="Broker">Broker</h4><p>消息存储和中转角色，负责存储和转发消息。</p><ul><li>Broker 内部维护着一个个 Consumer Queue，用来存储消息的索引，真正存储消息的地方是 CommitLog（日志文件）。</li></ul><p><img src="https://s2.loli.net/2023/04/01/cf24JrYQMukwSUl.png" alt="RocketMQ存储-图片来源官网"></p><ul><li>单个 Broker 与所有的 Nameserver 保持着长连接和心跳，并会定时将 Topic 信息同步到 NameServer，和 NameServer 的通信底层是通过 Netty 实现的。</li></ul><h4 id="Producer">Producer</h4><p>消息生产者，业务端负责发送消息，由用户自行实现和分布式部署。</p><ul><li><p><strong>Producer</strong>由用户进行分布式部署，消息由<strong>Producer</strong>通过多种负载均衡模式发送到<strong>Broker</strong>集群，发送低延时，支持快速失败。</p></li><li><p><strong>RocketMQ</strong> 提供了三种方式发送消息：同步、异步和单向</p></li><li><p><strong>同步发送</strong>：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</p></li><li><p><strong>异步发送</strong>：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</p></li><li><p><strong>单向发送</strong>：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</p></li></ul><h4 id="Consumer">Consumer</h4><p>消息消费者，负责消费消息，一般是后台系统负责异步消费。</p><ul><li><strong>Consumer</strong>也由用户部署，支持PUSH和PULL两种消费模式，支持<strong>集群消费</strong>和<strong>广播消费</strong>，提供<strong>实时的消息订阅机制</strong>。</li><li><strong>Pull</strong>：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</li><li><strong>Push</strong>：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但其实从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</li></ul><h2 id="进阶">进阶</h2><h3 id="9-如何保证消息的可用性-可靠性-不丢失呢？">9.如何保证消息的可用性/可靠性/不丢失呢？</h3><p>消息可能在哪些阶段丢失呢？可能会在这三个阶段发生丢失：生产阶段、存储阶段、消费阶段。</p><p>所以要从这三个阶段考虑：</p><p><img src="https://s2.loli.net/2023/04/01/27YJhAldxXrb145.png" alt="消息传递三阶段"></p><h4 id="生产">生产</h4><p>在生产阶段，主要<strong>通过请求确认机制，来保证消息的可靠传递</strong>。</p><ul><li>1、同步发送的时候，要注意处理响应结果和异常。如果返回响应OK，表示消息成功发送到了Broker，如果响应失败，或者发生其它异常，都应该重试。</li><li>2、异步发送的时候，应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。</li><li>3、如果发生超时的情况，也可以通过查询日志的API，来检查是否在Broker存储成功。</li></ul><h4 id="存储">存储</h4><p>存储阶段，可以通过<strong>配置可靠性优先的 Broker 参数来避免因为宕机丢消息</strong>，简单说就是可靠性优先的场景都应该使用同步。</p><ul><li>1、消息只要持久化到CommitLog（日志文件）中，即使Broker宕机，未消费的消息也能重新恢复再消费。</li><li>2、Broker的刷盘机制：同步刷盘和异步刷盘，不管哪种刷盘都可以保证消息一定存储在pagecache中（内存中），但是同步刷盘更可靠，它是Producer发送消息后等数据持久化到磁盘之后再返回响应给Producer。</li></ul><p><img src="https://s2.loli.net/2023/04/01/8g5HliIK7Nach4z.png" alt="同步刷盘和异步刷盘-图片来源官网"></p><ul><li>3、Broker通过主从模式来保证高可用，Broker支持Master和Slave同步复制、Master和Slave异步复制模式，生产者的消息都是发送给Master，但是消费既可以从Master消费，也可以从Slave消费。同步复制模式可以保证即使Master宕机，消息肯定在Slave中有备份，保证了消息不会丢失。</li></ul><h4 id="消费">消费</h4><p>从Consumer角度分析，如何保证消息被成功消费？</p><ul><li>Consumer保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。因为消息队列维护了消费的位置，逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。</li></ul><h3 id="10-如何处理消息重复的问题呢？">10.如何处理消息重复的问题呢？</h3><p>对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的，就是所谓的“有且仅有一次” 。RocketMQ择了确保一定投递，保证消息不丢失，但有可能造成消息重复。</p><p>处理消息重复问题，主要有业务端自己保证，主要的方式有两种：<strong>业务幂等</strong>和<strong>消息去重</strong>。</p><p><img src="https://s2.loli.net/2023/04/01/synKP8prH3hXc4z.png" alt="消息重复处理"></p><p><strong>业务幂等</strong>：第一种是保证消费逻辑的幂等性，也就是多次调用和一次调用的效果是一样的。这样一来，不管消息消费多少次，对业务都没有影响。</p><p><strong>消息去重</strong>：第二种是业务端，对重复的消息就不再消费了。这种方法，需要保证每条消息都有一个惟一的编号，通常是业务相关的，比如订单号，消费的记录需要落库，而且需要保证和消息确认这一步的原子性。</p><p>具体做法是可以建立一个消费记录表，拿到这个消息做数据库的insert操作。给这个消息做一个唯一主键（primary key）或者唯一约束，那么就算出现重复消费的情况，就会导致主键冲突，那么就不再处理这条消息。</p><h3 id="11-怎么处理消息积压？">11.怎么处理消息积压？</h3><p>发生了消息积压，这时候就得想办法赶紧把积压的消息消费完，就得考虑提高消费能力，一般有两种办法：</p><p><img src="https://s2.loli.net/2023/04/01/TAQNmLSOfohgctX.png" alt="消息积压处理"></p><ul><li><strong>消费者扩容</strong>：如果当前Topic的Message Queue的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力，尽快把积压的消息消费玩。</li><li><strong>消息迁移Queue扩容</strong>：如果当前Topic的Message Queue的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容Message Queue。可以新建一个临时的Topic，临时的Topic多设置一些Message Queue，然后先用一些消费者把消费的数据丢到临时的Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的Topic里的数据，消费完了之后，恢复原状。</li></ul><p><img src="https://s2.loli.net/2023/04/01/8JuIhRAT1va5fnp.png" alt="消息迁移扩容消费"></p><h3 id="12-顺序消息如何实现？">12.顺序消息如何实现？</h3><p>顺序消息是指消息的消费顺序和产生顺序相同，在有些业务逻辑下，必须保证顺序，比如订单的生成、付款、发货，这个消息必须按顺序处理才行。</p><p><img src="https://s2.loli.net/2023/04/01/2jl5K9LFQ3GkaDg.png" alt="顺序消息"></p><p>顺序消息分为全局顺序消息和部分顺序消息，全局顺序消息指某个 Topic 下的所有消息都要保证顺序；</p><p>部分顺序消息只要保证每一组消息被顺序消费即可，比如订单消息，只要保证同一个订单 ID 个消息能按顺序消费即可。</p><h4 id="部分顺序消息">部分顺序消息</h4><p>部分顺序消息相对比较好实现，生产端需要做到把同 ID 的消息发送到同一个 Message Queue ；在消费过程中，要做到从同一个Message Queue读取的消息顺序处理——消费端不能并发处理顺序消息，这样才能达到部分有序。</p><p><img src="https://s2.loli.net/2023/04/01/gS5C3cqYeFoARk9.png" alt="部分顺序消息"></p><p>发送端使用 MessageQueueSelector 类来控制 把消息发往哪个 Message Queue 。</p><p><img src="https://s2.loli.net/2023/04/01/Q4d2oOMqtcHe3S7.png" alt="顺序消息生产-例子来源官方"></p><p>消费端通过使用 MessageListenerOrderly 来解决单 Message Queue 的消息被并发处理的问题。</p><p><img src="https://s2.loli.net/2023/04/01/tA8kNGRF1vsuTDo.png" alt=""></p><h4 id="全局顺序消息">全局顺序消息</h4><p>RocketMQ 默认情况下不保证顺序，比如创建一个 Topic ，默认八个写队列，八个读队列，这时候一条消息可能被写入任意一个队列里；在数据的读取过程中，可能有多个 Consumer ，每个 Consumer 也可能启动多个线程并行处理，所以消息被哪个 Consumer 消费，被消费的顺序和写人的顺序是否一致是不确定的。</p><p>要保证全局顺序消息， 需要先把 Topic 的读写队列数设置为 一，然后Producer Consumer 的并发设置，也要是一。简单来说，为了保证整个 Topic全局消息有序，只能消除所有的并发处理，各部分都设置成单线程处理 ，这时候就完全牺牲RocketMQ的高并发、高吞吐的特性了。</p><p><img src="https://s2.loli.net/2023/04/01/T5MxZ6Q8zbONcLE.png" alt="全局顺序消息"></p><h3 id="13-如何实现消息过滤？">13.如何实现消息过滤？</h3><p>有两种方案：</p><ul><li>一种是在 Broker 端按照 Consumer 的去重逻辑进行过滤，这样做的好处是避免了无用的消息传输到 Consumer 端，缺点是加重了 Broker 的负担，实现起来相对复杂。</li><li>另一种是在 Consumer 端过滤，比如按照消息设置的 tag 去重，这样的好处是实现起来简单，缺点是有大量无用的消息到达了 Consumer 端只能丢弃不处理。</li></ul><p>一般采用Cosumer端过滤，如果希望提高吞吐量，可以采用Broker过滤。</p><p>对消息的过滤有三种方式：</p><p><img src="https://s2.loli.net/2023/04/01/BVsSu7qK9lc5Ujz.png" alt="消息过滤"></p><ul><li>根据Tag过滤：这是最常见的一种，用起来高效简单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;CID_EXAMPLE&quot;);</span><br><span class="line">consumer.subscribe(&quot;TOPIC&quot;, &quot;TAGA || TAGB || TAGC&quot;);</span><br></pre></td></tr></table></figure><ul><li>SQL 表达式过滤：SQL表达式过滤更加灵活</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;);</span><br><span class="line">// 只有订阅的消息有这个属性a, a &gt;=0 and a &lt;= 3</span><br><span class="line">consumer.subscribe(&quot;TopicTest&quot;, MessageSelector.bySql(&quot;a between 0 and 3&quot;);</span><br><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">       return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Filter Server 方式：最灵活，也是最复杂的一种方式，允许用户自定义函数进行过滤</li></ul><h3 id="14-延时消息了解吗？">14.延时消息了解吗？</h3><p>电商的订单超时自动取消，就是一个典型的利用延时消息的例子，用户提交了一个订单，就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p><p>RocketMQ是支持延时消息的，只需要在生产消息的时候设置消息的延时级别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 实例化一个生产者来产生延时消息</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;ExampleProducerGroup&quot;);</span><br><span class="line">// 启动生产者</span><br><span class="line">producer.start();</span><br><span class="line">int totalMessagesToSend = 100;</span><br><span class="line">for (int i = 0; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">    Message message = new Message(&quot;TestTopic&quot;, (&quot;Hello scheduled message &quot; + i).getBytes());</span><br><span class="line">    // 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span><br><span class="line">    message.setDelayTimeLevel(3);</span><br><span class="line">    // 发送消息</span><br><span class="line">    producer.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前RocketMQ支持的延时级别是有限的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</span><br></pre></td></tr></table></figure><h4 id="RocketMQ怎么实现延时消息的？">RocketMQ怎么实现延时消息的？</h4><p>简单，八个字：<code>临时存储</code>+<code>定时任务</code>。</p><p>Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。</p><p><img src="https://s2.loli.net/2023/04/01/1k5HRErDfYhyPv8.jpg" alt="延迟消息处理流程-图片来源见水印"></p><h3 id="15-怎么实现分布式消息事务的？半消息？">15.怎么实现分布式消息事务的？半消息？</h3><p>半消息：是指暂时还不能被 Consumer 消费的消息，Producer 成功发送到 Broker 端的消息，但是此消息被标记为 “暂不可投递” 状态，只有等 Producer 端执行完本地事务后经过二次确认了之后，Consumer 才能消费此条消息。</p><p>依赖半消息，可以实现分布式消息事务，其中的关键在于二次确认以及消息回查：</p><p><img src="https://s2.loli.net/2023/04/01/7tpA5W6Towia9vH.png" alt="RocketMQ实现消息事务"></p><ul><li>1、Producer 向 broker 发送半消息</li><li>2、Producer 端收到响应，消息发送成功，此时消息是半消息，标记为 “不可投递” 状态，Consumer 消费不了。</li><li>3、Producer 端执行本地事务。</li><li>4、正常情况本地事务执行完成，Producer 向 Broker 发送 Commit/Rollback，如果是 Commit，Broker 端将半消息标记为正常消息，Consumer 可以消费，如果是 Rollback，Broker 丢弃此消息。</li><li>5、异常情况，Broker 端迟迟等不到二次确认。在一定时间后，会查询所有的半消息，然后到 Producer 端查询半消息的执行情况。</li><li>6、Producer 端查询本地事务的状态</li><li>7、根据事务的状态提交 commit/rollback 到 broker 端。（5，6，7 是消息回查）</li><li>8、消费者段消费到消息之后，执行本地事务，执行本地事务。</li></ul><h3 id="16-死信队列知道吗？">16.死信队列知道吗？</h3><p>死信队列用于处理无法被正常消费的消息，即死信消息。</p><p>当一条消息初次消费失败，<strong>消息队列 RocketMQ 会自动进行消息重试</strong>；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该<strong>消费者对应的特殊队列中</strong>，该特殊队列称为<strong>死信队列</strong>。</p><p><strong>死信消息的特点</strong>：</p><ul><li>不会再被消费者正常消费。</li><li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，需要在死信消息产生后的 3 天内及时处理。</li></ul><p><strong>死信队列的特点</strong>：</p><ul><li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li><li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li><li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li></ul><p>RocketMQ 控制台提供对死信消息的查询、导出和重发的功能。</p><h3 id="17-如何保证RocketMQ的高可用？">17.如何保证RocketMQ的高可用？</h3><p>NameServer因为是无状态，且不相互通信的，所以只要集群部署就可以保证高可用。</p><p><img src="https://s2.loli.net/2023/04/01/M6hiubtxfg5Udse.png" alt="NameServer集群"></p><p>RocketMQ的高可用主要是在体现在Broker的读和写的高可用，Broker的高可用是通过<code>集群</code>和<code>主从</code>实现的。</p><p><img src="https://s2.loli.net/2023/04/01/DxlbUROHJFIfsk5.png" alt="Broker集群、主从示意图"></p><p>Broker可以配置两种角色：Master和Slave，Master角色的Broker支持读和写，Slave角色的Broker只支持读，Master会向Slave同步消息。</p><p>也就是说Producer只能向Master角色的Broker写入消息，Cosumer可以从Master和Slave角色的Broker读取消息。</p><p>Consumer 的配置文件中，并不需要设置是从 Master 读还是从 Slave读，当 Master 不可用或者繁忙的时候， Consumer 的读请求会被自动切换到从 Slave。有了自动切换 Consumer 这种机制，当一个 Master 角色的机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 读取消息，这就实现了读的高可用。</p><p>如何达到发送端写的高可用性呢？在创建 Topic 的时候，把 Topic 的多个Message Queue 创建在多个 Broker 组上（相同 Broker 名称，不同 brokerId机器组成 Broker 组），这样当 Broker 组的 Master 不可用后，其他组Master 仍然可用， Producer 仍然可以发送消息 RocketMQ 目前还不支持把Slave自动转成 Master ，如果机器资源不足，需要把 Slave 转成 Master ，则要手动停止 Slave 色的 Broker ，更改配置文件，用新的配置文件启动 Broker。</p><h2 id="原理">原理</h2><h3 id="18-说一下RocketMQ的整体工作流程？">18.说一下RocketMQ的整体工作流程？</h3><p>简单来说，RocketMQ是一个分布式消息队列，也就是<code>消息队列</code>+<code>分布式系统</code>。</p><p>作为消息队列，它是<code>发</code>-<code>存</code>-<code>收</code>的一个模型，对应的就是Producer、Broker、Cosumer；作为分布式系统，它要有服务端、客户端、注册中心，对应的就是Broker、Producer/Consumer、NameServer</p><p>所以我们看一下它主要的工作流程：RocketMQ由NameServer注册中心集群、Producer生产者集群、Consumer消费者集群和若干Broker（RocketMQ进程）组成：</p><ol><li>Broker在启动的时候去向所有的NameServer注册，并保持长连接，每30s发送一次心跳</li><li>Producer在发送消息的时候从NameServer获取Broker服务器地址，根据负载均衡算法选择一台服务器来发送消息</li><li>Conusmer消费消息的时候同样从NameServer获取Broker地址，然后主动拉取消息来消费</li></ol><p><img src="https://s2.loli.net/2023/04/01/UOe4szTWGZmPltp.png" alt="RocketMQ整体工作流程"></p><h3 id="19-为什么RocketMQ不使用Zookeeper作为注册中心呢？">19.为什么RocketMQ不使用Zookeeper作为注册中心呢？</h3><p>Kafka我们都知道采用Zookeeper作为注册中心——当然也开始逐渐去Zookeeper，RocketMQ不使用Zookeeper其实主要可能从这几方面来考虑：</p><ol><li>基于可用性的考虑，根据CAP理论，同时最多只能满足两个点，而Zookeeper满足的是CP，也就是说Zookeeper并不能保证服务的可用性，Zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。</li><li>基于性能的考虑，NameServer本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而Zookeeper的写是不可扩展的，Zookeeper要解决这个问题只能通过划分领域，划分多个Zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。</li><li>持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。</li><li>消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从NameServer获取到Broker地址后缓存到本地，如果NameServer整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。</li></ol><h3 id="20-Broker是怎么保存数据的呢？">20.Broker是怎么保存数据的呢？</h3><p>RocketMQ主要的存储文件包括CommitLog文件、ConsumeQueue文件、Indexfile文件。</p><p><img src="https://s2.loli.net/2023/04/01/PRV7LHlm81ks4nM.png" alt=""></p><p>消息存储的整体的设计：</p><p><img src="https://s2.loli.net/2023/04/01/MB4GVmW1EwanHNb.png" alt="消息存储整体设计-来源官网"></p><ul><li><strong>CommitLog</strong>：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G, 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。</li></ul><p>CommitLog文件保存于${Rocket_Home}/store/commitlog目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认1G，写满后自动生成一个新的文件。</p><p><img src="https://s2.loli.net/2023/04/01/Lb9KcPY3TH58Iut.jpg" alt="CommitLog"></p><ul><li><strong>ConsumeQueue</strong>：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。</li></ul><p>Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。</p><p>ConsumeQueue文件可以看成是基于Topic的CommitLog索引文件，故ConsumeQueue文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样ConsumeQueue文件采取定长设计，每一个条目共20个字节，分别为8字节的CommitLog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</p><p><img src="https://s2.loli.net/2023/04/01/YRCXUs1akqf8M6u.jpg" alt="Comsumer Queue"></p><ul><li><strong>IndexFile</strong>：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是： {fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故RocketMQ的索引文件其底层实现为hash索引。</li></ul><p><img src="https://s2.loli.net/2023/04/01/aIWMqGkQcxdZ79B.png" alt="IndexFile文件示意图"></p><p>总结一下：RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。</p><p>RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。</p><p>只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。</p><p>这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p><p><img src="https://s2.loli.net/2023/04/01/4rZYGe79TtKAi2I.png" alt=""></p><h3 id="21-说说RocketMQ怎么对文件进行读写的？">21.说说RocketMQ怎么对文件进行读写的？</h3><p>RocketMQ对文件的读写巧妙地利用了操作系统的一些高效文件读写方式——<code>PageCache</code>、<code>顺序读写</code>、<code>零拷贝</code>。</p><ul><li>PageCache、顺序读取</li></ul><p>在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p><p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p><ul><li>零拷贝</li></ul><p>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO，将磁盘文件数据在操作系统内核地址空间的缓冲区，和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p><h4 id="说说什么是零拷贝">说说什么是零拷贝?</h4><p>在操作系统中，使用传统的方式，数据需要经历几次拷贝，还要经历用户态/内核态切换。</p><p><img src="https://s2.loli.net/2023/04/01/XKHT5cAu9NSGLar.png" alt="传统文件传输示意图-来源《图解操作系统》"></p><ol><li>从磁盘复制数据到内核态内存；</li><li>从内核态内存复制到用户态内存；</li><li>然后从用户态内存复制到网络驱动的内核态内存；</li><li>最后是从网络驱动的内核态内存复制到网卡中进行传输。</li></ol><p>所以，可以通过零拷贝的方式，<strong>减少用户态与内核态的上下文切换</strong>和<strong>内存拷贝的次数</strong>，用来提升I/O的性能。零拷贝比较常见的实现方式是<strong>mmap</strong>，这种机制在Java中是通过MappedByteBuffer实现的。</p><p><img src="https://s2.loli.net/2023/04/01/dIOsG7YmXMqo5W4.png" alt="mmap示意图-来源《图解操作系统》"></p><h3 id="22-消息刷盘怎么实现的呢？">22.消息刷盘怎么实现的呢？</h3><p>RocketMQ提供了两种刷盘策略：同步刷盘和异步刷盘</p><ul><li>同步刷盘：在消息达到Broker的内存之后，必须刷到commitLog日志文件中才算成功，然后返回Producer数据已经发送成功。</li><li>异步刷盘：异步刷盘是指消息达到Broker内存后就返回Producer数据已经发送成功，会唤醒一个线程去将数据持久化到CommitLog日志文件中。</li></ul><p><strong>Broker</strong> 在消息的存取时直接操作的是内存（内存映射文件），这可以提供系统的吞吐量，但是无法避免机器掉电时数据丢失，所以需要持久化到磁盘中。</p><p>刷盘的最终实现都是使用<strong>NIO</strong>中的 MappedByteBuffer.force() 将映射区的数据写入到磁盘，如果是同步刷盘的话，在<strong>Broker</strong>把消息写到<strong>CommitLog</strong>映射区后，就会等待写入完成。</p><p>异步而言，只是唤醒对应的线程，不保证执行的时机，流程如图所示。</p><p><img src="https://s2.loli.net/2023/04/01/X6S8VAPbxHLov3T.png" alt="异步刷盘"></p><h3 id="22-能说下-RocketMQ-的负载均衡是如何实现的？">22.能说下 RocketMQ 的负载均衡是如何实现的？</h3><p>RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。</p><h4 id="Producer的负载均衡">Producer的负载均衡</h4><p>Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。具这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。</p><p><img src="https://s2.loli.net/2023/04/01/nbPZCeucrgTho76.png" alt=""></p><p>所谓的&quot;latencyFaultTolerance&quot;，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p><h4 id="Consumer的负载均衡">Consumer的负载均衡</h4><p>在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端知道从Broker端的哪一个消息队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p><ol><li>Consumer端的心跳包发送</li></ol><p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p><ol start="2"><li>Consumer端实现负载均衡的核心类—RebalanceImpl</li></ol><p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。</p><p>通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，这个方法是实现Consumer端负载均衡的核心。</p><p>rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p><p><img src="https://s2.loli.net/2023/04/01/VkOHYcf9IvWbMlw.png" alt=""></p><p>(1) 从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p><p>(2) 根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送通信请求，获取该消费组下消费者Id列表；</p><p>(3) 先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的的MessageQueue。</p><p><img src="https://s2.loli.net/2023/04/01/hTkEKofDgJI68Lj.png" alt="Cosumer分配"></p><p>(4) 然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p><p><img src="https://s2.loli.net/2023/04/01/9RocKJWaw5NgpZx.png" alt=""></p><ul><li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</li><li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</li><li>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空。</li></ul><p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p><h3 id="23-RocketMQ消息长轮询了解吗？">23.RocketMQ消息长轮询了解吗？</h3><p>所谓的长轮询，就是Consumer 拉取消息，如果对应的 Queue 如果没有数据，Broker 不会立即返回，而是把 PullReuqest hold起来，等待 queue 有了消息后，或者长轮询阻塞时间到了，再重新处理该 queue 上的所有 PullRequest。</p><p><img src="https://s2.loli.net/2023/04/01/MQiU4wKHTOJhmEC.png" alt="长轮询简单示意图"></p><ul><li><code>PullMessageProcessor#processRequest</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//如果没有拉到数据</span><br><span class="line">case ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">// broker 和 consumer 都允许 suspend，默认开启</span><br><span class="line">if (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">    long pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">    if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">        pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String topic = requestHeader.getTopic();</span><br><span class="line">    long offset = requestHeader.getQueueOffset();</span><br><span class="line">    int queueId = requestHeader.getQueueId();</span><br><span class="line">    //封装一个PullRequest</span><br><span class="line">    PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">            this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">    //把PullRequest挂起来</span><br><span class="line">    this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">    response = null;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂起的请求，有一个服务线程会不停地检查，看queue中是否有数据，或者超时。</p><ul><li><code>PullRequestHoldService#run()</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    log.info(&quot;&#123;&#125; service started&quot;, this.getServiceName());</span><br><span class="line">    while (!this.isStopped()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                this.waitForRunning(5 * 1000);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            long beginLockTimestamp = this.systemClock.now();</span><br><span class="line">            //检查hold住的请求</span><br><span class="line">            this.checkHoldRequest();</span><br><span class="line">            long costTime = this.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            if (costTime &gt; 5 * 1000) &#123;</span><br><span class="line">                log.info(&quot;[NOTIFYME] check hold request cost &#123;&#125; ms.&quot;, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;&#123;&#125; service end&quot;, this.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> RocketMq篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis篇(修正版)</title>
      <link href="/posts/a070ed70.html"/>
      <url>/posts/a070ed70.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="1-说说什么是Redis">1.说说什么是Redis?</h3><p><img src="https://s2.loli.net/2023/03/31/gdS5ZQBHcLjWE6i.png" alt="Redis图标"></p><p>Redis是一种基于键值对（key-value）的NoSQL数据库。</p><p>比一般键值对数据库强大的地方，Redis中的value支持string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构，因此 Redis可以满足很多的应用场景。</p><p>而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常出色。</p><p>不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。</p><p>除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。</p><p>总之，Redis是一款强大的性能利器。</p><h3 id="2-Redis可以用来干什么？">2.Redis可以用来干什么？</h3><p><img src="https://s2.loli.net/2023/03/31/Mj13w6LZsD9fTHl.png" alt="Redis"></p><ol><li><p>缓存</p><p>这是Redis应用最广泛地方，基本所有的Web应用都会使用Redis作为缓存，来降低数据源压力，提高响应速度。<br><img src="https://s2.loli.net/2023/03/31/jWSLNR4lkHo6J19.png" alt="Redis缓存"></p></li><li><p>计数器<br>Redis天然支持计数功能，而且计数性能非常好，可以用来记录浏览量、点赞量等等。</p></li><li><p>排行榜<br>Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。</p></li><li><p>社交网络<br>赞/踩、粉丝、共同好友/喜好、推送、下拉刷新。</p></li><li><p>消息队列<br>Redis提供了发布订阅功能和阻塞队列的功能，可以满足一般消息队列功能。</p></li><li><p>分布式锁<br>分布式环境下，利用Redis实现分布式锁，也是Redis常见的应用。</p></li></ol><p>Redis的应用一般会结合项目去问，以一个电商项目的用户服务为例：</p><ul><li>Token存储：用户登录成功之后，使用Redis存储Token</li><li>登录失败次数计数：使用Redis计数，登录失败超过一定次数，锁定账号</li><li>地址缓存：对省市区数据的缓存</li><li>分布式锁：分布式环境下登录、注册等操作加分布式锁</li><li>……</li></ul><h3 id="3-Redis-有哪些数据结构？">3.Redis 有哪些数据结构？</h3><p><img src="https://s2.loli.net/2023/03/31/NAUCoiqv2cFXtDl.png" alt="Redis基本数据结构"><br>Redis有五种基本数据结构。</p><p><strong>string</strong></p><p>字符串最基础的数据结构。字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字 （整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。</p><p>字符串主要有以下几个典型使用场景：</p><ul><li>缓存功能</li><li>计数</li><li>共享Session</li><li>限速</li></ul><p><strong>hash</strong></p><p>哈希类型是指键值本身又是一个键值对结构。</p><p>哈希主要有以下典型应用场景：</p><ul><li>缓存用户信息</li><li>缓存对象</li></ul><p><strong>list</strong></p><p>列表（list）类型是用来存储多个有序的字符串。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色</p><p>列表主要有以下几种使用场景：</p><ul><li>消息队列</li><li>文章列表</li></ul><p><strong>set</strong></p><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的。</p><p>集合主要有如下使用场景：</p><ul><li>标签（tag）</li><li>共同关注</li></ul><p><strong>sorted set</strong></p><p>有序集合中的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个权重（score）作为排序的依据。</p><p>有序集合主要应用场景：</p><ul><li>用户点赞统计</li><li>用户排序</li></ul><h3 id="4-Redis为什么快呢？">4.Redis为什么快呢？</h3><p>Redis的速度⾮常的快，单机的Redis就可以⽀撑每秒十几万的并发，相对于MySQL来说，性能是MySQL的⼏⼗倍。速度快的原因主要有⼏点：</p><ol><li><strong>完全基于内存操作</strong></li><li>使⽤单线程，避免了线程切换和竞态产生的消耗</li><li>基于⾮阻塞的IO多路复⽤机制</li><li>C语⾔实现，优化过的数据结构，基于⼏种基础的数据结构，redis做了⼤量的优化，性能极⾼<br><img src="https://s2.loli.net/2023/03/31/URsrK3LCTniouBh.png" alt="Redis使用IO多路复用和自身事件模型"></li></ol><h3 id="5-能说一下I-O多路复用吗？">5.能说一下I/O多路复用吗？</h3><p>引用知乎上一个高赞的回答来解释什么是I/O多路复用。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ul><li><p>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</p></li><li><p>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者- 线程处理连接。</p></li><li><p>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。</p></li></ul><p>第一种就是阻塞IO模型，第三种就是I/O复用模型。</p><p><img src="https://s2.loli.net/2023/03/31/jl4AmT1P7XVxvKL.png" alt="多路复用模型"></p><p>官方一点的回答是</p><ul><li><strong>lO</strong>：在操作系统中，数据在内核态和用户态之间的读写操作</li><li><strong>多路</strong>：大部分情况下是指多个TCP连接(多个Socket或者多个channel)</li><li><strong>复用</strong>：一个或多个线程资源</li><li><strong>IO多路复用</strong>：<mark class="hl-label orange">一个或多个线程处理多个 TCP 连接。无需创建和维护过多的进程/线程</mark> </li></ul><p>Linux系统有三种方式实现IO多路复用：select、poll和epoll。</p><p>例如epoll方式是将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。</p><p>这样，整个过程只在进行select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</p><h3 id="6-Redis为什么早期选择单线程？">6. Redis为什么早期选择单线程？</h3><p>官方解释：<a href="https://redis.io/topics/faq">https://redis.io/topics/faq</a></p><p><img src="https://s2.loli.net/2023/03/31/A95mfxXhTbOwQv4.png" alt="官方单线程解释"><br>官方FAQ表示，因为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，Redis的瓶颈最有可能是内存的大小或者网络限制。</p><p>如果想要最大程度利用CPU，可以在一台机器上启动多个Redis实例。</p><p>PS：网上有这样的回答，吐槽官方的解释有些敷衍，其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。</p><p>同时FAQ里还提到了， Redis 4.0 之后开始变成多线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 Key 的删除等等。</p><h3 id="7-Redis6-0使用多线程是怎么回事">7.Redis6.0使用多线程是怎么回事?</h3><p>Redis不是说用单线程的吗？怎么6.0成了多线程的？</p><p>Redis6.0的多线程是用多线程来处理数据的<strong>读写和协议解析</strong>，但是Redis<strong>执行命令</strong>还是单线程的。</p><p><img src="https://s2.loli.net/2023/03/31/9PSoavOZuYQkdDs.png" alt="Redis6.0多线程"><br>这样做的⽬的是因为Redis的性能瓶颈在于⽹络IO⽽⾮CPU，使⽤多线程能提升IO读写的效率，从⽽整体提⾼Redis的性能。</p><h2 id="持久化">持久化</h2><h3 id="8-Redis持久化⽅式有哪些？有什么区别？">8.Redis持久化⽅式有哪些？有什么区别？</h3><p>Redis持久化⽅案分为RDB和AOF两种。<br><img src="https://s2.loli.net/2023/03/31/BCkJy8pSMO6NvKV.png" alt="Redis持久化两种方式"></p><p><strong>RDB</strong></p><p>RDB持久化是把当前进程数据生成<strong>快照</strong>保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p><p>RDB⽂件是⼀个压缩的⼆进制⽂件，通过它可以还原某个时刻数据库的状态。由于RDB⽂件是保存在硬盘上的，所以即使Redis崩溃或者退出，只要RDB⽂件存在，就可以⽤它来恢复还原数据库的状态。</p><p>手动触发分别对应save和bgsave命令:<br><img src="https://s2.loli.net/2023/03/31/WqAPmsc1VwYvGu3.png" alt="save和bgsave"></p><ul><li><p>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。</p></li><li><p>bgsave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</p></li></ul><p>以下场景会自动触发RDB持久化：</p><ul><li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li><li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点</li><li>执行debug reload命令重新加载Redis时，也会自动触发save操作</li><li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li></ul><p><strong>AOF</strong></p><p>AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p><p>AOF的工作流程操作：命令写入 （append）、文件同步（sync）、文件重写（rewrite）、重启加载 （load）<br><img src="https://s2.loli.net/2023/03/31/QJH2idRVwtgCfYh.png" alt="AOF工作流程">流程如下：</p><p>1）所有的写入命令会追加到aof_buf（缓冲区）中。</p><p>2）AOF缓冲区根据对应的策略向硬盘做同步操作。</p><p>3）随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩 的目的。</p><p>4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。</p><h3 id="9-RDB-和-AOF-各自有什么优缺点？">9.RDB 和 AOF 各自有什么优缺点？</h3><p><strong>RDB | 优点</strong></p><ol><li>只有一个紧凑的二进制文件 <code>dump.rdb</code>，非常适合备份、全量复制的场景。</li><li><strong>容灾性好</strong>，可以把RDB文件拷贝道远程机器或者文件系统张，用于容灾恢复。</li><li><strong>恢复速度快</strong>，RDB恢复数据的速度远远快于AOF的方式</li></ol><p><strong>RDB | 缺点</strong></p><ol><li><strong>实时性低</strong>，RDB 是间隔一段时间进行持久化，没法做到实时持久化/秒级持久化。如果在这一间隔事件发生故障，数据会丢失。</li><li><strong>存在兼容问题</strong>，Redis演进过程存在多个格式的RDB版本，存在老版本Redis无法兼容新版本RDB的问题。</li></ol><p><strong>AOF | 优点</strong></p><ol><li><strong>实时性好</strong>，aof 持久化可以配置 <code>appendfsync</code> 属性，有 <code>always</code>，每进行一次命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li></ol><p><strong>AOF | 缺点</strong></p><ol><li>AOF 文件比 RDB <strong>文件大</strong>，且 <strong>恢复速度慢</strong>。</li><li><strong>数据集大</strong> 的时候，比 RDB <strong>启动效率低</strong>。</li></ol><h3 id="10-RDB和AOF如何选择？">10.RDB和AOF如何选择？</h3><ul><li>一般来说， 如果想达到足以媲美数据库的 <strong>数据安全性</strong>，应该 <strong>同时使用两种持久化功能</strong>。在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</li><li>如果 <strong>可以接受数分钟以内的数据丢失</strong>，那么可以 <strong>只使用 RDB 持久化</strong>。</li><li>有很多用户都只使用 AOF 持久化，但并不推荐这种方式，因为定时生成 RDB 快照（snapshot）非常便于进行数据备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，除此之外，使用 RDB 还可以避免 AOF 程序的 bug。</li><li>如果只需要数据在服务器运行的时候存在，也可以不使用任何持久化方式。</li></ul><h3 id="11-Redis的数据恢复？">11.Redis的数据恢复？</h3><p>当Redis发生了故障，可以从RDB或者AOF中恢复数据。</p><p>恢复的过程也很简单，把RDB或者AOF文件拷贝到Redis的数据目录下，如果使用AOF恢复，配置文件开启AOF，然后启动redis-server即可。<br><img src="https://s2.loli.net/2023/03/31/hgCTiFuNA9UGo7D.png" alt="Redis启动加载数据"></p><p><strong>Redis</strong> 启动时加载数据的流程：</p><ol><li>AOF持久化开启且存在AOF文件时，优先加载AOF文件。</li><li>AOF关闭或者AOF文件不存在时，加载RDB文件。</li><li>加载AOF/RDB文件成功后，Redis启动成功。</li><li>AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</li></ol><h3 id="12-Redis-4-0-的混合持久化了解吗？">12.Redis 4.0 的混合持久化了解吗？</h3><p>重启 Redis 时，我们很少使用 <code>RDB</code> 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 <code>RDB</code> 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。</p><p><strong>Redis 4.0</strong> 为了解决这个问题，带来了一个新的持久化选项——<strong>混合持久化</strong>。将 <code>rdb</code> 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是 <strong>自持久化开始到持久化结束</strong> 的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小：<br><img src="https://s2.loli.net/2023/03/31/TPwLkIsS5HEUXFj.png" alt="混合持久化"></p><p>于是在 Redis 重启的时候，可以先加载 <code>rdb</code> 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p><h2 id="高可用">高可用</h2><p>Redis保证高可用主要有三种方式：主从、哨兵、集群。</p><h3 id="13-主从复制了解吗？">13.主从复制了解吗？</h3><p><img src="https://s2.loli.net/2023/03/31/SbWXHjEcqL139MF.png" alt="Redis主从复制简图"></p><p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由主节点到从节点。Redis 主从复制支持 <strong>主从同步</strong> 和 <strong>从从同步</strong> 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p><blockquote><p>主从复制主要的作用?</p></blockquote><ul><li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 <em>(实际上是一种服务的冗余)</em>。</li><li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <em>（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点）</em>，分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</li><li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</li></ul><h3 id="14-Redis主从有几种常见的拓扑结构？">14.Redis主从有几种常见的拓扑结构？</h3><p>Redis的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从、树状主从结构。</p><p>1.一主一从结构</p><p>一主一从结构是最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持。<br><img src="https://s2.loli.net/2023/03/31/o7HFs8h4r1QIeqA.png" alt="一主一从结构"><br>2.一主多从结构</p><p>一主多从结构（又称为星形拓扑结构）使得应用端可以利用多个从节点实现读写分离（见图6-5）。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。<br><img src="https://s2.loli.net/2023/03/31/iOdWCFVwrpG7xAY.png" alt="一主多从结构"><br>3.树状主从结构</p><p>树状主从结构（又称为树状拓扑结构）使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。<br><img src="https://s2.loli.net/2023/03/31/5vCB1jpa8YJnDwu.png" alt="树状主从结构"></p><h3 id="15-Redis的主从复制原理了解吗？">15.Redis的主从复制原理了解吗？</h3><p>Redis主从复制的工作流程大概可以分为如下几步：<br><img src="https://s2.loli.net/2023/03/31/yFzT1358LNXDnPp.png" alt="Redis主从复制工作流程"></p><ol><li>保存主节点（master）信息<br>这一步只是保存主节点信息，保存主节点的ip和port。</li><li>主从建立连接<br>从节点（slave）发现新的主节点后，会尝试和主节点建立网络连接。</li><li>发送ping命令<br>连接建立成功后从节点发送ping请求进行首次通信，主要是检测主从之间网络套接字是否可用、主节点当前是否可接受处理命令。</li><li>权限验证<br>如果主节点要求密码验证，从节点必须正确的密码才能通过验证。</li><li>同步数据集<br>主从复制连接正常通信后，主节点会把持有的数据全部发送给从节点。</li><li>命令持续复制<br>接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。</li></ol><h3 id="16-说说主从数据同步的方式？">16.说说主从数据同步的方式？</h3><p>Redis在2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。</p><p><img src="https://s2.loli.net/2023/03/31/Kwzi27vGrI1sHOV.png" alt="主从数据同步方式"></p><p><strong>全量复制</strong><br>一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。</p><p>全量复制的完整运行流程如下：<br><img src="https://s2.loli.net/2023/03/31/lmtjLpVT5FXhqgd.png" alt="全量复制"></p><ol><li>发送psync命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送psync-1。</li><li>主节点根据psync-1解析出当前为全量复制，回复+FULLRESYNC响应。</li><li>从节点接收主节点的响应数据保存运行ID和偏移量offset</li><li>主节点执行bgsave保存RDB文件到本地</li><li>主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件</li><li>对于从节点开始接收RDB快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完RDB文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。</li><li>从节点接收完主节点传送来的全部数据后会清空自身旧数据</li><li>从节点清空数据后开始加载RDB文件</li><li>从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。</li></ol><p><strong>部分复制</strong><br>部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施， 使用psync{runId}{offset}命令实现。当从节点（slave）正在复制主节点 （master）时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向 主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。<br><img src="https://s2.loli.net/2023/03/31/XFug8bnwMB7joRY.png" alt="部分复制"></p><ol><li>当主从节点之间网络出现中断时，如果超过repl-timeout时间，主节点会认为从节点故障并中断复制连接</li><li>主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存1MB。</li><li>当主从节点网络恢复后，从节点会再次连上主节点</li><li>当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作psync参数发送给主节点，要求进行部分复制操作。</li><li>主节点接到psync命令后首先核对参数runId是否与自身一致，如果一 致，说明之前复制的是当前主节点；之后根据参数offset在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送+CONTINUE响应，表示可以进行部分复制。</li><li>主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</li></ol><h3 id="17-主从复制存在哪些问题呢？">17.主从复制存在哪些问题呢？</h3><p>主从复制虽好，但也存在一些问题：</p><ul><li>一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其他从节点去复制新的主节点，整个过程都需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li></ul><p>第一个问题是Redis的高可用问题，第二、三个问题属于Redis的分布式问题。</p><h3 id="18-Redis-Sentinel（哨兵）了解吗？">18.Redis Sentinel（哨兵）了解吗？</h3><p>主从复制存在一个问题，没法完成自动故障转移。所以我们需要一个方案来完成自动故障转移，它就是Redis Sentinel（哨兵）。</p><p><img src="https://s2.loli.net/2023/03/31/rql3jLz2WBaFV6E.png" alt="Redis Sentinel"></p><p>Redis Sentinel ，它由两部分组成，哨兵节点和数据节点：</p><ul><li><strong>哨兵节点：</strong> 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据，对数据节点进行监控。</li><li><strong>数据节点：</strong> 主节点和从节点都是数据节点；</li></ul><p>在复制的基础上，哨兵实现了 <strong>自动化的故障恢复</strong> 功能，下面是官方对于哨兵功能的描述：</p><ul><li><strong>监控（Monitoring）：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）：</strong> 当 <strong>主节点</strong> 不能正常工作时，哨兵会开始 <strong>自动故障转移操作</strong>，它会将失效主节点的其中一个 <strong>从节点升级为新的主节点</strong>，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。</li><li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li></ul><p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移。而配置提供者和通知功能，则需要在与客户端的交互中才能体现。</p><h3 id="19-Redis-Sentinel（哨兵）实现原理知道吗？">19.Redis Sentinel（哨兵）实现原理知道吗？</h3><p>哨兵模式是通过哨兵节点完成对数据节点的监控、下线、故障转移。<br><img src="https://s2.loli.net/2023/03/31/JAkfD4RqvXpBUbw.png" alt="Redis Sentinel工作流程"></p><ul><li><strong>定时监控</strong><br><img src="https://s2.loli.net/2023/03/31/HWaFl48JZxBXuiy.png" alt="三个定时任务">Redis Sentinel通过三个定时监控任务完成对各个节点发现和监控：<ol><li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构</li><li>每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__：hello 频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息</li><li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达</li></ol></li><li><strong>主观下线和客观下线</strong><br>主观下线就是哨兵节点认为某个节点有问题，客观下线就是超过一定数量的哨兵节点认为主节点有问题。<br><img src="https://s2.loli.net/2023/03/31/kUlLrjXI6aH1GcR.png" alt="主观下线和客观下线"></li></ul><ol><li><p>主观下线<br>每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过 down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</p></li><li><p>客观下线<br>当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is- master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过 &lt;quorum&gt;个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定</p></li></ol><ul><li><p><strong>领导者Sentinel节点选举</strong><br>Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举。</p></li><li><p><strong>故障转移</strong></p><p>领导者选举出的Sentinel节点负责故障转移，过程如下：<br><img src="https://s2.loli.net/2023/03/31/hCOtsvn41H5UroL.png" alt="故障转移"></p><ol><li>在从节点列表中选出一个节点作为新的主节点，这一步是相对复杂一些的一步</li><li>Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点</li><li>Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点</li><li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点</li></ol></li></ul><h3 id="20-领导者Sentinel节点选举了解吗？">20.领导者Sentinel节点选举了解吗？</h3><p>Redis使用了Raft算法实 现领导者选举，大致流程如下：<br><img src="https://s2.loli.net/2023/03/31/YFzOuGoZkhmtcrC.png" alt="领导者Sentinel节点选举"></p><ol><li>每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观 下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令， 要求将自己设置为领导者。</li><li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。</li><li>如果该Sentinel节点发现自己的票数已经大于等于max（quorum， num（sentinels）/2+1），那么它将成为领导者。</li><li>如果此过程没有选举出领导者，将进入下一次选举。</li></ol><h3 id="21-新的主节点是怎样被挑选出来的？">21.新的主节点是怎样被挑选出来的？</h3><p>选出新的主节点，大概分为这么几步：<br><img src="https://s2.loli.net/2023/03/31/C5dKNpgcaPwlzT4.png" alt="新的主节点"></p><ol><li>过滤：“不健康”（主观下线、断线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒。</li><li>选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。</li><li>选择runid最小的从节点。</li></ol><h3 id="22-Redis-集群了解吗？">22.Redis 集群了解吗？</h3><p>前面说到了主从存在高可用和分布式的问题，哨兵解决了高可用的问题，而集群就是终极方案，一举解决高可用和分布式问题。<br><img src="https://s2.loli.net/2023/03/31/KRQbrWjtzFXc3Pu.png" alt="Redis 集群示意图"></p><ol><li><p><strong>数据分区：</strong> 数据分区 <em>(或称数据分片)</em> 是集群最核心的功能。集群将数据分散到多个节点，一方面 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。</p></li><li><p><strong>高可用：</strong> 集群支持主从复制和主节点的 <strong>自动故障转移</strong> <em>（与哨兵类似）</em>，当任一节点发生故障时，集群仍然可以对外提供服务。</p></li></ol><h3 id="23-集群中数据如何分区？">23.集群中数据如何分区？</h3><p>分布式的存储中，要把数据集按照分区规则映射到多个节点，常见的数据分区规则三种：<br><img src="https://s2.loli.net/2023/03/31/BtYhJpur8Oi7mAZ.png" alt="分布式数据分区"></p><h4 id="方案一：节点取余分区">方案一：节点取余分区</h4><p>节点取余分区，非常好理解，使用特定的数据，比如Redis的键，或者用户ID之类，对响应的hash值取余：hash（key）%N，来确定数据映射到哪一个节点上。</p><p>不过该方案最大的问题是，当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。</p><p><img src="https://s2.loli.net/2023/03/31/q3ICAylK6HF8UXw.png" alt="节点取余分区"></p><h4 id="方案二：一致性哈希分区">方案二：一致性哈希分区</h4><p>将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当我们需要确定某一个 Key 需要存取到哪个节点上的时候，先对这个 Key 做同样的 Hash 取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。</p><p>比如说下面这张图里面，Key 1 和 Key 2 会落入到 Node 1 中，Key 3、Key 4 会落入到 Node 2 中，Key 5 落入到 Node 3 中，Key 6 落入到 Node 4 中。<br><img src="https://s2.loli.net/2023/03/31/fjAv6rbCGexWgqU.png" alt="一致性哈希分区"></p><p>这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。</p><p>但它还是存在问题：</p><ul><li>缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大</li><li>当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成压力。</li></ul><h4 id="方案三：虚拟槽分区">方案三：虚拟槽分区</h4><p>这个方案 一致性哈希分区的基础上，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的虚拟节点称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。<br><img src="https://s2.loli.net/2023/03/31/gpIXokPfryTN9Wq.png" alt="虚拟槽分配"></p><p>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0-15)；</p><ul><li>槽 0-3 位于 node1；4-7 位于 node2；以此类推…</li></ul><p>如果此时删除 <code>node2</code>，只需要将槽 4-7 重新分配即可，例如槽 4-5 分配给 <code>node1</code>，槽 6 分配给 <code>node3</code>，槽 7 分配给 <code>node4</code>，数据在其他节点的分布仍然较为均衡。</p><h3 id="24-能说说Redis集群的原理吗？">24.能说说Redis集群的原理吗？</h3><p>Redis集群通过数据分区来实现数据的分布式存储，通过自动故障转移实现高可用。</p><h4 id="集群创建">集群创建</h4><p>数据分区是在集群创建的时候完成的。<br><img src="https://s2.loli.net/2023/03/31/rb48thH7NgyEknR.png" alt="集群创建"></p><p><strong>设置节点</strong><br>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。<br><img src="https://s2.loli.net/2023/03/31/AmM1FtSyu2N5wLZ.png" alt="节点和握手"><br><strong>节点握手</strong><br>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信， 达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命 令：cluster meet{ip}{port}。完成节点握手之后，一个个的Redis节点就组成了一个多节点的集群。</p><p><strong>分配槽（slot）</strong><br>Redis集群把所有的数据映射到16384个槽中。每个节点对应若干个槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过 cluster addslots命令为节点分配槽。</p><p><img src="https://s2.loli.net/2023/03/31/k9lXjKEMPxb4Udi.png" alt="分配槽"></p><h4 id="故障转移">故障转移</h4><p>Redis集群的故障转移和哨兵的故障转移类似，但是Redis集群中所有的节点都要承担状态维护的任务。</p><p><strong>故障发现</strong><br>Redis集群内节点通过ping/pong消息实现节点通信，集群中每个节点都会定期向其他节点发送ping消息，接收节点回复pong 消息作为响应。如果在cluster-node-timeout时间内通信一直失败，则发送节 点会认为接收节点存在故障，把接收节点标记为主观下线（pfail）状态。<br><img src="https://s2.loli.net/2023/03/31/rwMpA7LTJSRcKfD.png" alt="主观下线"><br>当某个节点判断另一个节点主观下线后，相应的节点状态会跟随消息在集群内传播。通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告。当 半数以上持有槽的主节点都标记某个节点是主观下线时。触发客观下线流程。<br><img src="https://s2.loli.net/2023/03/31/6tiwq4DAap85Udg.png" alt="主观下线和客观下线"></p><p><strong>故障恢复</strong></p><p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它 的从节点中选出一个替换它，从而保证集群的高可用。</p><p><img src="https://s2.loli.net/2023/03/31/AkfR4dFqLnSpUz3.png" alt="故障恢复流程"></p><ol><li>资格检查<br>每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障 的主节点。</li><li>准备选举时间<br>当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该 时间后才能执行后续流程。</li><li>发起选举<br>当从节点定时任务检测到达故障选举时间（failover_auth_time）到达后，发起选举流程。</li><li>选举投票<br>持有槽的主节点处理故障选举消息。投票过程其实是一个领导者选举的过程，如集群内有N个持有槽的主节 点代表有N张选票。由于在每个配置纪元内持有槽的主节点只能投票给一个 从节点，因此只能有一个从节点获得N/2+1的选票，保证能够找出唯一的从节点。<br><img src="https://s2.loli.net/2023/03/31/cRNdZ4oDtsQhrfn.png" alt="选举投票"></li><li>替换主节点<br>当从节点收集到足够的选票之后，触发替换主节点操作。</li></ol><blockquote><p><strong>部署Redis集群至少需要几个物理节点？</strong></p></blockquote><p>在投票选举的环节，故障主节点也算在投票数内，假设集群内节点规模是3主3从，其中有2 个主节点部署在一台机器上，当这台机器宕机时，由于从节点无法收集到 3/2+1个主节点选票将导致故障转移失败。这个问题也适用于故障发现环节。因此部署集群时所有主节点最少需要部署在3台物理机上才能避免单点问题。</p><h3 id="25-说说集群的伸缩？">25.说说集群的伸缩？</h3><p>Redis集群提供了灵活的节点扩容和收缩方案，可以在不影响集群对外服务的情况下，为集群添加节点进行扩容也可以下线部分节点进行缩容。<br><img src="https://s2.loli.net/2023/03/31/AsHyMqCwXrxtTO6.png" alt="集群的伸缩">其实，集群扩容和缩容的关键点，就在于槽和节点的对应关系，扩容和缩容就是将一部分<code>槽</code>和<code>数据</code>迁移给新节点。</p><p>例如下面一个集群，每个节点对应若干个槽，每个槽对应一定的数据，如果希望加入1个节点希望实现集群扩容时，需要通过相关命令把一部分槽和内容迁移给新节点。<br><img src="https://s2.loli.net/2023/03/31/W85ByOeGDZt6nzK.png" alt="扩容实例">缩容也是类似，先把槽和数据迁移到其它节点，再把对应的节点下线。</p><h2 id="缓存设计">缓存设计</h2><h3 id="26-什么是缓存击穿、缓存穿透、缓存雪崩？">26.什么是缓存击穿、缓存穿透、缓存雪崩？</h3><p>PS:这是多年黄历的老八股了，一定要理解清楚。</p><h4 id="缓存击穿">缓存击穿</h4><p>一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在DB上。</p><p><img src="https://s2.loli.net/2023/03/31/VAzdkoQvZBxMjNr.png" alt="缓存击穿"><br>解决⽅案：</p><ol><li><p>加锁更新，⽐如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。<br><img src="https://s2.loli.net/2023/03/31/TMHy3EimsUKqz4g.png" alt="加锁更新"></p></li><li><p>将过期时间组合写在value中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。</p></li></ol><h4 id="缓存穿透">缓存穿透</h4><p>缓存穿透指的查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。</p><p><img src="https://s2.loli.net/2023/03/31/H9sDnyiX7R2gb8d.png" alt="缓存穿透"><br>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。</p><p>缓存穿透可能会使后端存储负载加大，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。</p><p>缓存穿透可能有两种原因：</p><ol><li>自身业务代码问题</li><li>恶意攻击，爬虫造成空命中</li></ol><p>它主要有两种解决办法：</p><ul><li><strong>缓存空值/默认值</strong></li></ul><p>一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。</p><p><img src="https://s2.loli.net/2023/03/31/zInshYAvM71DZeu.png" alt="缓存空值/默认值"></p><p>缓存空值有两大问题：</p><ol><li><p>空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p></li><li><p>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。<br>例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。<br>这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。</p></li></ol><ul><li><p><strong>布隆过滤器</strong><br>除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。</p><p>布隆过滤器里会记录和判断数据是否存在，如果判断数据不存在，就不会访问存储。<br><img src="https://s2.loli.net/2023/03/31/NGHBbd5C1aTDlSy.png" alt="布隆过滤器"><br>两种解决方案的对比：<br><img src="https://s2.loli.net/2023/03/31/CxiM7D3AONsguGb.png" alt="缓存空对象核布隆过滤器方案对比"></p></li></ul><h4 id="缓存雪崩">缓存雪崩</h4><p>某⼀时刻发⽣⼤规模的缓存失效的情况，例如缓存服务宕机、大量key在同一时间过期，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。</p><p><img src="https://s2.loli.net/2023/03/31/q5O9zFINc78uatH.png" alt="缓存雪崩"><br>缓存雪崩是三大缓存问题里最严重的一种，我们来看看怎么预防和处理。</p><ul><li><strong>提高缓存可用性</strong></li></ul><ol><li>集群部署：通过集群来提升缓存的可用性，可以利用Redis本身的Redis Cluster或者第三方集群方案如Codis等。</li><li>多级缓存：设置多级缓存，第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</li></ol><ul><li><strong>过期时间</strong></li></ul><ol><li>均匀过期：为了避免大量的缓存在同一时间过期，可以把不同的 key 过期时间随机生成，避免过期时间太过集中。</li><li>热点数据永不过期。</li></ol><ul><li><strong>熔断降级</strong></li></ul><ol><li>服务熔断：当缓存服务器宕机或超时响应时，为了防止整个系统出现雪崩，暂时停止业务服务访问缓存系统。</li><li>服务降级：当出现大量缓存失效，而且处在高并发高负荷的情况下，在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息。</li></ol><h3 id="27-能说说布隆过滤器吗？">27.能说说布隆过滤器吗？</h3><p>布隆过滤器，它是一个连续的数据结构，每个存储位存储都是一个<code>bit</code>，即<code>0</code>或者<code>1</code>, 来标识数据是否存在。</p><p>存储数据的时候，使用K个不同的哈希函数将这个变量映射为bit列表的的K个点，把它们置为1。</p><p><img src="https://s2.loli.net/2023/03/31/J4596DQCmqZYnaF.png" alt="布隆过滤器">我们判断缓存key是否存在，同样，K个哈希函数，映射到bit列表上的K个点，判断是不是1：</p><ul><li>如果全不是1，那么key不存在；</li><li>如果都是1，也只是表示key可能存在。</li></ul><p>布隆过滤器也有一些缺点：</p><ol><li>它在判断元素是否在集合中时是有一定错误几率，因为哈希算法有一定的碰撞的概率。</li><li>不支持删除元素。</li></ol><h3 id="28-如何保证缓存和数据库数据的⼀致性？">28.如何保证缓存和数据库数据的⼀致性？</h3><p>根据CAP理论，在保证可用性和分区容错性的前提下，无法保证一致性，所以缓存和数据库的绝对一致是不可能实现的，只能尽可能保存缓存和数据库的最终一致性。</p><h4 id="选择合适的缓存更新策略">选择合适的缓存更新策略</h4><p><strong>1. 删除缓存而不是更新缓存</strong></p><p>当一个线程对缓存的key进行写操作的时候，如果其它线程进来读数据库的时候，读到的就是脏数据，产生了数据不一致问题。</p><p>相比较而言，删除缓存的速度比更新缓存的速度快很多，所用时间相对也少很多，读脏数据的概率也小很多。<br><img src="https://s2.loli.net/2023/03/31/sW6tPGkMHbQ3YLX.png" alt="删除缓存和更新缓存"></p><ol start="2"><li><p><strong>先更数据，后删缓存</strong><br>先更数据库还是先删缓存？这是一个问题。</p><p>更新数据，耗时可能在删除缓存的百倍以上。在缓存中不存在对应的key，数据库又没有完成更新的时候，如果有线程进来读取数据，并写入到缓存，那么在更新成功之后，这个key就是一个脏数据。</p><p>毫无疑问，先删缓存，再更数据库，缓存中key不存在的时间更长，有更大的概率会产生脏数据。</p></li></ol><p><img src="https://s2.loli.net/2023/03/31/hyINwqZnbdsDRiL.png" alt="先更数据库还是先删缓存">目前最流行的缓存读写策略cache-aside-pattern就是采用先更数据库，再删缓存的方式。</p><h4 id="缓存不一致处理">缓存不一致处理</h4><p>如果不是并发特别高，对缓存依赖性很强，其实一定程度上的不一致是可以接受的。</p><p>但是如果对一致性要求比较高，那就得想办法保证缓存和数据库中数据一致。</p><p>缓存和数据库数据不一致常见的两种原因：</p><ul><li>缓存key删除失败</li><li>并发导致写入了脏数据</li></ul><p><img src="https://s2.loli.net/2023/03/31/xS4hJFW9fmPlRNG.png" alt="缓存一致性"></p><p><strong>消息队列保证key被删除</strong><br>可以引入消息队列，把要删除的key或者删除失败的key丢进消息队列，利用消息队列的重试机制，重试删除对应的key。</p><p><img src="https://s2.loli.net/2023/03/31/Hq4wFTxbipCsZjG.png" alt="消息队列保证key被删除"></p><p>这种方案看起来不错，缺点是对业务代码有一定的侵入性。</p><p><strong>数据库订阅+消息队列保证key被删除</strong><br>可以用一个服务（比如阿里的 canal）去监听数据库的binlog，获取需要操作的数据。</p><p>然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除操作。<br><img src="https://s2.loli.net/2023/03/31/NyRfzHl58upViCY.png" alt="数据库订阅+消息队列保证key被删除"><br>这种方式降低了对业务的侵入，但其实整个系统的复杂度是提升的，适合基建完善的大厂。</p><p><strong>延时双删防止脏数据</strong><br>还有一种情况，是在缓存不存在的时候，写入了脏数据，这种情况在先删缓存，再更数据库的缓存更新策略下发生的比较多，解决方案是延时双删。</p><p>简单说，就是在第一次删除缓存之后，过了一段时间之后，再次删除缓存。</p><p><img src="https://s2.loli.net/2023/03/31/4QpcHbzBL1dW7rK.png" alt="延时双删"></p><p>这种方式的延时时间设置需要仔细考量和测试。</p><p><strong>设置缓存过期时间兜底</strong></p><p>这是一个朴素但是有用的办法，给缓存设置一个合理的过期时间，即使发生了缓存数据不一致的问题，它也不会永远不一致下去，缓存过期的时候，自然又会恢复一致。</p><h3 id="29-如何保证本地缓存和分布式缓存的一致？">29.如何保证本地缓存和分布式缓存的一致？</h3><p>PS:这道题面试很少问，但实际工作中很常见。</p><p>在日常的开发中，我们常常采用两级缓存：本地缓存+分布式缓存。</p><p>所谓本地缓存，就是对应服务器的内存缓存，比如Caffeine，分布式缓存基本就是采用Redis。</p><p>那么问题来了，本地缓存和分布式缓存怎么保持数据一致？<br><img src="https://s2.loli.net/2023/03/31/lgMb7hQuDjGTBzx.png" alt="延时双删"><br>Redis缓存，数据库发生更新，直接删除缓存的key即可，因为对于应用系统而言，它是一种中心化的缓存。</p><p>但是本地缓存，它是非中心化的，散落在分布式服务的各个节点上，没法通过客户端的请求删除本地缓存的key，所以得想办法通知集群所有节点，删除对应的本地缓存key。<br><img src="https://s2.loli.net/2023/03/31/hAqcTJaYlnxwXQG.png" alt="本地缓存/分布式缓存保持一致"></p><p>可以采用消息队列的方式：</p><ol><li>采用Redis本身的Pub/Sub机制，分布式集群的所有节点订阅删除本地缓存频道，删除Redis缓存的节点，同时发布删除本地缓存消息，订阅者们订阅到消息后，删除对应的本地key。<em>但是Redis的发布订阅不是可靠的，不能保证一定删除成功。</em></li><li>引入专业的消息队列，比如RocketMQ，保证消息的可靠性，但是增加了系统的复杂度。</li><li>设置适当的过期时间兜底，本地缓存可以设置相对短一些的过期时间。</li></ol><h3 id="30-怎么处理热key？">30.怎么处理热key？</h3><blockquote><p><strong>什么是热Key？</strong><br>所谓的热key，就是访问频率比较高的key。</p></blockquote><p>比如，热门新闻事件或商品，这类key通常有大流量的访问，对存储这类信息的 Redis来说，是不小的压力。</p><p>假如Redis集群部署，热key可能会造成整体流量的不均衡，个别节点出现OPS过大的情况，极端情况下热点key甚至会超过 Redis本身能够承受的OPS。</p><blockquote><p><strong>怎么处理热key？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/31/7IZuCWSDoeqQnah.png" alt="热key处理"><br>对热key的处理，最关键的是对热点key的监控，可以从这些端来监控热点key:</p><ol><li><p>客户端<br>客户端其实是距离key“最近”的地方，因为Redis命令就是从客户端发出的，例如在客户端设置全局字典（key和调用次数），每次调用Redis命令时，使用这个字典进行记录。</p></li><li><p>代理端<br>像Twemproxy、Codis这些基于代理的Redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。</p></li><li><p>Redis服务端<br>使用monitor命令统计热点key是很多开发和运维人员首先想到，monitor命令可以监控到Redis执行的所有命令。</p></li></ol><p>只要监控到了热key，对热key的处理就简单了：</p><ol><li><p>把热key打散到不同的服务器，降低压⼒</p></li><li><p>加⼊⼆级缓存，提前加载热key数据到内存中，如果redis宕机，⾛内存查询</p></li></ol><h3 id="31-缓存预热怎么做呢？">31.缓存预热怎么做呢？</h3><p>所谓缓存预热，就是提前把数据库里的数据刷到缓存里，通常有这些方法：</p><p>1、直接写个缓存刷新页面或者接口，上线时手动操作</p><p>2、数据量不大，可以在项目启动的时候自动进行加载</p><p>3、定时任务刷新缓存.</p><h3 id="32-热点key重建？问题？解决？">32.热点key重建？问题？解决？</h3><p>开发的时候一般使用“缓存+过期时间”的策略，既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。</p><p>但是有两个问题如果同时出现，可能就会出现比较大的问题：</p><ul><li><p>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。</p></li><li><p>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次IO、多个依赖等。 在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p></li></ul><blockquote><p><strong>怎么处理呢？</strong></p></blockquote><p>要解决这个问题也不是很复杂，解决问题的要点在于：</p><ul><li>减少重建缓存的次数。</li><li>数据尽可能一致。</li><li>较少的潜在危险。</li></ul><p>所以一般采用如下方式：</p><ol><li>互斥锁（mutex key）<br>这种方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</li><li>永远不过期<br>“永远不过期”包含两层意思：</li></ol><ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。</li><li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ul><h3 id="33-无底洞问题吗？如何解决？">33.无底洞问题吗？如何解决？</h3><blockquote><p><strong>什么是无底洞问题？</strong></p></blockquote><p>2010年，Facebook的Memcache节点已经达到了3000个，承载着TB级别的缓存数据。但开发和运维人员发现了一个问题，为了满足业务要求添加了大量新Memcache节点，但是发现性能不但没有好转反而下降了，当时将这 种现象称为缓存的“<strong>无底洞</strong>”现象。</p><p>那么为什么会产生这种现象呢?</p><p>通常来说添加节点使得Memcache集群 性能应该更强了，但事实并非如此。键值数据库由于通常采用哈希函数将 key映射到各个节点上，造成key的分布与业务无关，但是由于数据量和访问量的持续增长，造成需要添加大量节点做水平扩容，导致键值分布到更多的 节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。</p><blockquote><p><strong>无底洞问题如何优化呢？</strong></p></blockquote><p>先分析一下无底洞问题：</p><ul><li><p>客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。</p></li><li><p>网络连接数变多，对节点的性能也有一定影响。</p></li></ul><p>常见的优化思路如下：</p><ul><li><p>命令本身的优化，例如优化操作语句等。</p></li><li><p>减少网络通信次数。</p></li><li><p>降低接入成本，例如客户端使用长连/连接池、NIO等。</p></li></ul><h2 id="Redis运维">Redis运维</h2><h3 id="34-Redis报内存不足怎么处理？">34.Redis报内存不足怎么处理？</h3><p>Redis 内存不足有这么几种处理方式：</p><ul><li>修改配置文件 redis.conf 的 maxmemory 参数，增加 Redis 可用内存</li><li>也可以通过命令set maxmemory动态设置内存上限</li><li>修改内存淘汰策略，及时释放内存空间</li><li>使用 Redis 集群模式，进行横向扩容。</li></ul><h3 id="35-Redis的过期数据回收策略有哪些？">35.Redis的过期数据回收策略有哪些？</h3><p>Redis主要有2种过期数据回收策略：<br><img src="https://s2.loli.net/2023/03/31/RMPi2Zu653qg9tG.png" alt="在这里插入图片描述"></p><p><strong>惰性删除</strong></p><p>惰性删除指的是当我们查询key的时候才对key进⾏检测，如果已经达到过期时间，则删除。显然，他有⼀个缺点就是如果这些过期的key没有被访问，那么他就⼀直⽆法被删除，⽽且⼀直占⽤内存。</p><p><strong>定期删除</strong></p><p>定期删除指的是Redis每隔⼀段时间对数据库做⼀次检查，删除⾥⾯的过期key。由于不可能对所有key去做轮询来删除，所以Redis会每次随机取⼀些key去做检查和删除。</p><h3 id="36-Redis有哪些内存溢出控制-内存淘汰策略？">36.Redis有哪些内存溢出控制/内存淘汰策略？</h3><p>Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略，Redis支持六种策略：<br><img src="https://s2.loli.net/2023/03/31/NTU2wbPvq7MrOpe.png" alt="Redis六种内存溢出控制策略"></p><ol><li>noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返 回客户端错误信息，此 时Redis只响应读操作。</li><li>volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直 到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。</li><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性， 直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果 没有，回退到noeviction策略。</li></ol><h3 id="37-Redis阻塞？怎么解决？">37.Redis阻塞？怎么解决？</h3><p>Redis发生阻塞，可以从以下几个方面排查：<br><img src="https://s2.loli.net/2023/03/31/PytNJgCYe6FvdXb.png" alt="Redis阻塞排查"></p><ul><li><p><strong>API或数据结构使用不合理</strong></p><p>通常Redis执行命令速度非常快，但是不合理地使用命令，可能会导致执行速度很慢，导致阻塞，对于高并发的场景，应该尽量避免在大对象上执行算法复杂 度超过O（n）的命令。</p><p>对慢查询的处理分为两步：</p><ol><li>发现慢查询： slowlog get{n}命令可以获取最近 的n条慢查询命令；</li><li>发现慢查询后，可以从两个方向去优化慢查询：<br>1）修改为低算法复杂度的命令，如hgetall改为hmget等，禁用keys、sort等命 令<br>2）调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据。</li></ol></li><li><p><strong>CPU饱和的问题</strong></p><p>单线程的Redis处理命令时只能使用一个CPU。而CPU饱和是指Redis单核CPU使用率跑到接近100%。</p><p>针对这种情况，处理步骤一般如下：</p><ol><li>判断当前Redis并发量是否已经达到极限，可以使用统计命令redis-cli-h{ip}-p{port}–stat获取当前 Redis使用情况</li><li>如果Redis的请求几万+，那么大概就是Redis的OPS已经到了极限，应该做集群化水平扩展来分摊OPS压力</li><li>如果只有几百几千，那么就得排查命令和内存的使用</li></ol></li><li><p><strong>持久化相关的阻塞</strong></p><p>对于开启了持久化功能的Redis节点，需要排查是否是持久化导致的阻塞。</p><ol><li>fork阻塞<br>fork操作发生在RDB和AOF重写时，Redis主线程调用fork操作产生共享内存的子进程，由子进程完成持久化文件重写工作。如果fork操作本身耗时过长，必然会导致主线程的阻塞。</li><li>AOF刷盘阻塞<br>当我们开启AOF持久化功能时，文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做fsync操作。当硬盘压力过大时，fsync操作需要等 待，直到写入完成。如果主线程发现距离上一次的fsync成功超过2秒，为了 数据安全性它会阻塞直到后台线程执行fsync操作完成。</li><li>HugePage写操作阻塞<br>对于开启Transparent HugePages的 操作系统，每次写命令引起的复制内存页单位由4K变为2MB，放大了512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。</li></ol></li></ul><h3 id="38-大key问题了解吗？">38.大key问题了解吗？</h3><p>Redis使用过程中，有时候会出现大key的情况， 比如：</p><ul><li>单个简单的key存储的value很大，size超过10KB</li><li>hash， set，zset，list 中存储过多的元素（以万为单位）</li></ul><blockquote><p><strong>大key会造成什么问题呢？</strong></p></blockquote><ul><li>客户端耗时增加，甚至超时</li><li>对大key进行IO操作时，会严重占用带宽和CPU</li><li>造成Redis集群中数据倾斜</li><li>主动删除、被动删等，可能会导致阻塞</li></ul><blockquote><p><strong>如何找到大key?</strong></p></blockquote><ul><li>bigkeys命令：使用bigkeys命令以遍历的方式分析Redis实例中的所有Key，并返回整体统计信息与每个数据类型中Top1的大Key</li><li>redis-rdb-tools：redis-rdb-tools是由Python写的用来分析Redis的rdb快照文件用的工具，它可以把rdb快照文件生成json文件或者生成报表用来分析Redis的使用详情。</li></ul><blockquote><p><strong>如何处理大key?</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/31/6YRtSMCzZngKQP9.png" alt="大key处理"></p><ul><li><p><strong>删除大key</strong></p><ul><li>当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够以非阻塞的方式，逐步地清理传入的Key。</li><li>当Redis版本小于4.0时，避免使用阻塞式命令KEYS，而是建议通过SCAN命令执行增量迭代扫描key，然后判断进行删除。</li></ul></li><li><p><strong>压缩和拆分key</strong></p><ul><li>当vaule是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。</li><li>当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</li><li>当value是list/set等集合类型时，根据预估的数据规模来进行分片，不同的元素计算后分到不同的片。</li></ul></li></ul><h3 id="39-Redis常见性能问题和解决方案？">39.Redis常见性能问题和解决方案？</h3><ol><li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li><li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li><li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li><li>尽量避免在压力较大的主库上增加从库。</li><li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li><li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li></ol><h2 id="Redis应用">Redis应用</h2><h3 id="40-使用Redis-如何实现异步队列？">40.使用Redis 如何实现异步队列？</h3><p>我们知道redis支持很多种结构的数据，那么如何使用redis作为异步队列使用呢？<br>一般有以下几种方式：</p><ul><li><strong>使用list作为队列，lpush生产消息，rpop消费消息</strong></li></ul><p>这种方式，消费者死循环rpop从队列中消费消息。但是这样，即使队列里没有消息，也会进行rpop，会导致Redis CPU的消耗。<br><img src="https://s2.loli.net/2023/03/31/l5Wo9ejRruynHTp.png" alt="list作为队列"><br>可以通过让消费者休眠的方式的方式来处理，但是这样又会又消息的延迟问题。</p><p>-<strong>使用list作为队列，lpush生产消息，brpop消费消息</strong></p><p>brpop是rpop的阻塞版本，list为空的时候，它会一直阻塞，直到list中有值或者超时。<br><img src="https://s2.loli.net/2023/03/31/hlfq3xFEurIowKX.png" alt="list作为队列，brpop"></p><p>这种方式只能实现一对一的消息队列。</p><ul><li><strong>使用Redis的pub/sub来进行消息的发布/订阅</strong></li></ul><p>发布/订阅模式可以1：N的消息发布/订阅。发布者将消息发布到指定的频道频道（channel），订阅相应频道的客户端都能收到消息。</p><p><img src="https://s2.loli.net/2023/03/31/cbepL1OJEw2PG59.png" alt="pub/sub"><br>但是这种方式不是可靠的，它不保证订阅者一定能收到消息，也不进行消息的存储。</p><p>所以，一般的异步队列的实现还是交给专业的消息队列。</p><h3 id="41-Redis-如何实现延时队列">41.Redis 如何实现延时队列?</h3><ul><li><strong>使用zset，利用排序实现</strong></li></ul><p>可以使用 zset这个结构，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 …命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。<br><img src="https://s2.loli.net/2023/03/31/J4cHKhDG7bRxfgW.png" alt="zset实现延时队列"></p><h3 id="42-Redis-支持事务吗？">42.Redis 支持事务吗？</h3><p>Redis提供了简单的事务，但它对事务ACID的支持并不完备。</p><p>multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; multi </span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd user:a:follow user:b </span><br><span class="line">QUEUED </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd user:b:fans user:a </span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember user:a:follow user:b </span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exec <span class="number">1</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Redis事务的原理，是所有的指令在 exec 之前不执行，而是缓存在<br>服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。<br><img src="https://s2.loli.net/2023/03/31/51bz9xF3emvBSD8.png" alt="Redis事务"></p><p>因为Redis执行命令是单线程的，所以这组命令顺序执行，而且不会被其它线程打断。</p><p><strong>Redis事务的注意点有哪些？</strong></p><p>需要注意的点有：</p><ul><li><p>Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；</p></li><li><p>Redis 服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。</p></li></ul><p><strong>Redis 事务为什么不支持回滚？</strong></p><p>Redis 的事务不支持回滚。</p><p>如果执行的命令有语法错误，Redis 会执行失败，这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。</p><p>这样做的原因是因为回滚需要增加很多工作，而不支持回滚则可以<strong>保持简单、快速的特性</strong>。</p><h3 id="43-Redis和Lua脚本的使用了解吗？">43.Redis和Lua脚本的使用了解吗？</h3><p>Redis的事务功能比较简单，平时的开发中，可以利用Lua脚本来增强Redis的命令。</p><p>Lua脚本能给开发人员带来这些好处：</p><ul><li>Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。</li><li>Lua脚本可以帮助开发和运维人员创造出自己定制的命令，并可以将这 些命令常驻在Redis内存中，实现复用的效果。</li><li>Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</li></ul><p>比如这一段很（烂）经（大）典（街）的秒杀系统利用lua扣减Redis库存的脚本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 库存未预热</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">2</span>]) == <span class="number">1</span>) then</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">9</span>;</span><br><span class="line"> end;</span><br><span class="line"> -- 秒杀商品库存存在</span><br><span class="line"> <span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">1</span>) then</span><br><span class="line">     <span class="type">local</span> <span class="variable">stock</span> <span class="operator">=</span> tonumber(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]));</span><br><span class="line">     <span class="type">local</span> <span class="variable">num</span> <span class="operator">=</span> tonumber(ARGV[<span class="number">1</span>]);</span><br><span class="line">     -- 剩余库存少于请求数量</span><br><span class="line">     <span class="keyword">if</span> (stock &lt; num) then</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">3</span></span><br><span class="line">     end;</span><br><span class="line">     -- 扣减库存</span><br><span class="line">     <span class="keyword">if</span> (stock &gt;= num) then</span><br><span class="line">         redis.call(<span class="string">&#x27;incrby&#x27;</span>, KEYS[<span class="number">1</span>], <span class="number">0</span> - num);</span><br><span class="line">         -- 扣减成功</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">     end;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line"> end;</span><br><span class="line"> -- 秒杀商品库存不存在</span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="44-Redis的管道了解吗？">44.Redis的管道了解吗？</h3><p>Redis 提供三种将客户端多条命令打包发送给服务端执行的方式：</p><p>Pipelining(管道) 、 Transactions(事务) 和 Lua Scripts(Lua 脚本) 。</p><p><strong>Pipelining</strong>（管道）</p><p>Redis 管道是三者之中最简单的，当客户端需要执行多条 redis 命令时，可以通过管道一次性将要执行的多条命令发送给服务端，其作用是为了降低 RTT(Round Trip Time) 对性能的影响，比如我们使用 nc 命令将两条指令发送给 redis 服务端。</p><p>Redis 服务端接收到管道发送过来的多条命令后，会一直执命令，并将命令的执行结果进行缓存，直到最后一条命令执行完成，再所有命令的执行结果一次性返回给客户端 。<br><img src="https://s2.loli.net/2023/03/31/6KbZEQNoJaufVI3.png" alt="Pipelining示意图`"></p><p><strong>Pipelining的优势</strong></p><p>在性能方面， Pipelining 有下面两个优势：</p><ul><li><strong>节省了RTT</strong>：将多条命令打包一次性发送给服务端，减少了客户端与服务端之间的网络调用次数</li><li><strong>减少了上下文切换</strong>：当客户端/服务端需要从网络中读写数据时，都会产生一次系统调用，系统调用是非常耗时的操作，其中设计到程序由用户态切换到内核态，再从内核态切换回用户态的过程。当我们执行 10 条 redis 命令的时候，就会发生 10 次用户态到内核态的上下文切换，但如果我们使用 Pipeining 将多条命令打包成一条一次性发送给服务端，就只会产生一次上下文切换。</li></ul><h3 id="45-Redis实现分布式锁了解吗？">45.Redis实现分布式锁了解吗？</h3><p>Redis是分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p><ul><li><strong>V1：setnx命令</strong></li></ul><p>占坑一般是使用 setnx(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 del 指令释放茅坑。<br><img src="https://s2.loli.net/2023/03/31/jNszkaR8K9VIcdJ.png" alt="setnx(set if not exists)"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:fighter <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:fighter</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p><ul><li><strong>V2:锁超时释放</strong></li></ul><p>所以在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。<br><img src="https://s2.loli.net/2023/03/31/mljCQBkhFSP7us9.png" alt="锁超时释放"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:fighter <span class="literal">true</span></span><br><span class="line">OK</span><br><span class="line">&gt; expire lock:fighter <span class="number">5</span></span><br><span class="line">... <span class="keyword">do</span> something critical ...</span><br><span class="line">&gt; del lock:fighter</span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是以上逻辑还有问题。如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p><p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。</p><ul><li><strong>V3:set指令</strong></li></ul><p>这个问题在Redis 2.8 版本中得到了解决，这个版本加入了 set 指令的扩展参数，使得 setnx 和expire 指令可以一起执行。<br><img src="https://s2.loli.net/2023/03/31/SEu986nrBaGq1xR.png" alt="set原子指令"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set lock:fighter3 <span class="literal">true</span> ex <span class="number">5</span> nx OK ... <span class="keyword">do</span> something critical ... &gt; del lock:codehole</span><br></pre></td></tr></table></figure><p>上面这个指令就是 setnx 和 expire 组合在一起的原子指令，这个就算是比较完善的分布式锁了。</p><p>当然实际的开发，没人会去自己写分布式锁的命令，因为有专业的轮子——<strong>Redisson</strong>。</p><h2 id="底层结构">底层结构</h2><p>这一部分就比较深了，如果不是简历上写了精通Redis，应该不会怎么问。</p><h3 id="46-说说Redis底层数据结构？">46.说说Redis底层数据结构？</h3><p>Redis有<strong>动态字符串(sds)</strong>、<strong>链表(list)</strong>、<strong>字典(ht)</strong>、<strong>跳跃表(skiplist)</strong>、<strong>整数集合(intset)</strong>、<strong>压缩列表(ziplist)</strong> 等底层数据结构。</p><p>Redis并没有使用这些数据结构来直接实现键值对数据库，而是基于这些数据结构创建了一个对象系统，来表示所有的key-value。</p><p><img src="https://s2.loli.net/2023/03/31/jACvZrzmLsg8yGU.png" alt="redisObject对应的映射"><br>我们常用的数据类型和编码对应的映射关系：</p><p><img src="https://s2.loli.net/2023/03/31/2F1Ejty8cD43MTx.png" alt="类型-编码-结构"><br>简单看一下底层数据结构，如果对数据结构掌握不错的话，理解这些结构应该不是特别难：</p><ol><li><p><strong>字符串</strong>：redis没有直接使⽤C语⾔传统的字符串表示，⽽是⾃⼰实现的叫做简单动态字符串SDS的抽象类型。</p><p>C语⾔的字符串不记录⾃身的⻓度信息，⽽SDS则保存了⻓度信息，这样将获取字符串⻓度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串⻓度时所需的内存重分配次数。</p></li></ol><p><img src="https://s2.loli.net/2023/03/31/zXyFiT4wCnQtJW2.png" alt="SDS"></p><ol start="2"><li><strong>链表linkedlist</strong>：redis链表是⼀个双向⽆环链表结构，很多发布订阅、慢查询、监视器功能都是使⽤到了链表来实现，每个链表的节点由⼀个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。</li></ol><p><img src="https://s2.loli.net/2023/03/31/TDHNjxeh4J9bVcq.png" alt="链表linkedlist"></p><ol start="3"><li><p><strong>字典dict</strong>：⽤于保存键值对的抽象数据结构。Redis使⽤hash表作为底层实现，一个哈希表里可以有多个哈希表节点，而每个哈希表节点就保存了字典里中的一个键值对。<br>每个字典带有两个hash表，供平时使⽤和rehash时使⽤，hash表使⽤链地址法来解决键冲突，被分配到同⼀个索引位置的多个键值对会形成⼀个单向链表，在对hash表进⾏扩容或者缩容的时候，为了服务的可⽤性，rehash的过程不是⼀次性完成的，⽽是渐进式的。<br><img src="https://s2.loli.net/2023/03/31/HPbJDslwaORcMnZ.png" alt="字典"></p></li><li><p><strong>跳跃表skiplist</strong>：跳跃表是有序集合的底层实现之⼀，Redis中在实现有序集合键和集群节点的内部结构中都是⽤到了跳跃表。Redis跳跃表由zskiplist和zskiplistNode组成，zskiplist⽤于保存跳跃表信息（表头、表尾节点、⻓度等），zskiplistNode⽤于表示表跳跃节点，每个跳跃表节点的层⾼都是1-32的随机数，在同⼀个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯⼀的，节点按照分值⼤⼩排序，如果分值相同，则按照成员对象的⼤⼩排序。<br><img src="https://s2.loli.net/2023/03/31/2REXYSprcfdxBIy.png" alt="跳跃表"></p></li><li><p><strong>整数集合intset</strong>：⽤于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。<br><img src="https://s2.loli.net/2023/03/31/wvdEpWPuVYQCR8o.png" alt="整数集合intset"></p></li><li><p><strong>压缩列表ziplist</strong>：压缩列表是为节约内存⽽开发的顺序性数据结构，它可以包含任意多个节点，每个节点可以保存⼀个字节数组或者整数值。</p></li></ol><p><img src="https://s2.loli.net/2023/03/31/wNUh9QagqpSDcYG.png" alt="压缩列表组成"></p><h3 id="47-Redis-的-SDS-和-C-中字符串相比有什么优势？">47.Redis 的 SDS 和 C 中字符串相比有什么优势？</h3><p>C 语言使用了一个长度为 <code>N+1</code> 的字符数组来表示长度为 <code>N</code> 的字符串，并且字符数组最后一个元素总是 <code>\0</code>，这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。</p><p><img src="https://s2.loli.net/2023/03/31/IsK6ghuQYkN7Paz.png" alt="C语言的字符串"></p><blockquote><p><strong>C语言的字符串可能有什么问题？</strong></p></blockquote><p>这样简单的数据结构可能会造成以下一些问题：</p><ul><li><strong>获取字符串长度复杂度高</strong> ：因为 C 不保存数组的长度，每次都需要遍历一遍整个数组，时间复杂度为O(n)；</li><li>不能杜绝 <strong>缓冲区溢出/内存泄漏</strong> 的问题 : C字符串不记录自身长度带来的另外一个问题是容易造成缓存区溢出（buffer overflow），例如在字符串拼接的时候，新的</li><li>C 字符串 <strong>只能保存文本数据</strong> → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 <code>'\0'</code> 可能会被判定为提前结束的字符串而识别不了；</li></ul><blockquote><p><strong>Redis如何解决？优势？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/31/hfZ6e7RJyMEF4C5.png" alt="Redis sds"></p><p>简单来说一下 Redis 如何解决的：</p><ol><li><strong>多增加 len 表示当前字符串的长度</strong>：这样就可以直接获取长度了，复杂度 O(1)；</li><li><strong>自动扩展空间</strong>：当 SDS 需要对字符串进行修改时，首先借助于 <code>len</code> 和 <code>alloc</code> 检查空间是否满足修改所需的要求，如果空间不够的话，SDS 会自动扩展空间，避免了像 C 字符串操作中的溢出情况；</li><li><strong>有效降低内存分配次数</strong>：C 字符串在涉及增加或者清除操作时会改变底层数组的大小造成重新分配，SDS 使用了 <strong>空间预分配</strong> 和 <strong>惰性空间释放</strong> 机制，简单理解就是每次在扩展时是成倍的多分配的，在缩容是也是先留着并不正式归还给 OS；</li><li><strong>二进制安全</strong>：C 语言字符串只能保存 <code>ascii</code> 码，对于图片、音频等信息无法保存，SDS 是二进制安全的，写入什么读取就是什么，不做任何过滤和限制；</li></ol><h3 id="48-字典是如何实现的？Rehash-了解吗？">48.字典是如何实现的？Rehash 了解吗？</h3><p>字典是 Redis 服务器中出现最为频繁的复合型数据结构。除了 <strong>hash</strong> 结构的数据会用到字典外，整个 Redis 数据库的所有 <code>key</code> 和 <code>value</code> 也组成了一个 <strong>全局字典</strong>，还有带过期时间的 <code>key</code> 也是一个字典。<em>(存储在 RedisDb 数据结构中)</em></p><blockquote><p><strong>字典结构是什么样的呢？</strong></p></blockquote><p><strong>Redis</strong> 中的字典相当于 Java 中的 <strong>HashMap</strong>，内部实现也差不多类似，采用哈希与运算计算下标位置；通过 <strong>“数组 + 链表” <strong>的</strong>链地址法</strong> 来解决哈希冲突，同时这样的结构也吸收了两种不同数据结构的优点。<br><img src="https://s2.loli.net/2023/03/31/VHGnfDz7kEOSLTU.png" alt="Redis字典结构"></p><blockquote><p><strong>字典是怎么扩容的？</strong></p></blockquote><p>字典结构内部包含 <strong>两个 hashtable</strong>，通常情况下只有一个哈希表 ht[0] 有值，在扩容的时候，把ht[0]里的值rehash到ht[1]，然后进行 <strong>渐进式rehash</strong> ——所谓渐进式rehash，指的是这个rehash的动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>待搬迁结束后，h[1]就取代h[0]存储字典的元素。</p><h3 id="49-跳跃表是如何实现的？原理？">49.跳跃表是如何实现的？原理？</h3><p>PS:跳跃表是比较常问的一种结构。</p><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。<br><img src="https://s2.loli.net/2023/03/31/sGADHfUvLFNWJBw.png" alt="跳跃表"></p><blockquote><p><strong>为什么使用跳跃表?</strong></p></blockquote><p>首先，因为 zset 要支持随机的插入和删除，所以它 <strong>不宜使用数组来实现</strong>，关于排序问题，我们也很容易就想到 <strong>红黑树/ 平衡树</strong> 这样的树形结构，为什么 Redis 不使用这样一些结构呢？</p><ol><li><strong>性能考虑：</strong> 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部；</li><li><strong>实现考虑：</strong> 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；</li></ol><p>基于以上的一些考虑，Redis 基于 <strong>William Pugh</strong> 的论文做出一些改进后采用了 <strong>跳跃表</strong> 这样的结构。</p><p>本质是解决查找问题。</p><blockquote><p><strong>跳跃表是怎么实现的？</strong></p></blockquote><p>跳跃表的节点里有这些元素：</p><ul><li><p><strong>层</strong><br>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其它节点的指针，程序可以通过这些层来加快访问其它节点的速度，一般来说，层的数量月多，访问其它节点的速度就越快。</p><p>每次创建一个新的跳跃表节点的时候，程序都根据幂次定律，随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”</p></li><li><p><strong>前进指针</strong><br>每个层都有一个指向表尾的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。</p><p>我们看一下跳跃表从表头到表尾，遍历所有节点的路径：<br><img src="https://s2.loli.net/2023/03/31/I28C56gPbvoJWwq.png" alt="通过前进指针遍历"></p></li><li><p><strong>跨度</strong><br>层的跨度用于记录两个节点之间的距离。跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p><p>例如查找，分值为3.0、成员对象为o3的节点时，沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的排位为3。<br><img src="https://s2.loli.net/2023/03/31/BCAN7xPhRgDp8qb.png" alt="计算节点的排位"></p></li><li><p><strong>分值和成员</strong><br>节点的分值（score属性）是一个double类型的浮点数，跳跃表中所有的节点都按分值从小到大来排序。</p><p>节点的成员对象（obj属性）是一个指针，它指向一个字符串对象，而字符串对象则保存这一个SDS值。</p></li></ul><h3 id="50-压缩列表了解吗？">50.压缩列表了解吗？</h3><p>压缩列表是 Redis <strong>为了节约内存</strong> 而使用的一种数据结构，是由一系列特殊编码的连续内存快组成的顺序型数据结构。</p><p>一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p><img src="https://s2.loli.net/2023/03/31/YFQa2z4ER7PLnm9.png" alt="压缩列表组成部分">压缩列表由这么几部分组成：</p><ul><li><strong>zlbyttes</strong>:记录整个压缩列表占用的内存字节数</li><li><strong>zltail</strong>:记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</li><li><strong>zllen</strong>:记录压缩列表包含的节点数量</li><li><strong>entryX</strong>:列表节点</li><li><strong>zlend</strong>:用于标记压缩列表的末端</li></ul><p><img src="https://s2.loli.net/2023/03/31/CpU6mtli7OKJWQj.png" alt="压缩列表示例"></p><h3 id="51-快速列表-quicklist-了解吗？">51.快速列表 quicklist 了解吗？</h3><p>Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是说当元素少时使用 ziplist，当元素多时用 linkedlist。</p><p>但考虑到链表的附加空间相对较高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16</code> 个字节（64 位操作系统占用 <code>8</code> 个字节），另外每个节点的内存都是单独分配，会家具内存的碎片化，影响内存管理效率。</p><p>后来 Redis 新版本（3.2）对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>，quicklist是综合考虑了时间效率与空间效率引入的新型数据结构。</p><p>quicklist由list和ziplist结合而成，它是一个由ziplist充当节点的双向链表。<br><img src="https://s2.loli.net/2023/03/31/nFbPhtGxamNWeYd.png" alt="quicklist"></p><h2 id="其他问题">其他问题</h2><h3 id="52-假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？">52.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3><p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。但是要注意 keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 <code>key</code> 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> redis篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring框架篇(修正版)</title>
      <link href="/posts/574cbe50.html"/>
      <url>/posts/574cbe50.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="1-Spring-是什么？特性？有哪些模块？">1.Spring 是什么？特性？有哪些模块？</h3><p><img src="https://s2.loli.net/2023/03/31/f9gxpnzM68cPAGy.jpg" alt="Spring Logo"></p><p>一句话概括：<strong>Spring 是一个轻量级、非入侵式的控制反转 (IoC) 和面向切面 (AOP) 的框架。</strong></p><p>2003 年，一个音乐家 Rod Johnson 决定发展一个轻量级的 Java 开发框架，<code>Spring</code>作为 Java 战场的龙骑兵渐渐崛起，并淘汰了<code>EJB</code>这个传统的重装骑兵。</p><p><img src="https://s2.loli.net/2023/03/31/lZiHcVFQj58tbO7.png" alt="Spring重要版本"></p><p>到了现在，企业级开发的标配基本就是 <strong>Spring5</strong> + <strong>Spring Boot 2</strong> + <strong>JDK 8</strong></p><blockquote><p>Spring 有哪些特性呢？</p></blockquote><p>Spring 有很多优点：</p><p><img src="https://s2.loli.net/2023/03/31/HEXlPZj3yBqmSzY.png" alt="Spring特性"></p><ol><li><strong>IOC</strong> 和 <strong>DI</strong> 的支持</li></ol><p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用于生成 Bean，并且管理 Bean 的生命周期，实现<strong>高内聚低耦合</strong>的设计理念。</p><ol start="2"><li>AOP 编程的支持</li></ol><p>Spring 提供了<strong>面向切面编程</strong>，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p><ol start="3"><li>声明式事务的支持</li></ol><p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提交、回滚的 JDBC 代码，都可以不用自己写了。</p><ol start="4"><li>快捷测试的支持</li></ol><p>Spring 对 Junit 提供支持，可以通过<strong>注解</strong>快捷地测试 Spring 程序。</p><ol start="5"><li>快速集成功能</li></ol><p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p><ol start="6"><li>复杂 API 模板封装</li></ol><p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板化的封装，这些封装 API 的提供使得应用难度大大降低。</p><h3 id="2-Spring-有哪些模块呢？">2.Spring 有哪些模块呢？</h3><p>Spring 框架是分模块存在，除了最核心的<code>Spring Core Container</code>是必要模块之外，其他模块都是<code>可选</code>，大约有 20 多个模块。</p><p><img src="https://s2.loli.net/2023/03/31/k51PvSHyzYcIDBb.jpg" alt="Spring模块划分"></p><p>最主要的七大模块：</p><ol><li><strong>Spring Core</strong>：Spring 核心，它是框架最基础的部分，提供 IOC 和依赖注入 DI 特性。</li><li><strong>Spring Context</strong>：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</li><li><strong>Spring Web</strong>：它提供 Web 应用开发的支持。</li><li><strong>Spring MVC</strong>：它针对 Web 应用中 MVC 思想的实现。</li><li><strong>Spring DAO</strong>：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</li><li><strong>Spring ORM</strong>：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等。</li><li><strong>Spring AOP</strong>：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</li></ol><h3 id="3-Spring-有哪些常用注解呢？">3.Spring 有哪些常用注解呢？</h3><p>Spring 有很多模块，甚至广义的 SpringBoot、SpringCloud 也算是 Spring 的一部分，我们来分模块，按功能来看一下一些常用的注解：</p><p><img src="https://s2.loli.net/2023/03/31/i5vcVlBt6pmwKqa.png" alt="Spring常用注解"></p><p><strong>Web</strong>:</p><ul><li>@Controller：组合注解（组合了@Component 注解），应用在 MVC 层（控制层）。</li><li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li><li>@RequestMapping：用于映射 Web 请求，包括访问路径和参数。如果是 Restful 风格接口，还可以根据请求类型使用不同的注解：<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ul></li><li>@ResponseBody：支持将返回值放在 response 内，而不是一个页面，通常用户返回 json 数据。</li><li>@RequestBody：允许 request 的参数在 request 体中，而不是在直接连接在地址后面。</li><li>@PathVariable：用于接收路径参数，比如 <code>@RequestMapping(“/hello/&#123;name&#125;”)</code>申明的路径，将注解放在参数中前，即可获取该值，通常作为 Restful 的接口实现方法。</li><li>@RestController：该注解为一个组合注解，相当于@Controller 和@ResponseBody 的组合，注解在类上，意味着，该 Controller 的所有方法都默认加上了@ResponseBody。</li></ul><p><strong>容器</strong>:</p><ul><li>@Component：表示一个带注释的类是一个“组件”，成为 Spring 管理的 Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component 还是一个元注解。</li><li>@Service：组合注解（组合了@Component 注解），应用在 service 层（业务逻辑层）。</li><li>@Repository：组合注解（组合了@Component 注解），应用在 dao 层（数据访问层）。</li><li>@Autowired：Spring 提供的工具（由 Spring 的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</li><li>@Qualifier：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解</li><li>@Configuration：声明当前类是一个配置类（相当于一个 Spring 配置的 xml 文件）</li><li>@Value：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 <code>#&#123;&#125; 跟 \$&#123;&#125;</code> 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。</li><li>@Bean：注解在方法上，声明当前方法的返回值为一个 Bean。返回的 Bean 对应的类中可以定义 init()方法和 destroy()方法，然后在<code>@Bean(initMethod=”init”,destroyMethod=”destroy”)</code>定义，在构造之后执行 init，在销毁之前执行 destroy。</li><li>@Scope:定义我们采用什么模式去创建 Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</li></ul><p><strong>AOP</strong>:</p><ul><li>@Aspect:声明一个切面（类上） 使用@After、@Before、@Around 定义建言（advice），可直接将拦截规则（切点）作为参数。<ul><li><code>@After</code> ：在方法执行之后执行（方法上）。</li><li><code>@Before</code>： 在方法执行之前执行（方法上）。</li><li><code>@Around</code>： 在方法执行之前与之后执行（方法上）。</li><li><code>@PointCut</code>： 声明切点 在 java 配置类中使用@EnableAspectJAutoProxy 注解开启 Spring 对 AspectJ 代理的支持（类上）。</li></ul></li></ul><p><strong>事务：</strong></p><ul><li>@Transactional：在要开启事务的方法上使用@Transactional 注解，即可声明式开启事务。</li></ul><h3 id="4-Spring-中应用了哪些设计模式呢？">4.Spring 中应用了哪些设计模式呢？</h3><p>Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p><p><img src="https://s2.loli.net/2023/03/31/LVYPF8TrIhMc5q3.png" alt="Spring中用到的设计模式"></p><ol><li><strong>工厂模式</strong> : Spring 容器本质是一个大工厂，使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li><strong>代理模式</strong> : Spring AOP 功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</li><li><strong>单例模式</strong> : Spring 中的 Bean 默认都是单例的，这样有利于容器对 Bean 的管理。</li><li><strong>模板模式</strong> : Spring 中 JdbcTemplate、RestTemplate 等以 Template 结尾的对数据库、网络等等进行操作的模板类，就使用到了模板模式。</li><li><strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 Controller。</li><li><strong>策略模式</strong>：Spring 中有一个 Resource 接口，它的不同实现类，会根据不同的策略去访问资源。</li></ol><h2 id="IOC">IOC</h2><h3 id="5-说一说什么是-IOC？什么是-DI">5.说一说什么是 IOC？什么是 DI?</h3><p>Java 是面向对象的编程语言，一个个实例对象相互合作组成了业务逻辑，原来，我们都是在代码里创建对象和对象的依赖。</p><p>所谓的<strong>IOC</strong>（控制反转）：就是由容器来负责控制对象的生命周期和对象间的关系。以前是我们想要什么，就自己创建什么，现在是我们需要什么，容器就给我们送来什么。</p><p><img src="https://s2.loli.net/2023/03/31/F39A2qxaXVhTcvl.png" alt="引入IOC之前和引入IOC之后"></p><p>也就是说，控制对象生命周期的不再是引用它的对象，而是容器。对具体对象，以前是它控制其它对象，现在所有对象都被容器控制，所以这就叫<strong>控制反转</strong>。</p><p><img src="https://s2.loli.net/2023/03/31/ZVapjhwkT38GMyq.png" alt="控制反转示意图"></p><p><strong>DI（依赖注入）</strong>：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法 IOC 和 DI 是一回事，有的说法是 IOC 是思想，DI 是 IOC 的实现。</p><blockquote><p><strong>为什么要使用 IOC 呢？</strong></p></blockquote><p>最主要的是两个字<strong>解耦</strong>，硬编码会造成对象间的过度耦合，使用 IOC 之后，我们可以不用关心对象间的依赖，专心开发应用就行。</p><h3 id="6-能简单说一下-Spring-IOC-的实现机制吗？">6.能简单说一下 Spring IOC 的实现机制吗？</h3><p>PS:这道题老三在面试中被问到过，问法是“<strong>你有自己实现过简单的 Spring 吗？</strong>”</p><p>Spring 的 IOC 本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？</p><p><img src="https://s2.loli.net/2023/03/31/1kSWKaNEdtqrFy9.png" alt="工厂运行"></p><ul><li><p><strong>生产产品</strong>：一个工厂最核心的功能就是生产产品。在 Spring 里，不用 Bean 自己来实例化，而是交给 Spring，应该怎么实现呢？——答案毫无疑问，<strong>反射</strong>。</p><p>那么这个厂子的生产管理是怎么做的？你应该也知道——<strong>工厂模式</strong>。</p></li><li><p><strong>库存产品</strong>：工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring 我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</p></li><li><p><strong>订单处理</strong>：还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。</p><p>在 Spring 里，也有这样的订单，它就是我们 bean 的定义和依赖关系，可以是 xml 形式，也可以是我们最熟悉的注解形式。</p></li></ul><p>我们简单地实现一个 mini 版的 Spring IOC：</p><p><img src="https://s2.loli.net/2023/03/31/T9u8xyQVWkqF54o.png" alt="mini版本Spring IOC"></p><p><strong>Bean 定义：</strong></p><p>Bean 通过一个配置文件定义，把它解析成一个类型。</p><ul><li><p>beans.properties</p><p>偷懒，这里直接用了最方便解析的 properties，这里直接用一个<code>&lt;key,value&gt;</code>类型的配置来代表 Bean 的定义，其中 key 是 beanName，value 是 class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userDao:cn.fighter3.bean.UserDao</span><br></pre></td></tr></table></figure></li><li><p>BeanDefinition.java</p><p>bean 定义类，配置文件中 bean 定义对应的实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class beanClass;</span><br><span class="line">     <span class="comment">//省略getter、setter</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>ResourceLoader.java</p><p>资源加载器，用来完成配置文件中配置的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, BeanDefinition&gt; <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> ResourceLoader.class.getResourceAsStream(<span class="string">&quot;/beans.properties&quot;</span>);</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            Iterator&lt;String&gt; it = properties.stringPropertyNames().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">                <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">                beanDefinition.setBeanName(key);</span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                beanDefinition.setBeanClass(clazz);</span><br><span class="line">                beanDefinitionMap.put(key, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BeanRegister.java</p><p>对象注册器，这里用于单例 bean 的缓存，我们大幅简化，默认所有 bean 都是单例的。可以看到所谓单例注册，也很简单，不过是往 HashMap 里存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanRegister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例Bean缓存</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例Bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingletonBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> singletonMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册单例bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingletonBean</span><span class="params">(String beanName, Object bean)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonMap.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        singletonMap.put(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>BeanFactory.java</strong></p></li></ul><p><img src="https://s2.loli.net/2023/03/31/yVnkD6fto7KH5qs.png" alt="BeanFactory"></p><ul><li><p>对象工厂，我们最<strong>核心</strong>的一个类，在它初始化的时候，创建了 bean 注册器，完成了资源的加载。</p></li><li><p>获取 bean 的时候，先从单例缓存中取，如果没有取到，就创建并注册一个 bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanRegister beanRegister;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建bean注册器</span></span><br><span class="line">        beanRegister = <span class="keyword">new</span> <span class="title class_">BeanRegister</span>();</span><br><span class="line">        <span class="comment">//加载资源</span></span><br><span class="line">        <span class="built_in">this</span>.beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ResourceLoader</span>().getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">//从bean缓存中取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanRegister.getSingletonBean(beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据bean定义，创建bean</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanDefinitionMap.get(beanName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinition bean定义</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanDefinition.getBeanClass().newInstance();</span><br><span class="line">            <span class="comment">//缓存bean</span></span><br><span class="line">            beanRegister.registerSingletonBean(beanDefinition.getBeanName(), bean);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li><p>UserDao.java</p><p>我们的 Bean 类，很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUserInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A good man.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单元测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建bean工厂(同时完成了加载资源、创建注册单例bean注册器的操作)</span></span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.第一次获取bean（通过反射创建bean，缓存bean）</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) beanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao1.queryUserInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.第二次获取bean（从缓存中获取bean）</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) beanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao2.queryUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A good man.</span><br><span class="line">A good man.</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>至此，我们一个乞丐+破船版的 Spring 就完成了，代码也比较完整，有条件的可以跑一下。</p><p>PS:因为时间+篇幅的限制，这个 demo 比较简陋，没有面向接口、没有解耦、边界检查、异常处理……健壮性、扩展性都有很大的不足，感兴趣可以学习参考[15]。</p><h3 id="7-说说-BeanFactory-和-ApplicantContext">7.说说 BeanFactory 和 ApplicantContext?</h3><p>可以这么形容，BeanFactory 是 Spring 的“心脏”，ApplicantContext 是完整的“身躯”。</p><p><img src="https://s2.loli.net/2023/03/31/OfiHudNrSXL5ZjJ.png" alt="BeanFactory和ApplicantContext的比喻"></p><ul><li>BeanFactory（Bean 工厂）是 Spring 框架的基础设施，面向 Spring 本身。</li><li>ApplicantContext（应用上下文）建立在 BeanFactoty 基础上，面向使用 Spring 框架的开发者。</li></ul><h4 id="BeanFactory-接口">BeanFactory 接口</h4><p>BeanFactory 是类的通用工厂，可以创建并管理各种类的对象。</p><p>Spring 为 BeanFactory 提供了很多种实现，最常用的是 XmlBeanFactory，但在 Spring 3.2 中已被废弃，建议使用 XmlBeanDefinitionReader、DefaultListableBeanFactory。</p><p><img src="https://s2.loli.net/2023/03/31/wb4fL95DPtcjpZE.png" alt="Spring5 BeanFactory继承体系"></p><p>BeanFactory 接口位于类结构树的顶端，它最主要的方法就是 getBean(String var1)，这个方法从容器中返回特定名称的 Bean。</p><p>BeanFactory 的功能通过其它的接口得到了不断的扩展，比如 AbstractAutowireCapableBeanFactory 定义了将容器中的 Bean 按照某种规则（比如按名字匹配、按类型匹配等）进行自动装配的方法。</p><p>这里看一个 XMLBeanFactory（已过期） 获取 bean 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldApp</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">BeanFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span> (<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;beans.xml&quot;</span>));</span><br><span class="line">      <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) factory.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">      obj.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext-接口">ApplicationContext 接口</h4><p>ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。可以这么说，使用 BeanFactory 就是手动档，使用 ApplicationContext 就是自动档。</p><p><img src="https://s2.loli.net/2023/03/31/SblKF6NHTLIpUJa.png" alt="Spring5 ApplicationContext部分体系类图"></p><p>ApplicationContext 继承了 HierachicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过其他的接口扩展了 BeanFactory 的功能，包括：</p><ul><li><p>Bean instantiation/wiring</p></li><li><p>Bean 的实例化/串联</p></li><li><p>自动的 BeanPostProcessor 注册</p></li><li><p>自动的 BeanFactoryPostProcessor 注册</p></li><li><p>方便的 MessageSource 访问（i18n）</p></li><li><p>ApplicationEvent 的发布与 BeanFactory 懒加载的方式不同，它是预加载，所以，每一个 bean 都在 ApplicationContext 启动之后实例化</p></li></ul><p>这是 ApplicationContext 的使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldApp</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      ApplicationContext context=<span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">      <span class="type">HelloWorld</span> <span class="variable">obj</span> <span class="operator">=</span> (HelloWorld) context.getBean(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">      obj.getMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext 包含 BeanFactory 的所有特性，通常推荐使用前者。</p><h3 id="8-你知道-Spring-容器启动阶段会干什么吗？">8.你知道 Spring 容器启动阶段会干什么吗？</h3><p>PS：这道题老三面试被问到过</p><p>Spring 的 IOC 容器工作的过程，其实可以划分为两个阶段：<strong>容器启动阶段</strong>和<strong>Bean 实例化阶段</strong>。</p><p>其中容器启动阶段主要做的工作是加载和解析配置文件，保存到对应的 Bean 定义中。</p><p><img src="https://s2.loli.net/2023/03/31/FPUgdVCYXl3ahEv.png" alt="容器启动和Bean实例化阶段"></p><p>容器启动开始，首先会通过某种途径加载 Congiguration MetaData，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的 Congiguration MetaData 进行解析和分析，并将分析后的信息组为相应的 BeanDefinition。</p><p><img src="https://s2.loli.net/2023/03/31/VyF14RublsY2zf6.png" alt="xml配置信息映射注册过程"></p><p>最后把这些保存了 Bean 定义必要信息的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器启动就完成了。</p><h3 id="9-能说一下-Spring-Bean-生命周期吗？">9.能说一下 Spring Bean 生命周期吗？</h3><p>可以看看：<a href="https://mp.weixin.qq.com/s/zb6eA3Se0gQoqL8PylCPLw">Spring Bean 生命周期，好像人的一生。。</a></p><p>在 Spring 中，基本容器 BeanFactory 和扩展容器 ApplicationContext 的实例化时机不太一样，BeanFactory 采用的是延迟初始化的方式，也就是只有在第一次 getBean()的时候，才会实例化 Bean；ApplicationContext 启动之后会实例化所有的 Bean 定义。</p><p>Spring IOC 中 Bean 的生命周期大致分为四个阶段：<strong>实例化</strong>（Instantiation）、<strong>属性赋值</strong>（Populate）、<strong>初始化</strong>（Initialization）、<strong>销毁</strong>（Destruction）。</p><p><img src="https://s2.loli.net/2023/03/31/I9RGD3xq4shQzi2.png" alt="Bean生命周期四个阶段"></p><p>我们再来看一个稍微详细一些的过程：</p><ul><li><strong>实例化</strong>：第 1 步，实例化一个 Bean 对象</li><li><strong>属性赋值</strong>：第 2 步，为 Bean 设置相关属性和依赖</li><li><strong>初始化</strong>：初始化的阶段的步骤比较多，5、6 步是真正的初始化，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean 就可以被使用了</li><li><strong>销毁</strong>：第 8~10 步，第 8 步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接口，为了后面第 9、10 步真正销毁 Bean 时再执行相应的方法</li></ul><p><img src="https://s2.loli.net/2023/03/31/85MxyiFbJUtYawc.png" alt="SpringBean生命周期"></p><p>简单总结一下，Bean 生命周期里初始化的过程相对步骤会多一些，比如前置、后置的处理。</p><p>最后通过一个实例来看一下具体的细节：<br><img src="https://s2.loli.net/2023/03/31/Zi3qTgGnFIwD2YC.png" alt="Bean一生实例"></p><ul><li>定义一个<code>PersonBean</code>类，实现<code>DisposableBean</code>,<code>InitializingBean</code>, <code>BeanFactoryAware</code>, <code>BeanNameAware</code>这 4 个接口，同时还有自定义的<code>init-method</code>和<code>destroy-method</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, BeanFactoryAware, BeanNameAware, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份证号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer no;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.调用构造方法：我出生了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(Integer no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.设置属性：我的名字叫&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.调用BeanNameAware#setBeanName方法:我要上学了，起了个学名&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4.调用BeanFactoryAware#setBeanFactory方法：选好学校了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6.InitializingBean#afterPropertiesSet方法：入学登记&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7.自定义init方法：努力上学ing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9.DisposableBean#destroy方法：平淡的一生落幕了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10.自定义destroy方法:睡了，别想叫醒我&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean使用中：工作，只有对社会没有用的人才放假。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义一个<code>MyBeanPostProcessor</code>实现<code>BeanPostProcessor</code>接口。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5.BeanPostProcessor.postProcessBeforeInitialization方法：到学校报名啦&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8.BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>配置文件，指定<code>init-method</code>和<code>destroy-method</code>属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=<span class="string">&quot;myBeanPostProcessor&quot;</span> class=<span class="string">&quot;cn.fighter3.spring.life.MyBeanPostProcessor&quot;</span> /&gt;</span><br><span class="line">    &lt;bean name=<span class="string">&quot;personBean&quot;</span> class=<span class="string">&quot;cn.fighter3.spring.life.PersonBean&quot;</span></span><br><span class="line">          init-method=<span class="string">&quot;init&quot;</span> destroy-method=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;idNo&quot;</span> value= <span class="string">&quot;80669865&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;张铁钢&quot;</span> /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">PersonBean</span> <span class="variable">personBean</span> <span class="operator">=</span> (PersonBean) context.getBean(<span class="string">&quot;personBean&quot;</span>);</span><br><span class="line">        personBean.work();</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>运行结果：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>调用构造方法：我出生了！</span><br><span class="line"><span class="number">2.</span>设置属性：我的名字叫张铁钢</span><br><span class="line"><span class="number">3.</span>调用BeanNameAware#setBeanName方法:我要上学了，起了个学名</span><br><span class="line"><span class="number">4.</span>调用BeanFactoryAware#setBeanFactory方法：选好学校了</span><br><span class="line"><span class="number">5.</span>BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦</span><br><span class="line"><span class="number">6.</span>InitializingBean#afterPropertiesSet方法：入学登记</span><br><span class="line"><span class="number">7.</span>自定义init方法：努力上学ing</span><br><span class="line"><span class="number">8.</span>BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证啦！</span><br><span class="line">Bean使用中：工作，只有对社会没有用的人才放假。。</span><br><span class="line"><span class="number">9.</span>DisposableBean#destroy方法：平淡的一生落幕了</span><br><span class="line"><span class="number">10.</span>自定义destroy方法:睡了，别想叫醒我</span><br></pre></td></tr></table></figure><p>关于源码，Bean 创建过程可以查看<code>AbstractBeanFactory#doGetBean</code>方法，在这个方法里可以看到 Bean 的实例化，赋值、初始化的过程，至于最终的销毁，可以看看<code>ConfigurableApplicationContext#close()</code>。</p><p><img src="https://s2.loli.net/2023/03/31/EAY9hC53kJwajz8.png" alt="Bean生命周期源码追踪"></p><h3 id="10-Bean-定义和依赖定义有哪些方式？">10.Bean 定义和依赖定义有哪些方式？</h3><p>有三种方式：<strong>直接编码方式</strong>、<strong>配置文件方式</strong>、<strong>注解方式</strong>。</p><p><img src="https://s2.loli.net/2023/03/31/i6csSLZEVWnUKyG.png" alt="Bean依赖配置方式"></p><ul><li>直接编码方式：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。</li><li>配置文件方式：通过 xml、propreties 类型的配置文件，配置相应的依赖关系，Spring 读取配置文件，完成依赖关系的注入。</li><li>注解方式：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring 会扫描注解，完成依赖关系的注入。</li></ul><h3 id="11-有哪些依赖注入的方法？">11.有哪些依赖注入的方法？</h3><p>Spring 支持<strong>构造方法注入</strong>、<strong>属性注入</strong>、<strong>工厂方法注入</strong>,其中工厂方法注入，又可以分为<strong>静态工厂方法注入</strong>和<strong>非静态工厂方法注入</strong>。</p><p><img src="https://s2.loli.net/2023/03/31/YyU3GKgRC8uVFq7.png" alt="Spring依赖注入方法"></p><ul><li><p><strong>构造方法注入</strong></p><p>通过调用类的构造方法，将接口实现类通过构造方法变量传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CatDaoImpl</span><span class="params">(String message)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>. message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;CatDaoImpl&quot;</span> class=<span class="string">&quot;com.CatDaoImpl&quot;</span>&gt;</span><br><span class="line">  &lt;constructor-arg value=<span class="string">&quot; message &quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>属性注入</strong></p><p>通过 Setter 方法完成调用类所需依赖的注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Id</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123; <span class="built_in">this</span>.id = id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;id&quot;</span> class=<span class="string">&quot;com.id &quot;</span>&gt;</span><br><span class="line">  &lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;123&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>工厂方法注入</strong></p><ul><li><p><strong>静态工厂注入</strong></p><p>静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 Spring 管理所有对象，我们不能直接通过&quot;工程类.静态方法()&quot;来获取对象，而是依然通过 Spring 注入的形式获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123; <span class="comment">//静态工厂</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title function_">getStaticFactoryDaoImpl</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StaticFacotryDaoImpl</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAction</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//注入对象</span></span><br><span class="line"> <span class="keyword">private</span> FactoryDao staticFactoryDao;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//注入对象的 set 方法</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStaticFactoryDao</span><span class="params">(FactoryDao staticFactoryDao)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.staticFactoryDao = staticFactoryDao;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span></span><br><span class="line"> &lt;bean name=<span class="string">&quot;springAction&quot;</span> class=<span class="string">&quot; SpringAction&quot;</span> &gt;</span><br><span class="line">   &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line">   &lt;property name=<span class="string">&quot;staticFactoryDao&quot;</span> ref=<span class="string">&quot;staticFactoryDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;</span><br><span class="line">&lt;bean name=<span class="string">&quot;staticFactoryDao&quot;</span> class=<span class="string">&quot;DaoFactory&quot;</span></span><br><span class="line">  factory-method=<span class="string">&quot;getStaticFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>非静态工厂注入</strong></p><p>非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> FactoryDao <span class="title function_">getFactoryDaoImpl</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FactoryDaoImpl</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAction</span> &#123;</span><br><span class="line">  <span class="comment">//注入对象</span></span><br><span class="line">  <span class="keyword">private</span> FactoryDao factoryDao;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactoryDao</span><span class="params">(FactoryDao factoryDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.factoryDao = factoryDao;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &lt;bean name=<span class="string">&quot;springAction&quot;</span> class=<span class="string">&quot;SpringAction&quot;</span>&gt;</span><br><span class="line">   &lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line">   &lt;property name=<span class="string">&quot;factoryDao&quot;</span> ref=<span class="string">&quot;factoryDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;</span><br><span class="line"> &lt;bean name=<span class="string">&quot;daoFactory&quot;</span> class=<span class="string">&quot;com.DaoFactory&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean name=<span class="string">&quot;factoryDao&quot;</span> factory-bean=<span class="string">&quot;daoFactory&quot;</span> factory-method=<span class="string">&quot;getFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="12-Spring-有哪些自动装配的方式？">12.Spring 有哪些自动装配的方式？</h3><blockquote><p><strong>什么是自动装配？</strong></p></blockquote><p>Spring IOC 容器知道所有 Bean 的配置信息，此外，通过 Java 反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有 Bean 的这些信息后，Spring IOC 容器就可以按照某种规则对容器中的 Bean 进行自动装配，而无须通过显式的方式进行依赖配置。</p><p>Spring 提供的这种方式，可以按照某些规则进行 Bean 的自动装配，<code>&lt;bean&gt;</code>元素提供了一个指定自动装配类型的属性：<code>autowire=&quot;&lt;自动装配类型&gt;&quot;</code></p><blockquote><p><strong>Spring 提供了哪几种自动装配类型？</strong></p></blockquote><p>Spring 提供了 4 种自动装配类型：</p><p><img src="https://s2.loli.net/2023/03/31/g5R2MVQvpCa6t1I.png" alt="Spring四种自动装配类型"></p><ul><li><strong>byName</strong>：根据名称进行自动匹配，假设 Boss 又一个名为 car 的属性，如果容器中刚好有一个名为 car 的 bean，Spring 就会自动将其装配给 Boss 的 car 属性</li><li><strong>byType</strong>：根据类型进行自动匹配，假设 Boss 有一个 Car 类型的属性，如果容器中刚好有一个 Car 类型的 Bean，Spring 就会自动将其装配给 Boss 这个属性</li><li><strong>constructor</strong>：与 byType 类似， 只不过它是针对构造函数注入而言的。如果 Boss 有一个构造函数，构造函数包含一个 Car 类型的入参，如果容器中有一个 Car 类型的 Bean，则 Spring 将自动把这个 Bean 作为 Boss 构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的 Bean，则 Spring 将抛出异常。</li><li><strong>autodetect</strong>：根据 Bean 的自省机制决定采用 byType 还是 constructor 进行自动装配，如果 Bean 提供了默认的构造函数，则采用 byType，否则采用 constructor。</li></ul><h3 id="13-Spring-中的-Bean-的作用域有哪些">13.Spring 中的 Bean 的作用域有哪些?</h3><p>Spring 的 Bean 主要支持五种作用域：</p><p><img src="https://s2.loli.net/2023/03/31/2OpBqsh7bVg8e3E.png" alt="Spring Bean支持作用域"></p><ul><li><strong>singleton</strong> : 在 Spring 容器仅存在一个 Bean 实例，Bean 以单实例的方式存在，是 Bean 默认的作用域。</li><li><strong>prototype</strong> : 每次从容器重调用 Bean 时，都会返回一个新的实例。</li></ul><p>以下三个作用域于只在 Web 应用中适用：</p><ul><li><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP Request 内有效。</li><li><strong>session</strong> : 同一个 HTTP Session 共享一个 Bean，不同的 HTTP Session 使用不同的 Bean。</li><li><strong>globalSession</strong>：同一个全局 Session 共享一个 Bean，只用于基于 Protlet 的 Web 应用，Spring5 中已经不存在了。</li></ul><h3 id="14-Spring-中的单例-Bean-会存在线程安全问题吗？">14.Spring 中的单例 Bean 会存在线程安全问题吗？</h3><p>首先结论在这：Spring 中的单例 Bean<strong>不是线程安全的</strong>。</p><p>因为单例 Bean，是全局只有一个 Bean，所有线程共享。如果说单例 Bean，是一个无状态的，也就是线程中的操作不会对 Bean 中的成员变量执行<strong>查询</strong>以外的操作，那么这个单例 Bean 是线程安全的。比如 Spring mvc 的 Controller、Service、Dao 等，这些 Bean 大多是无状态的，只关注于方法本身。</p><p>假如这个 Bean 是有状态的，也就是会对 Bean 中的成员变量进行写操作，那么可能就存在线程安全的问题。</p><p><img src="https://s2.loli.net/2023/03/31/KXoQiMJrTDlxv15.png" alt="Spring单例Bean线程安全问题"></p><blockquote><p><strong>单例 Bean 线程安全问题怎么解决呢？</strong></p></blockquote><p>常见的有这么些解决办法：</p><ol><li><p>将 Bean 定义为多例</p><p>这样每一个线程请求过来都会创建一个新的 Bean，但是这样容器就不好管理 Bean，不能这么办。</p></li><li><p>在 Bean 对象中尽量避免定义可变的成员变量</p><p>削足适履了属于是，也不能这么干。</p></li><li><p>将 Bean 中的成员变量保存在 ThreadLocal 中 ⭐</p><p>我们知道 ThredLoca 能保证多线程下变量的隔离，可以在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 里，这是推荐的一种方式。</p></li></ol><h3 id="15-说说循环依赖">15.说说循环依赖?</h3><blockquote><p><strong>什么是循环依赖？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/31/ar2EMNPxv9TQS15.png" alt="Spring循环依赖"></p><p>Spring 循环依赖：简单说就是自己依赖自己，或者和别的 Bean 相互依赖。</p><p><img src="https://s2.loli.net/2023/03/31/TD37eR2XAfnkcQZ.png" alt="鸡和蛋"></p><p>只有单例的 Bean 才存在循环依赖的情况，<strong>原型</strong>(Prototype)情况下，Spring 会直接抛出异常。原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例……无限套娃，直接把系统干垮。</p><blockquote><p><strong>Spring 可以解决哪些情况的循环依赖？</strong></p></blockquote><p>Spring 不支持基于构造器注入的循环依赖，但是假如 AB 循环依赖，如果一个是构造器注入，一个是 setter 注入呢？</p><p>看看几种情形：</p><p><img src="https://s2.loli.net/2023/03/31/sz8CBOUL6wo9ZdE.png" alt="循环依赖的几种情形"></p><p>第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</p><p>所以简单总结，当循环依赖的实例都采用 setter 方法注入的时候，Spring 可以支持，都采用构造器注入的时候，不支持，构造器注入和 setter 注入同时存在的时候，看天。</p><h3 id="16-那-Spring-怎么解决循环依赖的呢？">16.那 Spring 怎么解决循环依赖的呢？</h3><blockquote><p>PS：其实正确答案是开发人员做好设计，别让 Bean 循环依赖，但是没办法，面试官不想听这个。</p></blockquote><p>我们都知道，单例 Bean 初始化完成，要经历三步：</p><p><img src="https://s2.loli.net/2023/03/31/FvkWAt4BipdLgXN.png" alt="Bean初始化步骤"></p><p>注入就发生在第二步，<strong>属性赋值</strong>，结合这个过程，Spring 通过<strong>三级缓存</strong>解决了循环依赖：</p><ol><li>一级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>singletonObjects</strong>，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例</li><li>二级缓存 : <code>Map&lt;String,Object&gt;</code> <strong>earlySingletonObjects</strong>，早期曝光对象，用于保存实例化完成的 bean 实例</li><li>三级缓存 : <code>Map&lt;String,ObjectFactory&lt;?&gt;&gt;</code> <strong>singletonFactories</strong>，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。</li></ol><p><img src="https://s2.loli.net/2023/03/31/LyFKNwYd9xqV7Af.png" alt="三级缓存"></p><p>我们来看一下三级缓存解决循环依赖的过程：</p><p>当 A、B 两个类发生循环依赖时：<br><img src="https://s2.loli.net/2023/03/31/sAITrPaqvn4DgUM.png" alt="循环依赖"></p><p>A 实例的初始化过程：</p><ol><li>创建 A 实例，实例化的时候把 A 对象⼯⼚放⼊三级缓存，表示 A 开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道</li></ol><p><img src="https://s2.loli.net/2023/03/31/z6xpiB5fINsoh4O.png" alt="1"></p><ol start="2"><li><p>A 注⼊属性时，发现依赖 B，此时 B 还没有被创建出来，所以去实例化 B</p></li><li><p>同样，B 注⼊属性时发现依赖 A，它就会从缓存里找 A 对象。依次从⼀级到三级缓存查询 A，从三级缓存通过对象⼯⼚拿到 A，发现 A 虽然不太完善，但是存在，把 A 放⼊⼆级缓存，同时删除三级缓存中的 A，此时，B 已经实例化并且初始化完成，把 B 放入⼀级缓存。</p></li></ol><p><img src="https://s2.loli.net/2023/03/31/dKeEUQ824wVMagv.png" alt="2"></p><ol start="4"><li><p>接着 A 继续属性赋值，顺利从⼀级缓存拿到实例化且初始化完成的 B 对象，A 对象创建也完成，删除⼆级缓存中的 A，同时把 A 放⼊⼀级缓存</p></li><li><p>最后，⼀级缓存中保存着实例化、初始化都完成的 A、B 对象</p></li></ol><p><img src="https://s2.loli.net/2023/03/31/FkReZPfNgX6KDti.png" alt="5"></p><p>所以，我们就知道为什么 Spring 能解决 setter 注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p><h3 id="17-为什么要三级缓存？⼆级不行吗？">17.为什么要三级缓存？⼆级不行吗？</h3><p>不行，主要是为了<strong>⽣成代理对象</strong>。如果是没有代理的情况下，使用二级缓存解决循环依赖也是 OK 的。但是如果存在代理，三级没有问题，二级就不行了。</p><p>因为三级缓存中放的是⽣成具体对象的匿名内部类，获取 Object 的时候，它可以⽣成代理对象，也可以返回普通对象。使⽤三级缓存主要是为了保证不管什么时候使⽤的都是⼀个对象。</p><p>假设只有⼆级缓存的情况，往⼆级缓存中放的显示⼀个普通的 Bean 对象，Bean 初始化过程中，通过 BeanPostProcessor 去⽣成代理对象之后，覆盖掉⼆级缓存中的普通 Bean 对象，那么可能就导致取到的 Bean 对象不一致了。</p><p><img src="https://s2.loli.net/2023/03/31/UhKbIAFTNguLfMp.png" alt="二级缓存不行的原因"></p><h3 id="18-Autowired-的实现原理？">18.@Autowired 的实现原理？</h3><p>实现@Autowired 的关键是：<strong>AutowiredAnnotationBeanPostProcessor</strong></p><p>在 Bean 的初始化阶段，会通过 Bean 后置处理器来进行一些前置和后置的处理。</p><p>实现@Autowired 的功能，也是通过后置处理器来完成的。这个后置处理器就是 AutowiredAnnotationBeanPostProcessor。</p><ul><li><p>Spring 在创建 bean 的过程中，最终会调用到 doCreateBean()方法，在 doCreateBean()方法中会调用 populateBean()方法，来为 bean 进行属性填充，完成自动装配等工作。</p></li><li><p>在 populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行 return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到 AutowiredAnnotationBeanPostProcessor 的 postProcessPropertyValues()方法，在该方法中就会进行@Autowired 注解的解析，然后实现自动装配。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 属性赋值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">          <span class="comment">//…………</span></span><br><span class="line">          <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">              <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">                  pvs = mbd.getPropertyValues();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              PropertyValues pvsToUse;</span><br><span class="line">              <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">var9</span> <span class="operator">=</span> <span class="built_in">this</span>.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) &#123;</span><br><span class="line">                  <span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">bp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor)var9.next();</span><br><span class="line">                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">                  <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">                          filteredPds = <span class="built_in">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="comment">//执行后处理器，填充属性，完成自动装配</span></span><br><span class="line">                      <span class="comment">//调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法</span></span><br><span class="line">                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                      <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                          <span class="keyword">return</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">//…………</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>postProcessorPropertyValues()方法的源码如下，在该方法中，会先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">//@Autowired注解、@Inject和@Value注解的属性和方法</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//属性填充</span></span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanCreationException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var6;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, var7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP">AOP</h2><h3 id="19-说说什么是-AOP？">19.说说什么是 AOP？</h3><p>AOP：面向切面编程。简单说，就是把一些业务逻辑中的相同的代码抽取到一个独立的模块中，让业务逻辑更加清爽。</p><p><img src="https://s2.loli.net/2023/03/31/DXP6fANEHqvpWm3.png" alt="横向抽取"></p><p>具体来说，假如我现在要 crud 写一堆业务，可是如何在业务代码前后进行打印日志和参数的校验呢？</p><p>我们可以把<code>日志记录</code>和<code>数据校验</code>可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。</p><p><img src="https://s2.loli.net/2023/03/31/xSqMoCJT4XBL7Zi.png" alt="AOP应用示例"></p><p>业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。</p><p>AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。</p><p><img src="https://s2.loli.net/2023/03/31/4PuDcOE8gSk1Kvt.png" alt="Java语言执行过程"></p><p>AOP 的核心其实就是<strong>动态代理</strong>，如果是实现了接口的话就会使用 JDK 动态代理，否则使用 CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p><blockquote><p><strong>AOP 有哪些核心概念？</strong></p></blockquote><ul><li><p><strong>切面</strong>（Aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</p></li><li><p><strong>连接点</strong>（Joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p></li><li><p><strong>切点</strong>（Pointcut）：对连接点进行拦截的定位</p></li><li><p><strong>通知</strong>（Advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作<strong>增强</strong></p></li><li><p><strong>目标对象</strong> （Target）：代理的目标对象</p></li><li><p><strong>织入</strong>（Weabing）：织入是将增强添加到目标类的具体连接点上的过程。</p><ul><li><p>编译期织入：切面在目标类编译时被织入</p></li><li><p>类加载期织入：切面在目标类加载到 JVM 时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p></li><li><p>运行期织入：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。SpringAOP 就是以这种方式织入切面。</p><p>Spring 采用运行期织入，而 AspectJ 采用编译期织入和类加载器织入。</p></li></ul></li><li><p><strong>引介</strong>（introduction）：引介是一种特殊的增强，可以动态地为类添加一些属性和方法</p></li></ul><blockquote><p><strong>AOP 有哪些环绕方式？</strong></p></blockquote><p>AOP 一般有 <strong>5 种</strong>环绕方式：</p><ul><li>前置通知 (@Before)</li><li>返回通知 (@AfterReturning)</li><li>异常通知 (@AfterThrowing)</li><li>后置通知 (@After)</li><li>环绕通知 (@Around)</li></ul><p><img src="https://s2.loli.net/2023/03/31/8rJUn1SxRV5DXEM.png" alt="环绕方式"></p><p>多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。</p><h3 id="20-说说你平时有用到-AOP-吗？">20.说说你平时有用到 AOP 吗？</h3><p>PS：这道题老三的同事面试候选人的时候问到了，候选人说了一堆 AOP 原理，同事就势来一句，你能现场写一下 AOP 的应用吗？结果——场面一度很尴尬。虽然我对面试写这种百度就能出来的东西持保留意见，但是还是加上了这一问，毕竟招人最后都是要撸代码的。</p><p>这里给出一个小例子，SpringBoot 项目中，利用 AOP 打印接口的入参和出参日志，以及执行时间，还是比较快捷的。</p><ul><li><p>引入依赖：引入 AOP 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>自定义注解：自定义一个注解作为切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 AOP 切面：</p><ul><li><p>@Aspect：标识切面</p></li><li><p>@Pointcut：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定义注解是比较常用的一种。</p></li><li><p>@Before：在切点之前织入，打印了一些入参信息</p></li><li><p>@Around：环绕切点，打印返回参数和接口执行时间</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span>         <span class="operator">=</span> LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以自定义 <span class="doctag">@WebLog</span> 注解为切点</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之前织入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 开始打印请求日志</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">        <span class="comment">// 打印请求相关参数</span></span><br><span class="line">        logger.info(<span class="string">&quot;========================================== Start ==========================================&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印请求 url</span></span><br><span class="line">        logger.info(<span class="string">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());</span><br><span class="line">        <span class="comment">// 打印 Http method</span></span><br><span class="line">        logger.info(<span class="string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">        <span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">        logger.info(<span class="string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());</span><br><span class="line">        <span class="comment">// 打印请求的 IP</span></span><br><span class="line">        logger.info(<span class="string">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());</span><br><span class="line">        <span class="comment">// 打印请求入参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Request Args   : &#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点之后织入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 结束后打个分隔线，方便查看</span></span><br><span class="line">        logger.info(<span class="string">&quot;=========================================== End ===========================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">        <span class="comment">// 打印出参</span></span><br><span class="line">        logger.info(<span class="string">&quot;Response Args  : &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(result));</span><br><span class="line">        <span class="comment">// 执行耗时</span></span><br><span class="line">        logger.info(<span class="string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用：只需要在接口上加上自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@WebLog(desc = &quot;这是一个欢迎接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>执行结果：可以看到日志打印了入参、出参和执行时间<br><img src="https://s2.loli.net/2023/03/31/9SBU84OEiQJLglD.png" alt="执行结果"></li></ul><h3 id="21-说说-JDK-动态代理和-CGLIB-代理-？">21.说说 JDK 动态代理和 CGLIB 代理 ？</h3><p>Spring 的 AOP 是通过<a href="https://mp.weixin.qq.com/s/aZtfwik0weJN5JzYc-JxYg">动态代理</a>来实现的，动态代理主要有两种方式 JDK 动态代理和 Cglib 动态代理，这两种动态代理的使用和原理有些不同。</p><p><strong>JDK 动态代理</strong></p><ol><li><strong>Interface</strong>：对于 JDK 动态代理，目标类需要实现一个 Interface。</li><li><strong>InvocationHandler</strong>：InvocationHandler 是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。</li><li><strong>Proxy</strong>：Proxy 利用 InvocationHandler 动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</li></ol><p><strong>CgLib 动态代理</strong></p><ol><li>使用 JDK 创建代理有一大限制，它只能为接口创建代理实例，而 CgLib 动态代理就没有这个限制。</li><li>CgLib 动态代理是使用字节码处理框架 <strong>ASM</strong>，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。</li><li><strong>CgLib</strong> 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib 在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</li></ol><p>我们来看一个常见的小场景，客服中转，解决用户问题：</p><p><img src="https://s2.loli.net/2023/03/31/eVjinFJlyqZdEYh.png" alt="用户向客服提问题"></p><p><strong>JDK 动态代理实现：</strong></p><p><img src="https://s2.loli.net/2023/03/31/KeCM6W9cpfNjvxz.png" alt="JDK动态代理类图"></p><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目标类:需要实现对应接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> <span class="keyword">implements</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写 InvocationHandler 方法，实现接口重写也差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 调用目标对象方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象:程序员</span></span><br><span class="line">        <span class="type">ISolver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">        <span class="comment">//代理：客服小姐姐</span></span><br><span class="line">        <span class="type">ISolver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (ISolver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">        <span class="comment">//目标方法：解决问题</span></span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Cglib 动态代理实现：</strong></p><p><img src="https://s2.loli.net/2023/03/31/KiUsGnorwQTgj36.png" alt="Cglib动态代理类图"></p><ul><li><p>目标类：Solver，这里目标类不用再实现接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;疯狂掉头发解决问题……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象代理</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端：Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象:程序员</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">        <span class="comment">//代理：客服小姐姐</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (Solver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">        <span class="comment">//目标方法：解决问题</span></span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="22-说说-Spring-AOP-和-AspectJ-AOP-区别">22.说说 Spring AOP 和 AspectJ AOP 区别?</h3><p><strong>Spring AOP</strong></p><p>Spring AOP 属于<code>运行时增强</code>，主要具有如下特点：</p><ol><li><p>基于动态代理来实现，默认如果使用接口的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现</p></li><li><p>Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现</p></li><li><p>在性能上，由于 Spring AOP 是基于<strong>动态代理</strong>来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。</p></li><li><p>Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p></li></ol><p><strong>AspectJ</strong></p><p>AspectJ 是一个易用的功能强大的 AOP 框架，属于<code>编译时增强</code>， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p><p>AspectJ 属于<strong>静态织入</strong>，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p><ol><li><p>编译期织入（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</p></li><li><p>编译后织入（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</p></li><li><p>类加载后织入（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p></li></ol><p>整体对比如下：</p><p><img src="https://s2.loli.net/2023/03/31/VeWQRUq7fL2IuGB.png" alt="Spring AOP和AspectJ对比"></p><h2 id="事务">事务</h2><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p><h3 id="23-Spring-事务的种类？">23.Spring 事务的种类？</h3><p>Spring 支持<code>编程式事务</code>管理和<code>声明式</code>事务管理两种方式：</p><p><img src="https://s2.loli.net/2023/03/31/A6noTVFHlKvQhYL.png" alt="Spring事务分类"></p><ol><li>编程式事务</li></ol><p>编程式事务管理使用 TransactionTemplate，需要显式执行事务。</p><ol start="2"><li><p>声明式事务</p></li><li><p>声明式事务管理建立在 AOP 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务</p></li><li><p>优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 @Transactional 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p></li></ol><h3 id="24-Spring-的事务隔离级别？">24.Spring 的事务隔离级别？</h3><p>Spring 的接口 TransactionDefinition 中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：</p><ol><li>ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。</li><li>ISOLATION_READ_UNCOMMITTED：读未提交</li><li>ISOLATION_READ_COMMITTED：读已提交</li><li>ISOLATION_REPEATABLE_READ：可重复读</li><li>ISOLATION_SERIALIZABLE：串行化</li></ol><h3 id="25-Spring-的事务传播机制？">25.Spring 的事务传播机制？</h3><p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。</p><p>事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p><p><img src="https://s2.loli.net/2023/03/31/4Eoi5rX1jalhyZu.png" alt="7种事务传播机制"></p><p>Spring 默认的事务传播行为是 PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个 ServiceX#methodX()都工作在事务环境下（均被 Spring 事务增强），且程序中存在调用链 <code>Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()</code>，那么这 3 个服务类的三个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p><h3 id="26-声明式事务实现原理了解吗？">26.声明式事务实现原理了解吗？</h3><p>就是通过 AOP/动态代理。</p><ul><li><p><strong>在 Bean 初始化阶段创建代理对象</strong>：Spring 容器在初始化每个单例 bean 的时候，会遍历容器中的所有 BeanPostProcessor 实现类，并执行其 postProcessAfterInitialization 方法，在执行 AbstractAutoProxyCreator 类的 postProcessAfterInitialization 方法时会遍历容器中所有的切面，查找与当前实例化 bean 匹配的切面，这里会获取事务属性切面，查找@Transactional 注解及其属性值，然后根据得到的切面创建一个代理对象，默认是使用 JDK 动态代理创建代理，如果目标类是接口，则使用 JDK 动态代理，否则使用 Cglib。</p></li><li><p><strong>在执行目标方法时进行事务增强操作</strong>：当通过代理对象调用 Bean 方法的时候，会触发对应的 AOP 增强拦截器，声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p></li></ul><p><img src="https://s2.loli.net/2023/03/31/xadHpBbuK8WqPw2.png" alt="图片来源网易技术专栏"></p><p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，包括开启事务、事务提交、异常回滚。</p><h3 id="27-声明式事务在哪些情况下会失效？">27.声明式事务在哪些情况下会失效？</h3><p><img src="https://s2.loli.net/2023/03/31/gucs6btNjZAdyeR.png" alt="声明式事务的几种失效的情况"></p><p><strong>1、@Transactional 应用在非 public 修饰的方法上</strong></p><p>如果 Transactional 注解应用在非 public 修饰的方法上，Transactional 将会失效。</p><p>是因为在 Spring AOP 代理时，TransactionInterceptor （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的 intercept 方法 或 JdkDynamicAopProxy 的 invoke 方法会间接调用 AbstractFallbackTransactionAttributeSource 的 <strong>computeTransactionAttribute</strong>方法，获取 Transactional 注解的事务配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> TransactionAttribute <span class="title function_">computeTransactionAttribute</span><span class="params">(Method method,</span></span><br><span class="line"><span class="params">    Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">        <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法会检查目标方法的修饰符是否为 public，不是 public 则不会获取@Transactional 的属性配置信息。</p><p><strong>2、@Transactional 注解属性 propagation 设置错误</strong></p><ul><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>3、@Transactional 注解属性 rollbackFor 设置错误</strong></p><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring 默认抛出了未检查 unchecked 异常（继承自 RuntimeException 的异常）或者 Error 才回滚事务，其他异常不会触发回滚事务。</p><p><img src="https://s2.loli.net/2023/03/31/oixpeFMvgaLzqGt.png" alt="Spring默认支持的异常回滚"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望自定义的异常可以进行回滚</span></span><br><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class</span></span><br></pre></td></tr></table></figure><p>若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。</p><p><strong>4、同一个类中方法调用，导致@Transactional 失效</strong></p><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类 Test，它的一个方法 A，A 再调用本类的方法 B（不论方法 B 是用 public 还是 private 修饰），但方法 A 没有声明注解事务，而 B 方法有。则外部调用方法 A 之后，方法 B 的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用 Spring AOP 代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由 Spring 生成的代理对象来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.insertB();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">       <span class="keyword">return</span> insert;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Transactional()</span></span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">       cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">       cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种情况是最常见的一种@Transactional 注解失效场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">private</span> Integer <span class="title function_">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">CityInfoDict</span> <span class="variable">cityInfoDict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CityInfoDict</span>();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * A 插入字段为 2的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * B 插入字段为 3的数据</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        b.insertB();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果 B 方法内部抛了异常，而 A 方法此时 try catch 了 B 方法的异常，那这个事务就不能正常回滚了，会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><h2 id="MVC">MVC</h2><h3 id="28-Spring-MVC-的核心组件？">28.Spring MVC 的核心组件？</h3><ol><li><strong>DispatcherServlet</strong>：前置控制器，是整个流程控制的<strong>核心</strong>，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。</li><li><strong>Handler</strong>：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。</li><li><strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。</li><li><strong>HandlerInterceptor</strong>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li><li><strong>HandlerExecutionChain</strong>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li><li><strong>HandlerAdapter</strong>：处理器适配器，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet 通过 HandlerAdapter 执行不同的 Handler。</li><li><strong>ModelAndView</strong>：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li><li><strong>ViewResolver</strong>：视图解析器，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</li></ol><h3 id="29-Spring-MVC-的工作流程？">29.Spring MVC 的工作流程？</h3><p><img src="https://s2.loli.net/2023/03/31/J7vRYTfzHg5Ok1W.png" alt="Spring MVC的工作流程"></p><ol><li>客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet(也叫中央控制器)。</li><li>DispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理（并未调用 Controller，只是得知）</li><li>DispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller</li><li>HandlerAdapter 处理器适配器去执行 Controller 并得到 ModelAndView(数据和视图)，并层层返回给 DispatcherServlet</li><li>DispatcherServlet 将 ModelAndView 交给 ViewReslover 视图解析器解析，然后返回真正的视图。</li><li>DispatcherServlet 将模型数据填充到视图中</li><li>DispatcherServlet 将结果响应给客户端</li></ol><p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有 <strong>Handler（Controller）</strong> 、<strong>View</strong> 、<strong>Model</strong>。</p><p>当然我们现在大部分的开发都是前后端分离，Restful 风格接口，后端只需要返回 Json 数据就行了。</p><h3 id="30-SpringMVC-Restful-风格的接口的流程是什么样的呢？">30.SpringMVC Restful 风格的接口的流程是什么样的呢？</h3><p>PS:这是一道全新的八股，毕竟 ModelAndView 这种方式应该没人用了吧？现在都是前后端分离接口，八股也该更新换代了。</p><p>我们都知道 Restful 接口，响应格式是 json，这就用到了一个常用注解：<strong>@ResponseBody</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入了这个注解后，整体的流程上和使用 ModelAndView 大体上相同，但是细节上有一些不同：</p><p><img src="https://s2.loli.net/2023/03/31/PYKvN16o5QIbd9Z.png" alt="Spring MVC Restful请求响应示意图"></p><ol><li><p>客户端向服务端发送一次请求，这个请求会先到前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet 接收到请求后会调用 HandlerMapping 处理器映射器。由此得知，该请求该由哪个 Controller 来处理</p></li><li><p>DispatcherServlet 调用 HandlerAdapter 处理器适配器，告诉处理器适配器应该要去执行哪个 Controller</p></li><li><p>Controller 被封装成了 ServletInvocableHandlerMethod，HandlerAdapter 处理器适配器去执行 invokeAndHandle 方法，完成对 Controller 的请求处理</p></li><li><p>HandlerAdapter 执行完对 Controller 的请求，会调用 HandlerMethodReturnValueHandler 去处理返回值，主要的过程：</p><p>5.1. 调用 RequestResponseBodyMethodProcessor，创建 ServletServerHttpResponse（Spring 对原生 ServerHttpResponse 的封装）实例</p><p>5.2.使用 HttpMessageConverter 的 write 方法，将返回值写入 ServletServerHttpResponse 的 OutputStream 输出流中</p><p>5.3.在写入的过程中，会使用 JsonGenerator（默认使用 Jackson 框架）对返回值进行 Json 序列化</p></li><li><p>执行完请求后，返回的 ModealAndView 为 null，ServletServerHttpResponse 里也已经写入了响应，所以不用关心 View 的处理</p></li></ol><h2 id="Spring-Boot">Spring Boot</h2><h3 id="31-介绍一下-SpringBoot，有哪些优点？">31.介绍一下 SpringBoot，有哪些优点？</h3><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p><img src="https://s2.loli.net/2023/03/31/x2guivnGLDQs6tz.png" alt="SpringBoot图标"></p><p>Spring Boot 以<code>约定大于配置</code>核心思想开展工作，相比 Spring 具有如下优势：</p><ol><li>Spring Boot 可以快速创建独立的 Spring 应用程序。</li><li>Spring Boot 内嵌了如 Tomcat，Jetty 和 Undertow 这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。</li><li>Spring Boot 无需再像 Spring 一样使用一堆繁琐的 xml 文件配置。</li><li>Spring Boot 可以自动配置(核心)Spring。SpringBoot 将原有的 XML 配置改为 Java 配置，将 bean 注入改为使用注解注入的方式(@Autowire)，并将多个 xml、properties 配置浓缩在一个 appliaction.yml 配置文件中。</li><li>Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。</li><li>Spring Boot 可以快速整合常用依赖（开发库，例如 spring-webmvc、jackson-json、validation-api 和 tomcat 等），提供的 POM 可以简化 Maven 的配置。当我们引入核心依赖时，SpringBoot 会自引入其他依赖。</li></ol><h3 id="32-SpringBoot-自动配置原理了解吗？">32.SpringBoot 自动配置原理了解吗？</h3><p>SpringBoot 开启自动配置的注解是<code>@EnableAutoConfiguration</code> ，启动类上的注解<code>@SpringBootApplication</code>是一个复合注解，包含了<code>@EnableAutoConfiguration</code>：</p><p><img src="https://s2.loli.net/2023/03/31/YzgwxQc2TIENFnb.png" alt="SpringBoot自动配置原理"></p><ul><li><p><code>EnableAutoConfiguration</code> 只是一个简单的注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//将main同级的包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span> <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AutoConfigurationImportSelector</code>实现了<code>ImportSelector</code>接口，这个接口的作用就是收集需要导入的配置类，配合<code>@Import()</code>就可以将相应的类导入到 Spring 容器中</p></li><li><p>获取注入类的方法是 selectImports()，它实际调用的是<code>getAutoConfigurationEntry</code>，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：</p><ol><li>获取注解的属性，用于后面的排除</li><li><strong>获取所有需要自动装配的配置类的路径</strong>：这一步是最关键的，从 META-INF/spring.factories 获取自动配置类的路径</li><li>去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取到注解的属性</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">//2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径</span></span><br><span class="line">        List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">//3.1.移除重复的配置</span></span><br><span class="line">        configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">//3.2.处理需要排除的配置</span></span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = <span class="built_in">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>自动配置简单来说呢，就是将第三方的组件自动装载到IOC容器里面，不需要开发人员再去编写相关的配置，在SpringBoot应用里面呢只需要加上@SpringBootApplication注解就可以实现自动配置，SpringBootApplication它是一个复合注解，真正实现自动装配的注解是@EnableAutoConfiguration注解。自动装配的实现呢主要依靠三个核心的关键技术：<br>1）引入Starter，启动依赖组件的时候，这个组件里面必须包括@Configuration配置类，然后我需要通过Bean注解去声明需要装配到IOC容器里面的Bean对象<br>2）这个配置类是放在第三方的jar包里面，然后通过Spring Boot中约定大于配置的理念，去把配置类的全路径放在classpath:META_INF/Spring.factories文件里面，SpringBoot就可以知道第三方jar包里面配置类的位置，它主要是依靠Spring里面的SpringFactorierLoader来完成的<br>3）SpringBoot拿到所有第三方jar包声明的配置类之后，再通过ImportSelector这样一个接口来实现对这些配置类的动态加载，从而去完成自动装配这样的一个动作。<br>在我看来，SpringBoot是约定优于配置这一理念下的一个产物，所以在很多的地方都会看到这一类的思想，它的出现让开发人员可以更加聚焦在业务代码的编写上，而不需要去关系和业务无关的配置，其实自动装配的思想在springframework3.x版本里面的@enable注解，就已经有了实现的一个雏形，@enable注解时候一个模块驱动的意思，就是说我们只要增加@enable注解，就可以自动打开某个功能，而不需要针对这个功能去做Bean的配置，@enable注解的底层是帮我们自动完成这样的一个模块相关bean的注入</p></div><h3 id="33-如何自定义一个-SpringBoot-Srarter">33.如何自定义一个 SpringBoot Srarter?</h3><p>知道了自动配置原理，创建一个自定义 SpringBoot Starter 也很简单。</p><ol><li>创建一个项目，命名为 demo-spring-boot-starter，引入 SpringBoot 相关依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>编写配置文件</p><p>这里定义了属性配置的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自动装配</p><p>创建自动配置类 HelloPropertiesConfigure</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloPropertiesConfigure</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置自动类</p><p>在<code>/resources/META-INF/spring.factories</code>文件中添加自动配置类路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">  cn.fighter3.demo.starter.configure.HelloPropertiesConfigure</span><br></pre></td></tr></table></figure></li><li><p>测试</p><ul><li><p>创建一个工程，引入自定义 starter 依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.fighter3&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;demo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件里添加配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.name=张三</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span>+helloProperties.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>运行结果</li></ul><p><img src="https://s2.loli.net/2023/03/31/uBlnT1ZkaLMvU6m.png" alt="运行结果"></p><p>至此，随手写的一个自定义 SpringBoot-Starter 就完成了，虽然比较简单，但是完成了主要的自动装配的能力。</p><h3 id="34-Springboot-启动原理？">34.Springboot 启动原理？</h3><p>SpringApplication 这个类主要做了以下四件事情：</p><ol><li>推断应用的类型是普通的项目还是 Web 项目</li><li>查找并加载所有可用初始化器 ， 设置到 initializers 属性中</li><li>找出所有的应用程序监听器，设置到 listeners 属性中</li><li>推断并设置 main 方法的定义类，找到运行的主类</li></ol><p>SpringBoot 启动大致流程如下 ：</p><p><img src="https://s2.loli.net/2023/03/31/JaItQcFBfoU3LDx.png" alt="SpringBoot 启动大致流程-图片来源网络"></p><h2 id="Spring-Cloud">Spring Cloud</h2><h3 id="35-对-SpringCloud-了解多少？">35.对 SpringCloud 了解多少？</h3><p>SpringCloud 是 Spring 官方推出的微服务治理框架。</p><p><img src="https://s2.loli.net/2023/03/31/eXrznsN2d4kDYLw.png" alt="Spring Cloud Netfilx核心组件-来源参考[2]"></p><blockquote><p><strong>什么是微服务？</strong></p></blockquote><ol><li>2014 年 <strong>Martin Fowler</strong> 提出的一种新的架构形式。微服务架构是一种<strong>架构模式</strong>，提倡将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制(如 HTTP 或 Dubbo)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如 Maven)对其进行构建。</li><li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li></ol><blockquote><p><strong>微服务架构主要要解决哪些问题？</strong></p></blockquote><ol><li>服务很多，客户端怎么访问，如何提供对外网关?</li><li>这么多服务，服务之间如何通信? HTTP 还是 RPC?</li><li>这么多服务，如何治理? 服务的注册和发现。</li><li>服务挂了怎么办？熔断机制。</li></ol><blockquote><p><strong>有哪些主流微服务框架？</strong></p></blockquote><ol><li>Spring Cloud Netflix</li><li>Spring Cloud Alibaba</li><li>SpringBoot + Dubbo + ZooKeeper</li></ol><blockquote><p><strong>SpringCloud 有哪些核心组件？</strong></p></blockquote><p><img src="https://s2.loli.net/2023/03/31/qn1EFQATyuc4Wfs.png" alt="SpringCloud"></p><p>PS:微服务后面有机会再扩展，其实面试一般都是结合项目去问。</p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> spring框架篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架篇(修正版)</title>
      <link href="/posts/aa2ef632.html"/>
      <url>/posts/aa2ef632.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><h3 id="1-说说有哪些常见集合？">1.说说有哪些常见集合？</h3><p>集合相关类和接口都在java.util中，主要分为3种：List（列表）、Map（映射）、Set(集)。</p><p><img src="https://s2.loli.net/2023/03/30/yS628LCdxQlwUJ4.png" alt="Java集合主要关系"></p><p>其中<code>Collection</code>是集合<code>List</code>、<code>Set</code>的父接口，它主要有两个子接口：</p><ul><li><code>List</code>：存储的元素有序，可重复。</li><li><code>Set</code>：存储的元素无序，不可重复。</li></ul><p><code>Map</code>是另外的接口，是键值对映射结构的集合。</p><h2 id="List">List</h2><div class="note info flat"><p>List，也没啥好问的，但不排除面试官剑走偏锋，比如面试官也看了我这篇文章。</p></div><h3 id="2-ArrayList和LinkedList有什么区别？">2.ArrayList和LinkedList有什么区别？</h3><p>（1）数据结构不同</p><ul><li>ArrayList基于数组实现</li><li>LinkedList基于双向链表实现</li></ul><p><img src="https://s2.loli.net/2023/03/30/sCoOuAjan2GTzh8.png" alt="ArrayList和LinkedList的数据结构"></p><p>（2） 多数情况下，ArrayList更利于查找，LinkedList更利于增删</p><ul><li><p>ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)；LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)；当然，get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)。</p></li><li><p>ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容；双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素。</p></li></ul><p><img src="https://s2.loli.net/2023/03/30/bpfKgHJdnu6TVLi.png" alt="ArrayList和LinkedList中间插入"></p><p><img src="https://s2.loli.net/2023/03/30/Qe19sdkAXZ4yF8c.png" alt="ArrayList和LinkedList中间删除"></p><blockquote><p>注意，这个地方可能会出陷阱，LinkedList更利于增删更多是体现在平均步长上，不是体现在时间复杂度上，二者增删的时间复杂度都是O(n)</p></blockquote><p><strong>（3）</strong> 是否支持随机访问</p><ul><li>ArrayList基于数组，所以它可以根据下标查找，支持随机访问，当然，它也实现了RandomAccess 接口，这个接口只是用来标识是否支持随机访问。</li><li>LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问。</li></ul><p><strong>（4）</strong> 内存占用，ArrayList基于数组，是一块连续的内存空间，LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗：</p><ul><li>ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费</li><li>LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间</li></ul><h3 id="3-ArrayList的扩容机制了解吗？">3.ArrayList的扩容机制了解吗？</h3><p>ArrayList是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1超过数组长度，就会进行扩容。</p><p>ArrayList的扩容是创建一个<strong>1.5倍</strong>的新数组，然后把原数组的值拷贝过去。</p><p><img src="https://s2.loli.net/2023/03/30/DeQmB4qtrhzyLbF.png" alt="ArrayList扩容"></p><h3 id="4-ArrayList怎么序列化的知道吗？-为什么用transient修饰数组？">4.ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？</h3><p>ArrayList的序列化不太一样，它使用<code>transient</code>修饰存储元素的<code>elementData</code>的数组，<code>transient</code>关键字的作用是让被修饰的成员属性不被序列化。</p><p><strong>为什么ArrayList不直接序列化元素数组呢？</strong></p><p>出于效率的考虑，数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。</p><p><strong>那ArrayList怎么序列化呢？</strong></p><p>ArrayList通过两个方法<strong>readObject、writeObject</strong>自定义序列化和反序列化策略，实际直接使用两个流<code>ObjectOutputStream</code>和<code>ObjectInputStream</code>来进行序列化和反序列化。</p><p><img src="https://s2.loli.net/2023/03/30/dKFDZBjnX4ha6Rf.png" alt="ArrayList自定义序列化"></p><h3 id="5-快速失败-fail-fast-和安全失败-fail-safe-了解吗？">5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？</h3><p><strong>快速失败（fail—fast）</strong>：快速失败是Java集合的一种错误检测机制</p><ul><li>在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li><li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <code> modCount</code>  变量。集合在被遍历期间如果内容发生变化，就会改变<code>modCount</code>的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount  这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li><li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。</li></ul><p><strong>安全失败（fail—safe）</strong></p><ul><li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li><li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li><li>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li><li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。</li></ul><h3 id="6-有哪几种实现ArrayList线程安全的方法？">6.有哪几种实现ArrayList线程安全的方法？</h3><p>fail-fast是一种可能触发的机制，实际上，ArrayList的线程安全仍然没有保证，一般，保证ArrayList的线程安全可以通过这些方案：</p><ul><li>使用 Vector 代替 ArrayList。（不推荐，Vector是一个历史遗留类）</li><li>使用 Collections.synchronizedList 包装 ArrayList，然后操作包装后的 list。</li><li>使用 CopyOnWriteArrayList 代替 ArrayList。</li><li>在使用 ArrayList 时，应用程序通过同步机制去控制 ArrayList 的读写。</li></ul><h3 id="7-CopyOnWriteArrayList了解多少？">7.CopyOnWriteArrayList了解多少？</h3><p>CopyOnWriteArrayList就是线程安全版本的ArrayList。</p><p>它的名字叫<code>CopyOnWrite</code>——写时复制，已经明示了它的原理。</p><p>CopyOnWriteArrayList采用了一种读写分离的并发策略。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p><p><img src="https://s2.loli.net/2023/03/30/ET3dRnWxIJGhPmF.png" alt="CopyOnWriteArrayList原理"></p><h2 id="Map">Map</h2><div class="note warning flat"><p>Map中，毫无疑问，最重要的就是HashMap，面试基本被盘出包浆了，各种问法，一定要好好准备。</p></div><h3 id="8-能说一下HashMap的数据结构吗？">8.能说一下HashMap的数据结构吗？</h3><p>JDK1.7的数据结构是<code>数组</code>+<code>链表</code>，JDK1.7还有人在用？不会吧……</p><p>说一下JDK1.8的数据结构吧：</p><p>JDK1.8的数据结构是<code>数组</code>+<code>链表</code>+<code>红黑树</code>。</p><p>数据结构示意图如下：</p><p><img src="https://s2.loli.net/2023/03/30/WStQxRzIn1ZKUMD.png" alt="jdk1.8 hashmap数据结构示意图"></p><p>其中，桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。</p><ul><li>数据元素通过映射关系，也就是散列函数，映射到桶数组对应索引的位置</li><li>如果发生冲突，从冲突的位置拉一个链表，插入冲突的元素</li><li>如果<strong>链表长度&gt;8</strong> 并且 <strong>数组大小&gt;=64</strong>，链表转为红黑树</li><li>如果红黑树节点个数&lt;6 ，转为链表</li></ul><h3 id="9-你对红黑树了解多少？为什么不用二叉树-平衡树呢？">9.你对红黑树了解多少？为什么不用二叉树/平衡树呢？</h3><p>红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点永远是黑色的；</li><li>所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；</li><li>每个红色节点的两个子节点一定都是黑色；</li><li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li></ol><p><img src="https://s2.loli.net/2023/03/30/q1wjGSsR9oz52Cm.png" alt="红黑树"></p><blockquote><p>之所以不用二叉树：</p></blockquote><p>红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。</p><blockquote><p>之所以不用平衡二叉树：</p></blockquote><p>平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。</p><h3 id="10-红黑树怎么保持平衡的知道吗？">10.红黑树怎么保持平衡的知道吗？</h3><p>红黑树有两种方式保持平衡：<code>旋转</code>和<code>染色</code>。</p><ul><li>旋转：旋转分为两种，左旋和右旋</li></ul><p><img src="https://s2.loli.net/2023/03/30/CaOkJ8SA4tzd9LY.png" alt="左旋"></p><p><img src="https://s2.loli.net/2023/03/30/BRfvyZSqQPOKTg5.png" alt="右旋"></p><ul><li>染⾊：</li></ul><p><img src="https://s2.loli.net/2023/03/30/ZelYv2xzobDLNVC.png" alt="染色"></p><h3 id="11-HashMap的put流程知道吗？">11.HashMap的put流程知道吗？</h3><p>先上个流程图吧:</p><p><img src="https://s2.loli.net/2023/03/30/XPOlKFIW9oqU74s.jpg" alt="HashMap插入数据流程图"></p><ol><li><p>首先进行哈希值的扰动，获取一个新的哈希值。<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></p></li><li><p>判断tab是否位空或者长度为0，如果是则进行扩容操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></li><li><p>根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。<code>tab[i = (n - 1) &amp; hash])</code></p></li><li><p>判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。</p></li><li><p>如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。<code>treeifyBin(tab, hash);</code></p></li><li><p>最后所有元素处理完成后，判断是否超过阈值；<code>threshold</code>，超过则扩容。</p></li></ol><h3 id="12-HashMap怎么查找元素的呢？">12.HashMap怎么查找元素的呢？</h3><p>先看流程图：</p><p><img src="https://s2.loli.net/2023/03/30/yLFtvun3pPS4igx.png" alt="HashMap查找流程图"></p><p>HashMap的查找就简单很多：</p><ol><li>使用扰动函数，获取新的哈希值</li><li>计算数组下标，获取节点</li><li>当前节点和key匹配，直接返回</li><li>否则，当前节点是否为树节点，查找红黑树</li><li>否则，遍历链表查找</li></ol><h3 id="13-HashMap的哈希-扰动函数是怎么设计的">13.HashMap的哈希/扰动函数是怎么设计的?</h3><p>HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key的hashCode和key的hashCode右移16位做异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么设计是为了降低哈希碰撞的概率。</p><h3 id="14-为什么哈希-扰动函数能降hash碰撞？">14.为什么哈希/扰动函数能降hash碰撞？</h3><p>因为 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为 <strong>-2147483648~2147483647</strong>，加起来大概 40 亿的映射空间。</p><p>只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。</p><p>假如 HashMap 数组的初始大小才 16，就需要用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。</p><p>源码中模运算就是把散列值和数组长度 - 1 做一个 “<code>与&amp;</code>” 操作，位运算比取余 % 运算要快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为这样（数组长度 - 1）正好相当于一个 “低位掩码”。<code>与</code> 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。2 进制表示是<code> 0000 0000 0000 0000 0000 0000 0000 1111</code>。和某个散列值做 <code>与</code> 操作如下，结果就是截取了最低的四位值。</p><p><img src="https://s2.loli.net/2023/03/30/KYGChw6ORBvsMp7.png" alt="哈希&amp;运算"></p><p>这样是要快捷一些，但是新的问题来了，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，那就更难搞了。</p><p>这时候 <code>扰动函数</code> 的价值就体现出来了，看一下扰动函数的示意图：</p><p><img src="https://s2.loli.net/2023/03/30/NbkwrZ1lzAJ8T6B.jpg" alt="扰动函数示意图"></p><p>右移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p><h3 id="15-为什么HashMap的容量是2的倍数呢？">15.为什么HashMap的容量是2的倍数呢？</h3><ul><li>第一个原因是为了方便哈希取余：</li></ul><p>将元素放在table数组上面，是用hash值%数组大小定位位置，而HashMap是用hash值&amp;(数组大小-1)，却能和前面达到一样的效果，这就得益于HashMap的大小是2的倍数，2的倍数意味着该数的二进制位只有一位为1，而该数-1就可以得到二进制位上1变成0，后面的0变成1，再通过&amp;运算，就可以得到和%一样的效果，并且位运算比%的效率高得多</p><p>HashMap的容量是2的n次幂时，(n-1)的2进制也就是1111111***111这样形式的，这样与添加元素的hash值进行位运算时，能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。</p><ul><li>第二个方面是在扩容时，利用扩容后的大小也是2的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去</li></ul><p>我们可以简单看看HashMap的扩容机制，HashMap中的元素在超过<code>负载因子*HashMap</code>大小时就会产生扩容。</p><p><img src="https://s2.loli.net/2023/03/30/nOwiMKlQjVq8L7k.png" alt="put中的扩容"></p><h3 id="16-如果初始化HashMap，传一个17的值new-HashMap-，它会怎么处理？">16.如果初始化HashMap，传一个17的值<code>new HashMap&lt;&gt;</code>，它会怎么处理？</h3><p>简单来说，就是初始化时，传的不是2的倍数时，HashMap会向上寻找<code>离得最近的2的倍数</code>，所以传入17，但HashMap的实际容量是32。</p><p>我们来看看详情，在HashMap的初始化中，有这样⼀段⽅法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line"> <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阀值 threshold ，通过⽅法<code> tableSizeFor</code> 进⾏计算，是根据初始化传的参数来计算的。</li><li>同时，这个⽅法也要要寻找⽐初始值⼤的，最⼩的那个2进制数值。⽐如传了17，我应该找到的是32。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line"> n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line"> <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，这个是临界范围，也就是最⼤的Map集合。</li><li>计算过程是向右移位1、2、4、8、16，和原来的数做<code>|</code>运算，这主要是为了把⼆进制的各个位置都填上1，当⼆进制的各个位置都是1以后，就是⼀个标准的2的倍数减1了，最后把结果加1再返回即可。</li></ul><p>以17为例，看一下初始化计算table容量的过程：</p><p><img src="https://s2.loli.net/2023/03/30/h1ipvRAwIkBs4La.png" alt="容量计算"></p><h3 id="17-你还知道哪些哈希函数的构造方法呢？">17.你还知道哪些哈希函数的构造方法呢？</h3><p>HashMap里哈希构造函数的方法叫：</p><ul><li><strong>除留取余法</strong>：H（key)=key%p（p&lt;=N）,关键字除以一个不大于哈希表长度的正整数p，所得余数为地址，当然HashMap里进行了优化改造，效率更高，散列也更均衡。</li></ul><p>除此之外，还有这几种常见的哈希函数构造方法：</p><ul><li><p><strong>直接定址法</strong></p><p>直接根据<code>key</code>来映射到对应的数组位置，例如1232放到下标1232的位置。</p></li><li><p><strong>数字分析法</strong></p><p>取<code>key</code>的某些数字（例如十位和百位）作为映射的位置</p></li><li><p><strong>平方取中法</strong></p><p>取<code>key</code>平方的中间几位作为映射的位置</p></li><li><p><strong>折叠法</strong></p><p>将<code>key</code>分割成位数相同的几段，然后把它们的叠加和作为映射的位置</p></li></ul><p><img src="https://s2.loli.net/2023/03/30/xZT4wamiA7qQvCj.png" alt="散列函数构造"></p><h3 id="18-解决哈希冲突有哪些方法呢？">18.解决哈希冲突有哪些方法呢？</h3><p>我们到现在已经知道，HashMap使用链表的原因为了处理哈希冲突，这种方法就是所谓的：</p><ul><li><strong>链地址法</strong>：在冲突的位置拉一个链表，把冲突的元素放进去。</li></ul><p>除此之外，还有一些常见的解决冲突的办法：</p><ul><li><p><strong>开放定址法</strong>：开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位。</p><p>找到空闲位置的方法也有很多种：</p><ul><li>线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置</li><li>平方探查法: 从冲突的位置x开始，第一次增加<code>1^2</code>个位置，第二次增加<code>2^2</code>…，直至找到空闲的位置</li><li>……</li></ul></li></ul><p><img src="https://s2.loli.net/2023/03/30/L7ezipwoPr9YRsq.png" alt="开放定址法"></p><ul><li><strong>再哈希法</strong>：换种哈希函数，重新计算冲突元素的地址。</li><li><strong>建立公共溢出区</strong>：再建一个数组，把冲突的元素放进去。</li></ul><h3 id="19-为什么HashMap链表转红黑树的阈值为8呢？">19.为什么HashMap链表转红黑树的阈值为8呢？</h3><p>树化发生在table数组的长度大于64，且链表的长度大于8的时候。</p><p>为什么是8呢？源码的注释也给出了答案。</p><p><img src="https://s2.loli.net/2023/03/30/CcftQIAbkvo5UGT.png" alt="源码注释"></p><p>红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。</p><p>阈值为什么要选8呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为8的情况，发生概率仅为<code>0.00000006</code>。</p><p>至于红黑树转回链表的阈值为什么是6，而不是8？是因为如果这个阈值也设置成8，假如发生碰撞，节点增减刚好在8附近，会发生链表和红黑树的不断转换，导致资源浪费。</p><h3 id="20-扩容在什么时候呢？为什么扩容因子是0-75？">20.扩容在什么时候呢？为什么扩容因子是0.75？</h3><p>为了减少哈希冲突发生的概率，当当前HashMap的元素个数达到一个临界值的时候，就会触发扩容，把所有元素rehash之后再放在扩容后的容器中，这是一个相当耗时的操作。</p><p><img src="https://s2.loli.net/2023/03/30/fBP5sM1ehyqVItr.png" alt="put时，扩容"></p><p>而这个<code>临界值threshold</code>就是由加载因子和当前容器的容量大小来确定的，假如采用默认的构造方法：</p><blockquote><p>临界值（threshold ）= 默认容量（DEFAULT_INITIAL_CAPACITY） * 默认扩容因子（DEFAULT_LOAD_FACTOR）</p></blockquote><p><img src="https://s2.loli.net/2023/03/30/gF7LOSVIPvkaMb4.png" alt="threshold计算"></p><p>那就是大于<code>16x0.75=12</code>时，就会触发扩容操作。</p><blockquote><p>那么为什么选择了0.75作为HashMap的默认加载因子呢？</p></blockquote><p>简单来说，这是对<code>空间</code>成本和<code>时间</code>成本平衡的考虑。</p><p>在HashMap中有这样一段注释：</p><p><img src="https://s2.loli.net/2023/03/30/cGRF3q45VeQNOmh.png" alt="关于默认负载因子的注释"></p><p>我们都知道，HashMap的散列构造方式是Hash取余，负载因子决定元素个数达到多少时候扩容。</p><p>假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了。</p><p>我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了。</p><h3 id="21-那扩容机制了解吗？">21.那扩容机制了解吗？</h3><p>HashMap是基于数组+链表和红黑树实现的，但用于存放key值的桶数组的长度是固定的，由初始化参数确定。</p><p>那么，随着数据的插入数量增加以及负载因子的作用下，就需要扩容来存放更多的数据。而扩容中有一个非常重要的点，就是jdk1.8中的优化操作，可以不需要再重新计算每一个元素的哈希值。</p><p>因为HashMap的初始容量是2的次幂，扩容之后的长度是原来的二倍，新的容量也是2的次幂，所以，元素，要么在原位置，要么在原位置再移动2的次幂。</p><p>看下这张图，n为table的长度，图<code>a</code>表示扩容前的key1和key2两种key确定索引的位置，图<code>b</code>表示扩容后key1和key2两种key确定索引位置。</p><p><img src="https://s2.loli.net/2023/03/30/vyY18GMe6HSzCUL.png" alt="扩容之后的索引计算"></p><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://s2.loli.net/2023/03/30/OzvtXqnhRW8cNsC.png" alt="扩容位置变化"></p><p>所以在扩容时，只需要看原来的hash值新增的那一位是0还是1就行了，是0的话索引没变，是1的化变成<code>原索引+oldCap</code>，看看如16扩容为32的示意图：</p><p><img src="https://s2.loli.net/2023/03/30/vfD5VYNLG4lpkzj.png" alt="扩容节点迁移示意图"></p><p>扩容节点迁移主要逻辑：</p><p><img src="https://s2.loli.net/2023/03/30/ltNvzHy6i1ER24X.png" alt="扩容主要逻辑"></p><h3 id="22-jdk1-8对HashMap主要做了哪些优化呢？为什么？">22.jdk1.8对HashMap主要做了哪些优化呢？为什么？</h3><p>jdk1.8 的HashMap主要有五点优化：</p><ol><li><p><strong>数据结构</strong>：数组 + 链表改成了数组 + 链表或红黑树</p><p><code>原因</code>：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度由<code>O(n)</code>降为<code>O(logn)</code></p></li><li><p><strong>链表插入方式</strong>：链表的插入方式从头插法改成了尾插法</p><p>简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。</p><div class="note info flat"><p><code>原因</code>：<a href="https://www.bilibili.com/video/BV1n541177Ea?t=108.7">因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环</a>。</p></div></li><li><p><strong>扩容rehash</strong>：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 新增容量大小。</p><p><code>原因：</code>提高扩容的效率，更快地扩容。</p></li><li><p><strong>扩容时机</strong>：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；</p></li><li><p><strong>散列函数</strong>：1.7 做了四次移位和四次异或，jdk1.8只做一次。</p><p><code>原因</code>：做 4 次的话，边际效用也不大，改为一次，提升效率。</p></li></ol><h3 id="23-你能自己设计实现一个HashMap吗？">23.你能自己设计实现一个HashMap吗？</h3><p>这道题<strong>快手</strong>常考。</p><p>不要慌，红黑树版咱们多半是写不出来，但是数组+链表版还是问题不大的，详细可见： <a href="https://mp.weixin.qq.com/s/Z9yoRZW5itrtgbS-cj0bUg">手写HashMap，快手面试官直呼内行！</a>。</p><p>整体的设计：</p><ul><li>散列函数：hashCode()+除留余数法</li><li>冲突解决：链地址法</li><li>扩容：节点重新hash获取位置</li></ul><p><img src="https://s2.loli.net/2023/03/30/P3x8oUsrJQ7iWLd.png" alt="自定义HashMap整体结构"></p><p>完整代码：</p><p><img src="https://s2.loli.net/2023/03/30/LaNMlfItiH37ZFz.png" alt="完整代码"></p><h3 id="24-HashMap-是线程安全的吗？多线程下会有什么问题？">24.HashMap 是线程安全的吗？多线程下会有什么问题？</h3><p>HashMap不是线程安全的，可能会发生这些问题：</p><ul><li><p>多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p></li><li><p>多线程的 put 可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。</p></li><li><p>put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出 threshold 而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。这个问题在 JDK 1.7 和 JDK 1.8 中都存在。</p></li></ul><h3 id="25-有什么办法能解决HashMap线程不安全的问题呢？">25.有什么办法能解决HashMap线程不安全的问题呢？</h3><p>Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。</p><ul><li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；</li><li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li><li>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。</li></ul><h3 id="26-能具体说一下ConcurrentHashmap的实现吗？">26.能具体说一下ConcurrentHashmap的实现吗？</h3><p>ConcurrentHashmap线程安全在jdk1.7版本是基于<code>分段锁</code>实现，在jdk1.8是基于<code>CAS+synchronized</code>实现。</p><h4 id="1-7分段锁">1.7分段锁</h4><p>从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</p><p>实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。</p><p><img src="https://s2.loli.net/2023/03/30/zwXY2OaFnkyq64Z.png" alt="1.7ConcurrentHashMap示意图"></p><p><strong>put流程</strong></p><p>整个流程和HashMap非常类似，只不过是先定位到具体的Segment，然后通过ReentrantLock去操作而已，后面的流程，就和HashMap基本上是一样的。</p><ol><li>计算hash，定位到segment，segment如果是空就先初始化</li><li>使用ReentrantLock加锁，如果获取锁失败则尝试自旋，自旋超过次数就阻塞获取，保证一定获取锁成功</li><li>遍历HashEntry，就是和HashMap一样，数组中key和hash一样就直接替换，不存在就再插入链表，链表同样操作</li></ol><p><img src="https://s2.loli.net/2023/04/09/aFKShU23xTwEXCc.jpg" alt="640.jpg"></p><p><strong>get流程</strong></p><p>get也很简单，key通过hash定位到segment，再遍历链表定位到具体的元素上，需要注意的是value是volatile的，所以get是不需要加锁的。</p><h4 id="1-8-CAS-synchronized"><strong>1.8 CAS+synchronized</strong></h4><p>jdk1.8实现线程安全不是在数据结构上下功夫，它的数据结构和HashMap是一样的，数组+链表+红黑树。它实现线程安全的关键点在于put流程。</p><p><strong>put流程</strong></p><ol><li>首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab = initTable();</span><br></pre></td></tr></table></figure><p>node数组初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果正在初始化或者扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;   <span class="comment">//CAS操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.如果当前数组位置是空则直接通过CAS自旋写入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果hash==MOVED，说明需要扩容，执行扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过8就转换成红黑树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f)&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/30/rADRuMC15ovaXqH.jpg" alt="ConcurrentHashmap jdk1.8put流程"></p><p><strong>get查询</strong></p><p>get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，如果是红黑树按照红黑树获取，否则就遍历链表获取。</p><h4 id="为什么是synchronized，而不是ReentranLock">为什么是synchronized，而不是ReentranLock</h4><p>（1）减少内存开销</p><p>假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承AQS来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p><p>（2）获得JVM的支持</p><div class="note info flat"><p><strong>扩展点</strong>：cmap的扩容过程（协助扩容）</p><ol><li>计算扩容戳，左移16位+2，标记自己是扩容的第一个线程</li><li>计算每个线程迁移的步长，和CPU内核数量有关，最小值是16</li><li>初始化新数组，线程领取任务，开始扩容</li><li>迁移结束之后，判断是不是最后一个扩容的线程</li><li>如果是则从头到尾检查一遍数据有没有完全迁移，有遗漏的数据则当前线程进行迁移</li></ol></div><h3 id="27-HashMap-内部节点是有序的吗？">27.HashMap 内部节点是有序的吗？</h3><p>HashMap是无序的，根据 hash 值随机插入。如果想使用有序的Map，可以使用LinkedHashMap 或者 TreeMap。</p><h3 id="28-讲讲-LinkedHashMap-怎么实现有序的？">28.讲讲 LinkedHashMap 怎么实现有序的？</h3><p>LinkedHashMap维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点 Entry 内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。</p><p><img src="https://s2.loli.net/2023/03/30/hIf8lztO7psuPiq.png" alt="Entry节点"></p><p>可以实现按插入的顺序或访问顺序排序。</p><p><img src="https://s2.loli.net/2023/03/30/G7DHUEdkp8O4tbn.png" alt="LinkedHashMap实现原理"></p><h3 id="29-讲讲-TreeMap-怎么实现有序的？">29.讲讲 TreeMap 怎么实现有序的？</h3><p>TreeMap 是按照 Key 的自然顺序或者 Comprator 的顺序进行排序，内部是通过红黑树来实现。所以要么 key 所属的类实现 Comparable 接口，或者自定义一个实现了 Comparator 接口的比较器，传给 TreeMap 用于 key 的比较。</p><p><img src="https://s2.loli.net/2023/03/30/km1FTwO3ayi4rcQ.png" alt="TreeMap"></p><h2 id="Set">Set</h2><p>Set面试没啥好问的，拿HashSet来凑个数。</p><h3 id="30-讲讲HashSet的底层实现？">30.讲讲HashSet的底层实现？</h3><p>HashSet 底层就是基于 HashMap 实现的。（ HashSet 的源码⾮常⾮常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。</p><p>HashSet的add方法，直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value，直接调用HashMap的put方法，它会根据返回值是否为空来判断是否插入元素成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/30/hoJCT8VBzaq4gci.png" alt="HashSet套娃"></p><p>而在HashMap的putVal方法中，进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> 集合框架篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM篇(修正版)</title>
      <link href="/posts/8d7d8ac3.html"/>
      <url>/posts/8d7d8ac3.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>JVM推荐马士兵的这套课，虽然对培训机构推销卖课非常反感，但是不可否认，这套讲得非常清楚。</p><p><a class="btn-beautify blue" href="https://www.bilibili.com/video/BV1SX4y1U7x2?p=9&vd_source=fe2653ebe933d4d68f2279ef88b506f5"   title="点击跳转" target="_blank"><i class="fa-brands fa-bilibili"></i><span>点击跳转</span></a></p></div> <h2 id="一、引言">一、引言</h2><h3 id="1-什么是-JVM">1.什么是 JVM?</h3><p>JVM——Java 虚拟机，它是 Java 实现平台无关性的基石。</p><p>Java 程序运行的时候，编译器将 Java 文件编译成平台无关的 Java 字节码文件（.class）,接下来对应平台 JVM 对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。</p><p><img src="https://s2.loli.net/2023/03/30/uoZIK4mhApW28wn.png" alt="Java语言编译运行"></p><p>同时 JVM 也是一个跨语言的平台，和语言无关，只和 class 的文件格式关联，任何语言，只要能翻译成符合规范的字节码文件，都能被 JVM 运行。</p><p><img src="https://s2.loli.net/2023/03/30/HlzkL3MWcuVSDja.png" alt="JVM跨语言"></p><h2 id="二、内存管理">二、内存管理</h2><h3 id="2-能说一下-JVM-的内存区域吗？">2.能说一下 JVM 的内存区域吗？</h3><p>JVM 内存区域最粗略的划分可以分为<code>堆</code>和<code>栈</code>，当然，按照虚拟机规范，可以划分为以下几个区域：</p><p><img src="https://s2.loli.net/2023/03/30/7j5M6KkDRqBNlrs.png" alt="Java虚拟机运行时数据区"></p><p>JVM 内存分为线程私有区和线程共享区，其中<code>方法区</code>和<code>堆</code>是线程共享区，<code>虚拟机栈</code>、<code>本地方法栈</code>和<code>程序计数器</code>是线程隔离的数据区。</p><p><strong>1）程序计数器</strong></p><p>程序计数器（Program Counter Register）也被称为 PC 寄存器，是一块较小的内存空间。</p><p>它可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>2）Java 虚拟机栈</strong></p><p>Java 虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。</p><p>Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：方法执行时，JVM 会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。</p><p><img src="https://s2.loli.net/2023/03/30/2la8JDBStqYs4d5.png" alt="Java虚拟机栈"></p><p><strong>3）本地方法栈</strong></p><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><p>Java 虚拟机规范允许本地方法栈被实现成固定大小的或者是根据计算动态扩展和收缩的。</p><p><strong>4）Java 堆</strong></p><p>对于 Java 应用程序来说，Java 堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 里“<strong>几乎</strong>”所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC 堆”（Garbage Collected Heap，）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆中经常会出现<code>新生代</code>、<code>老年代</code>、<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是 Java 虚拟机规范本身制定的。</p><p><img src="https://s2.loli.net/2023/03/30/oiZbcn7hfF8PlSs.png" alt="Java 堆内存结构"></p><p><strong>5）方法区</strong></p><p>方法区是比较特别的一块区域，和堆类似，它也是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>它特别在 Java 虚拟机规范对它的约束非常宽松，所以方法区的具体实现历经了许多变迁，例如 jdk1.7 之前使用永久代作为方法区的实现。</p><h3 id="3-说一下-JDK1-6、1-7、1-8-内存区域的变化？">3.说一下 JDK1.6、1.7、1.8 内存区域的变化？</h3><p>JDK1.6、1.7/1.8 内存区域发生了变化，主要体现在方法区的实现：</p><ul><li>JDK1.6 使用永久代实现方法区：</li></ul><p><img src="https://s2.loli.net/2023/03/30/cZ5YxGSAs8rfMRi.png" alt="JDK 1.6内存区域"></p><ul><li>JDK1.7 时发生了一些变化，将字符串常量池、静态变量，存放在堆上</li></ul><p><img src="https://s2.loli.net/2023/03/30/oyPIQL6J7dphsSO.png" alt="JDK 1.7内存区域"></p><ul><li>在 JDK1.8 时彻底干掉了永久代，而在直接内存中划出一块区域作为<strong>元空间</strong>，运行时常量池、类常量池都移动到元空间。</li></ul><p><img src="https://s2.loli.net/2023/03/30/WxaTrMmQ6nqR3GN.png" alt="JDK 1.8内存区域"></p><h3 id="4-为什么使用元空间替代永久代作为方法区的实现？">4.为什么使用元空间替代永久代作为方法区的实现？</h3><p>Java 虚拟机规范规定的方法区只是换种方式实现。有客观和主观两个原因。</p><ul><li><p>客观上使用永久代来实现方法区的决定的设计导致了 Java 应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize 的上限，即使不设置也有默认大小，而 J9 和 JRockit 只要没有触碰到进程可用内存的上限，例如 32 位系统中的 4GB 限制，就不会出问题），而且有极少数方法 （例如 String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。</p></li><li><p>主观上当 Oracle 收购 BEA 获得了 JRockit 的所有权后，准备把 JRockit 中的优秀功能，譬如 Java Mission Control 管理工具，移植到 HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到 HotSpot 未来的发展，在 JDK 6 的 时候 HotSpot 开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了，到了 JDK 7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Meta-space）来代替，把 JDK 7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</p></li></ul><h3 id="5-对象创建的过程了解吗？">5.对象创建的过程了解吗？</h3><p>在 JVM 中对象的创建，我们从一个 new 指令开始：</p><ul><li><p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用</p></li><li><p>检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就先执行相应的类加载过程</p></li><li><p>类加载检查通过后，接下来虚拟机将为新生对象分配内存。</p></li><li><p>内存分配完成之后，虚拟机将分配到的内存空间（但不包括对象头）都初始化为零值。</p></li><li><p>接下来设置对象头，请求头里包含了对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。</p></li></ul><p>这个过程大概图示如下：</p><p><img src="https://s2.loli.net/2023/03/30/LS3cZfAqv1kxTCG.png" alt="对象创建过程"></p><h3 id="6-什么是指针碰撞？什么是空闲列表？">6.什么是指针碰撞？什么是空闲列表？</h3><p>内存分配有两种方式，<strong>指针碰撞</strong>（Bump The Pointer）、<strong>空闲列表</strong>（Free List）。</p><p><img src="https://s2.loli.net/2023/03/30/5RCaebIJkZM1tzU.png" alt="指针碰撞和空闲列表"></p><ul><li>指针碰撞：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</li><li>空闲列表：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</li><li>两种方式的选择由 Java 堆是否规整决定，Java 堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的。</li></ul><h3 id="7-JVM-里-new-对象时，堆会发生抢占吗？JVM-是怎么设计来保证线程安全的？">7.JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？</h3><p>会，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。</p><p>有两种可选方案来解决这个问题：</p><p><img src="https://s2.loli.net/2023/03/30/ym1Ug98VkCFYMAN.png" alt="堆抢占和解决方案"></p><ul><li><p>采用 CAS 分配重试的方式来保证更新操作的原子性</p></li><li><p>每个线程在 Java 堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local Allocation</p><p>Buffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</p></li></ul><h3 id="8-能说一下对象的内存布局吗？">8.能说一下对象的内存布局吗？</h3><p>在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p><img src="https://s2.loli.net/2023/03/30/9xHeQ4AZTRoYvUs.png" alt="对象的存储布局"></p><p><strong>对象头</strong>主要由两部分组成：</p><ul><li>第一部分存储对象自身的运行时数据：哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，官方称它为 Mark Word，它是个动态的结构，随着对象状态变化。</li><li>第二部分是类型指针，指向对象的类元数据类型（即对象代表哪个类）。</li><li>此外，如果对象是一个 Java 数组，那还应该有一块用于记录数组长度的数据</li></ul><p><strong>实例数据</strong>用来存储对象真正的有效信息，也就是我们在程序代码里所定义的各种类型的字段内容，无论是从父类继承的，还是自己定义的。</p><p><strong>对齐填充</strong>不是必须的，没有特别含义，仅仅起着占位符的作用。</p><h3 id="9-对象怎么访问定位？">9.对象怎么访问定位？</h3><p>Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在《Java 虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：</p><ul><li>如果使用句柄访问的话，Java 堆中将可能会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，其结构如图所示：</li></ul><p><img src="https://s2.loli.net/2023/03/30/t1NBgpzcuv5oIRk.png" alt="通过句柄访问对象"></p><ul><li>如果使用直接指针访问的话，Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示：</li></ul><p><img src="https://s2.loli.net/2023/03/30/oxLDUqiCI1ASBcy.png" alt="通过直接指针访问对象"></p><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p>HotSpot 虚拟机主要使用直接指针来进行对象访问。</p><h3 id="10-内存溢出和内存泄漏是什么意思？">10.内存溢出和内存泄漏是什么意思？</h3><p>内存泄露就是申请的内存空间没有被正确释放，导致内存被白白占用。</p><p>内存溢出就是申请的内存超过了可用内存，内存不够了。</p><p>两者关系：内存泄露可能会导致内存溢出。</p><p>用一个有味道的比喻，内存溢出就是排队去蹲坑，发现没坑位了，内存泄漏，就是有人占着茅坑不拉屎，占着茅坑不拉屎的多了可能会导致坑位不够用。</p><p><img src="https://s2.loli.net/2023/03/30/wUzhpl8TQ6XBVEL.png" alt="内存泄漏、内存溢出"></p><h3 id="11-能手写内存溢出的例子吗？">11.能手写内存溢出的例子吗？</h3><p>在 JVM 的几个内存区域中，除了程序计数器外，其他几个运行时区域都有发生内存溢出（OOM）异常的可能，重点关注堆和栈。</p><ul><li>Java 堆溢出</li></ul><p>Java 堆用于储存对象实例，只要不断创建不可被回收的对象，比如静态对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常（OutOfMemoryError）。</p><p>这就相当于一个房子里，不断堆积不能被收走的杂物，那么房子很快就会被堆满了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">OOMObject</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">OOMObject</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>虚拟机栈.OutOfMemoryError</li></ul><p>JDK 使用的 HotSpot 虚拟机的栈内存大小是固定的，我们可以把栈的内存设大一点，然后不断地去创建线程，因为操作系统给每个进程分配的内存是有限的，所以到最后，也会发生 OutOfMemoryError 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vm参数：-Xss2M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaVMStackOOM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dontStop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stackLeakByThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    dontStop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">JavaVMStackOOM</span> <span class="variable">oom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaVMStackOOM</span>();</span><br><span class="line">        oom.stackLeakByThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="12-内存泄漏可能由哪些原因导致呢？">12.内存泄漏可能由哪些原因导致呢？</h3><p>内存泄漏可能的原因有很多种：</p><p><img src="https://s2.loli.net/2023/03/30/JgzT7YWUrMQ96Xn.png" alt="内存泄漏可能原因"></p><p><strong>静态集合类引起内存泄漏</strong></p><p>静态集合的生命周期和 JVM 一致，所以静态集合引用的对象不能被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOM</span> &#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">   list.add(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>单例模式</strong></p><p>和上面的例子原理类似，单例对象在初始化后会以静态变量的方式在 JVM 的整个生命周期中存在。如果单例对象持有外部的引用，那么这个外部对象将不能被 GC 回收，导致内存泄漏。</p><p><strong>数据连接、IO、Socket 等连接</strong></p><p>创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//不关闭连接</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>变量不合理的作用域</strong></p><p>一个变量的定义作用域大于其使用范围，很可能存在内存泄漏；或不再使用对象没有及时将对象设置为 null，很可能导致内存泄漏的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Simple</span> &#123;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        object = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">        <span class="comment">//由于作用域原因，method1执行完成之后，object 对象所分配的内存不会马上释放</span></span><br><span class="line">        object = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>hash 值发生变化</strong></p><p>对象 Hash 值改变，使用 HashMap、HashSet 等容器中时候，由于对象修改之后的 Hah 值和存储进容器时的 Hash 值不同，所以无法找到存入的对象，自然也无法单独删除了，这也会造成内存泄漏。说句题外话，这也是为什么 String 类型被设置成了不可变类型。</p><p><strong>ThreadLocal 使用不当</strong></p><p>ThreadLocal 的弱引用导致内存泄漏也是个老生常谈的话题了，使用完 ThreadLocal 一定要记得使用 remove 方法来进行清除。</p><h3 id="13-如何判断对象仍然存活？">13.如何判断对象仍然存活？</h3><p>有两种方式，<strong>引用计数算法</strong>（reference counting）和可达性分析算法。</p><ul><li><strong>引用计数算法</strong></li></ul><p>引用计数器的算法是这样的：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p><img src="https://s2.loli.net/2023/03/30/aBdseGOLNK1tboU.png" alt="引用计数算法"></p><ul><li><strong>可达性分析算法</strong></li></ul><p>目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（Gc Root Set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。<br><img src="https://s2.loli.net/2023/03/30/vHQBsbr7lWkJiKm.png" alt="GC Root"></p><h3 id="14-Java-中可作为-GC-Roots-的对象有哪几种？">14.Java 中可作为 GC Roots 的对象有哪几种？</h3><p>可以作为 GC Roots 的主要有四种对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI 引用的对象</li></ul><h3 id="15-说一下对象有哪几种引用？">15.说一下对象有哪几种引用？</h3><p>Java 中的引用有四种，分为强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><ul><li>强引用是最传统的<code>引用</code>的定义，是指在程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><ul><li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。在 JDK 1.2 版之后提供了 SoftReference 类来实现软引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 版之后提供了 WeakReference 类来实现弱引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在 JDK 1.2 版之后提供了 PhantomReference 类来实现虚引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(obj, queue);</span><br><span class="line"><span class="comment">//强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/03/30/Rek31rjuPHwT9BC.png" alt="四种引用总结"></p><h3 id="16-finalize-方法了解吗？有什么作用？">16.finalize()方法了解吗？有什么作用？</h3><p>用一个不太贴切的比喻，垃圾回收就是古代的秋后问斩，finalize()就是刀下留人，在人犯被处决之前，还要做最后一次审计，青天大老爷看看有没有什么冤情，需不需要刀下留人。</p><p><img src="https://s2.loli.net/2023/03/30/ZJy95wdcbIEM1WL.png" alt="刀下留人"></p><p>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。如果对象在在 finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它就”逃过一劫“；但是如果没有抓住这个机会，那么对象就真的要被回收了。</p><h3 id="17-Java-堆的内存分区了解吗？">17.Java 堆的内存分区了解吗？</h3><p>按照垃圾收集，将 Java 堆划分为<strong>新生代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation）两个区域，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>而新生代又可以分为三个区域，eden、from、to，比例是 8：1：1，而新生代的内存分区同样是从垃圾收集的角度来分配的。</p><p><img src="https://s2.loli.net/2023/03/30/T5nf2W6XGEYPLbi.png" alt="Java堆内存划分"></p><h3 id="18-垃圾收集算法了解吗？">18.垃圾收集算法了解吗？</h3><p>垃圾收集算法主要有三种：</p><ol><li><strong>标记-清除算法</strong></li></ol><p>见名知义，<code>标记-清除</code>（Mark-Sweep）算法分为两个阶段：</p><ul><li><strong>标记</strong> : 标记出所有需要回收的对象</li><li><strong>清除</strong>：回收所有被标记的对象</li></ul><p><img src="https://s2.loli.net/2023/03/30/ePtl1JKo8COyjWX.png" alt="标记-清除算法"></p><p>标记-清除算法比较基础，但是主要存在两个缺点：</p><ul><li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><ol start="2"><li><strong>标记-复制算法</strong></li></ol><p>标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。</p><p>过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><img src="https://s2.loli.net/2023/03/30/FrBsbmJydhq9z4M.png" alt="标记-复制算法"></p><p>这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。</p><p>新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。当然，实际新生代的收集不是按照这个比例。</p><ol start="3"><li><strong>标记-整理算法</strong></li></ol><p>为了降低内存的消耗，引入一种针对性的算法：<code>标记-整理</code>（Mark-Compact）算法。</p><p>其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p><img src="https://s2.loli.net/2023/03/30/XPAsUg7FI4E36rQ.png" alt="标记-整理算法"></p><p>标记-整理算法主要用于老年代，移动存活对象是个极为负重的操作，而且这种操作需要 Stop The World 才能进行，只是从整体的吞吐量来考量，老年代使用标记-整理算法更加合适。</p><h3 id="19-说一下新生代的区域划分？">19.说一下新生代的区域划分？</h3><p>新生代的垃圾收集主要采用标记-复制算法，因为新生代的存活对象比较少，每次复制少量的存活对象效率比较高。</p><p>基于这种算法，虚拟机将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。默认 Eden 和 Survivor 的大小比例是 8∶1。</p><p><img src="https://s2.loli.net/2023/03/30/ufk78FoDvKWhA6L.png" alt="新生代内存划分"></p><h3 id="20-Minor-GC-Young-GC、Major-GC-Old-GC、Mixed-GC、Full-GC-都是什么意思？">20.Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC 都是什么意思？</h3><p><strong>部分收集</strong>（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集，其中又分为：</p><ul><li><p>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</p></li><li><p>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前<strong>只有</strong>CMS 收集器会有单独收集老年代的行为。</p></li><li><p>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。</p></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p></li></ul><h3 id="21-Minor-GC-Young-GC-什么时候触发？">21.Minor GC/Young GC 什么时候触发？</h3><p>新创建的对象优先在新生代 Eden 区进行分配，如果 Eden 区没有足够的空间时，就会触发 Young GC 来清理新生代。</p><h3 id="22-什么时候会触发-Full-GC？">22.什么时候会触发 Full GC？</h3><p>这个触发条件稍微有点多，往下看：</p><p><img src="https://s2.loli.net/2023/03/30/vrWxy7ljnLMQged.png" alt="Full GC触发条件"></p><ul><li><strong>Young GC 之前检查老年代</strong>：在要进行 Young GC 的时候，发现<code>老年代可用的连续内存空间</code> &lt; <code>新生代历次Young GC后升入老年代的对象总和的平均大小</code>，说明本次 Young GC 后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。</li><li><strong>Young GC 之后老年代空间不足</strong>：执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次 Full GC</li><li><strong>老年代空间不足</strong>，老年代内存使用率过高，达到一定比例，也会触发 Full GC。</li><li><strong>空间分配担保失败</strong>（ Promotion Failure），新生代的 To 区放不下从 Eden 和 From 拷贝过来对象，或者新生代对象 GC 年龄到达阈值需要晋升这两种情况，老年代如果放不下的话都会触发 Full GC。</li><li><strong>方法区内存空间不足</strong>：如果方法区由永久代实现，永久代空间不足 Full GC。</li><li><strong>System.gc()等命令触发</strong>：System.gc()、jmap -dump 等命令会触发 full gc。</li></ul><h3 id="23-对象什么时候会进入老年代？">23.对象什么时候会进入老年代？</h3><p><img src="https://s2.loli.net/2023/03/30/eZxAUzy2icnI6wd.png" alt="对象进入老年代"></p><p><strong>长期存活的对象将进入老年代</strong></p><p>在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次 YoungGC 之后对象的移区操作中增加,每一次移区年龄加一。当这个年龄达到 <code>15</code>(默认)之后,这个对象将会被移入老年代。</p><p>可以通过这个参数设置这个年龄值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- XX:MaxTenuringThreshold</span><br></pre></td></tr></table></figure><p><strong>大对象直接进入老年代</strong></p><p>有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对象。</p><p>在 JVM 中，默认情况下，超过 128KB 大小的对象会被视为大对象。HotSpot 虚拟机提供了这个参数来设置。这个默认值是可以通过 JVM 命令行参数来调整的，例如使用 -XX:PretenureSizeThreshold 选项可以指定大对象的大小阈值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：PretenureSizeThreshold</span><br></pre></td></tr></table></figure><p><strong>动态对象年龄判定</strong></p><p>为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。</p><h3 id="24-知道有哪些垃圾收集器吗？">24.知道有哪些垃圾收集器吗？</h3><p>主要垃圾收集器如下，图中标出了它们的工作区域、垃圾收集算法，以及配合关系。</p><p><img src="https://s2.loli.net/2023/03/30/nEItgFrfH7yl5Vv.png" alt="HotSpot虚拟机垃圾收集器"></p><p>这些收集器里，面试的重点是两个——<strong>CMS</strong>和<strong>G1</strong>。</p><ul><li><p>Serial 收集器</p><p>Serial 收集器是最基础、历史最悠久的收集器。如同它的名字（串行），它是一个单线程工作的收集器，使用一个处理器或一条收集线程去完成垃圾收集工作。并且进行垃圾收集时，必须暂停其他所有工作线程，直到垃圾收集结束——这就是所谓的“Stop The World”。Serial/Serial Old 收集器的运行过程如图：</p></li></ul><p><img src="https://s2.loli.net/2023/03/30/MoOT62EFanQeLXf.png" alt="Serial/Serial Old收集器运行示意图"></p><ul><li><p>ParNew</p><p>ParNew 收集器实质上是 Serial 收集器的多线程并行版本，使用多条线程进行垃圾收集。ParNew/Serial Old 收集器运行示意图如下：</p></li></ul><p><img src="https://s2.loli.net/2023/03/30/sj41FG2YCRy3Swn.png" alt="ParNew/Serial Old收集器运行示意图"></p><ul><li><p>Parallel Scavenge</p><p>Parallel Scavenge 收集器是一款新生代收集器，基于标记-复制算法实现，也能够并行收集。和 ParNew 有些类似，但 Parallel Scavenge 主要关注的是垃圾收集的吞吐量——所谓吞吐量，就是 CPU 用于运行用户代码的时间和总消耗时间的比值，比值越大，说明垃圾收集的占比越小。</p></li></ul><p><img src="https://s2.loli.net/2023/03/30/3IK6pWjkQlvctLi.png" alt="吞吐量"></p><ul><li><p>Serial Old</p><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p></li><li><p>Parallel Old</p><p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p></li></ul><p><img src="https://s2.loli.net/2023/03/30/LtYDnKI7M2mkx1Q.png" alt="Parallel Scavenge/Parallel Old收集器运行示意图"></p><ul><li><p>CMS 收集器</p><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，同样是老年代的收集器，采用标记-清除算法。</p></li><li><p>Garbage First 收集器</p><p>Garbage First（简称 G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于 Region 的内存布局形式。</p></li></ul><h3 id="25-什么是-Stop-The-World-什么是-OopMap-？什么是安全点？">25.什么是 Stop The World ? 什么是 OopMap ？什么是安全点？</h3><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为<code>Stop The World</code>。也简称为 STW。</p><p>在 HotSpot 中，有个数据结构（映射表）称为<code>OopMap</code>。一旦类加载动作完成的时候，HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，记录到 OopMap。在即时编译过程中，也会在<code>特定的位置</code>生成 OopMap，记录下栈上和寄存器里哪些位置是引用。</p><p>这些特定的位置主要在：</p><ul><li><p>1.循环的末尾（非 counted 循环）</p></li><li><p>2.方法临返回前 / 调用方法的 call 指令后</p></li><li><p>3.可能抛异常的位置</p></li></ul><p>这些位置就叫作<strong>安全点(safepoint)。</strong> 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。</p><p>用通俗的比喻，假如老王去拉车，车上东西很重，老王累的汗流浃背，但是老王不能在上坡或者下坡休息，只能在平地上停下来擦擦汗，喝口水。</p><p><img src="https://s2.loli.net/2023/03/30/nTxbhpsQer8k13H.png" alt="老王拉车只能在平路休息"></p><h3 id="26-能详细说一下-CMS-收集器的垃圾收集过程吗？">26.能详细说一下 CMS 收集器的垃圾收集过程吗？</h3><p>CMS 收集齐的垃圾收集分为四步：</p><ul><li><strong>初始标记</strong>（CMS initial mark）：单线程运行，需要 Stop The World，标记 GC Roots 能直达的对象。</li><li><strong>并发标记</strong>（（CMS concurrent mark）：无停顿，和用户线程同时运行，从 GC Roots 直达对象开始遍历整个对象图。</li><li><strong>重新标记</strong>（CMS remark）：多线程运行，需要 Stop The World，标记并发标记阶段产生对象。</li><li><strong>并发清除</strong>（CMS concurrent sweep）：无停顿，和用户线程同时运行，清理掉标记阶段标记的死亡的对象。</li></ul><p>Concurrent Mark Sweep 收集器运行示意图如下：</p><p><img src="https://s2.loli.net/2023/03/30/2ANgbcuso9VQ6W5.png" alt="Concurrent Mark Sweep收集器运行示意图"></p><h3 id="27-G1-垃圾收集器了解吗？">27.G1 垃圾收集器了解吗？</h3><p>Garbage First（简称 G1）收集器是垃圾收集器的一个颠覆性的产物，它开创了局部收集的设计思路和基于 Region 的内存布局形式。</p><p>虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异。以前的收集器分代是划分新生代、老年代、持久代等。</p><p>G1 把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。收集器能够对扮演不同角色的 Region 采用不同的策略去处理。</p><p><img src="https://s2.loli.net/2023/03/30/46elgjSncOuC5wD.png" alt="G1 Heap Regions"></p><p>这样就避免了收集整个堆，而是按照若干个 Region 集进行收集，同时维护一个优先级列表，跟踪各个 Region 回收的“价值，优先收集价值高的 Region。</p><p>G1 收集器的运行过程大致可划分为以下四个步骤：</p><ul><li><strong>初始标记</strong>（initial mark），标记了从 GC Root 开始直接关联可达的对象。STW（Stop the World）执行。</li><li><strong>并发标记</strong>（concurrent marking），和用户线程并发执行，从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、</li><li><strong>最终标记</strong>（Remark），STW，标记再并发标记过程中产生的垃圾。</li><li><strong>筛选回收</strong>（Live Data Counting And Evacuation），制定回收计划，选择多个 Region 构成回收集，把回收集中 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。需要 STW。</li></ul><p><img src="https://s2.loli.net/2023/03/30/4YvnywjBoWhm8qT.png" alt="G1收集器运行示意图"></p><h3 id="28-有了-CMS，为什么还要引入-G1？">28.有了 CMS，为什么还要引入 G1？</h3><p>优点：CMS 最主要的优点在名字上已经体现出来——并发收集、低停顿。</p><p>缺点：CMS 同样有三个明显的缺点。</p><ul><li>Mark Sweep 算法会导致内存碎片比较多</li><li>CMS 的并发能力比较依赖于 CPU 资源，并发回收时垃圾收集线程可能会抢占用户线程的资源，导致用户程序性能下降。</li><li>并发清除阶段，用户线程依然在运行，会产生所谓的“浮动垃圾”（Floating Garbage），本次垃圾收集无法处理浮动垃圾，必须到下一次垃圾收集才能处理。如果浮动垃圾太多，会触发新的垃圾回收，导致性能降低。</li></ul><p>G1 主要解决了内存碎片过多的问题。</p><h3 id="29-你们线上用的什么垃圾收集器？为什么要用它？">29.你们线上用的什么垃圾收集器？为什么要用它？</h3><p>怎么说呢，虽然调优说的震天响，但是我们一般都是用默认。管你 Java 怎么升，我用 8，那么 JDK1.8 默认用的是什么呢？</p><p>可以使用命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p>可以看到有这么一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><code>UseParallelGC</code> = <code>Parallel Scavenge + Parallel Old</code>，表示的是新生代用的<code>Parallel Scavenge</code>收集器，老年代用的是<code>Parallel Old</code> 收集器。</p><p>那为什么要用这个呢？默认的呗。</p><p>当然面试肯定不能这么答。</p><p>Parallel Scavenge 的特点是什么？</p><p>高吞吐，我们可以回答：因为我们系统是业务相对复杂，但并发并不是非常高，所以希望尽可能的利用处理器资源，出于提高吞吐量的考虑采用<code>Parallel Scavenge + Parallel Old</code>的组合。</p><p>当然，这个默认虽然也有说法，但不太讨喜。</p><p>还可以说：</p><p>采用<code>Parallel New</code>+<code>CMS</code>的组合，我们比较关注服务的响应速度，所以采用了 CMS 来降低停顿时间。</p><p>或者一步到位：</p><p>我们线上采用了设计比较优秀的 G1 垃圾收集器，因为它不仅满足我们低停顿的要求，而且解决了 CMS 的浮动垃圾问题、内存碎片问题。</p><h3 id="30-垃圾收集器应该如何选择？">30.垃圾收集器应该如何选择？</h3><p>垃圾收集器的选择需要权衡的点还是比较多的——例如运行应用的基础设施如何？使用 JDK 的发行商是什么？等等……</p><p>这里简单地列一下上面提到的一些收集器的适用场景：</p><ul><li>Serial ：如果应用程序有一个很小的内存空间（大约 100 MB）亦或它在没有停顿时间要求的单线程处理器上运行。</li><li>Parallel：如果优先考虑应用程序的峰值性能，并且没有时间要求，或者可以接受 1 秒或更长的停顿时间。</li><li>CMS/G1：如果响应时间比吞吐量优先级高，或者垃圾收集暂停必须保持在大约 1 秒以内。</li><li>ZGC：如果响应时间是高优先级的，或者堆空间比较大。</li></ul><h3 id="31-对象一定分配在堆中吗？有没有了解逃逸分析技术？">31.对象一定分配在堆中吗？有没有了解逃逸分析技术？</h3><p><strong>对象一定分配在堆中吗？</strong> 不一定的。</p><p>随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT 会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p><strong>什么是逃逸分析？</strong></p><p><strong>逃逸分析</strong>是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。</p><p>通俗点讲，当一个对象被 new 出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。</p><p><img src="https://s2.loli.net/2023/03/30/phSscIe4MxU5lRz.png" alt="逃逸"></p><p>除此之外，如果对象还有可能被外部线程访问到，例如赋值给可以在其它线程中访问的实例变量，这种就被称为线程逃逸。</p><p><img src="https://s2.loli.net/2023/03/30/Xov8Q4aY3CbFrwH.png" alt="逃逸强度"></p><p><strong>逃逸分析的好处</strong></p><ul><li>栈上分配</li></ul><p>如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。</p><ul><li><strong>同步消除</strong></li></ul><p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p><ul><li><strong>标量替换</strong></li></ul><p>如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个 Java 对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。</p><h2 id="三、JVM-调优">三、JVM 调优</h2><h3 id="32-有哪些常用的命令行性能监控和故障处理工具？">32.有哪些常用的命令行性能监控和故障处理工具？</h3><ul><li><p>操作系统工具</p><ul><li>top：显示系统整体资源使用情况</li><li>vmstat：监控内存和 CPU</li><li>iostat：监控 IO 使用</li><li>netstat：监控网络使用</li></ul></li><li><p>JDK 性能监控工具</p><ul><li>jps：虚拟机进程查看</li><li>jstat：虚拟机运行时信息查看</li><li>jinfo：虚拟机配置查看</li><li>jmap：内存映像（导出）</li><li>jhat：堆转储快照分析</li><li>jstack：Java 堆栈跟踪</li><li>jcmd：实现上面除了 jstat 外所有命令的功能</li></ul></li></ul><h3 id="33-了解哪些可视化的性能监控和故障处理工具？">33.了解哪些可视化的性能监控和故障处理工具？</h3><p>以下是一些 JDK 自带的可视化性能监控和故障处理工具：</p><ul><li>JConsole</li></ul><p><img src="https://s2.loli.net/2023/03/30/hI2qbvgsFL7DTnH.png" alt="JConsole概览"></p><ul><li>VisualVM</li></ul><p><img src="https://s2.loli.net/2023/03/30/qe5XMKDoQkUWrZB.png" alt="VisualVM安装插件"></p><ul><li>Java Mission Control</li></ul><p><img src="https://s2.loli.net/2023/03/30/E2cBuQ7DrebnfRW.png" alt="JMC主要界面"></p><p>除此之外，还有一些第三方的工具：</p><ul><li><strong>MAT</strong></li></ul><p>Java 堆内存分析工具。</p><ul><li><strong>GChisto</strong></li></ul><p>GC 日志分析工具。</p><ul><li><strong>GCViewer</strong></li></ul><p><code>GC</code> 日志分析工具。</p><ul><li><strong>JProfiler</strong></li></ul><p>商用的性能分析利器。</p><ul><li><strong>arthas</strong></li></ul><p>阿里开源诊断工具。</p><ul><li><strong>async-profiler</strong></li></ul><p>Java 应用性能分析工具，开源、火焰图、跨平台。</p><h3 id="34-JVM-的常见参数配置知道哪些？">34.JVM 的常见参数配置知道哪些？</h3><p>一些常见的参数配置：</p><p><strong>堆配置：</strong></p><ul><li>-Xms：初始堆大小</li><li>-Xmx：最大堆大小</li><li>-XX:NewSize=n：设置年轻代大小</li><li>-XX:NewRatio=n：设置年轻代和年老代的比值。如：为 3 表示年轻代和年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4</li><li>-XX:SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如 3 表示 Eden： 3 Survivor：2，一个 Survivor 区占整个年轻代的 1/5</li><li>-XX:MaxPermSize=n：设置持久代大小</li></ul><p><strong>收集器设置：</strong></p><ul><li>-XX:+UseSerialGC：设置串行收集器</li><li>-XX:+UseParallelGC：设置并行收集器</li><li>-XX:+UseParalledlOldGC：设置并行年老代收集器</li><li>-XX:+UseConcMarkSweepGC：设置并发收集器</li></ul><p><strong>并行收集器设置</strong></p><ul><li>-XX:ParallelGCThreads=n：设置并行收集器收集时使用的 CPU 数。并行收集线程数</li><li>-XX:MaxGCPauseMillis=n：设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）</li><li>-XX:GCTimeRatio=n：设置垃圾回收时间占程序运行时间的百分比。公式为：1/(1+n)</li><li>-XX:+CMSIncrementalMode：设置为增量模式。适用于单 CPU 情况</li><li>-XX:ParallelGCThreads=n：设置并发收集器年轻代手机方式为并行收集时，使用的 CPU 数。并行收集线程数</li></ul><p><strong>打印 GC 回收的过程日志信息</strong></p><ul><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintGCTimeStamps</li><li>-Xloggc:filename</li></ul><h3 id="35-有做过-JVM-调优吗？">35.有做过 JVM 调优吗？</h3><p>JVM 调优是一件很严肃的事情，不是拍脑门就开始调优的，需要有严密的分析和监控机制，大概的一个 JVM 调优流程图：</p><p><img src="https://s2.loli.net/2023/03/30/kwngNYtKIhSiHdV.png" alt="JVM调优大致流程图"></p><p>实际上，JVM 调优是不得已而为之，有那功夫，好好把烂代码重构一下不比瞎调 JVM 强。</p><p>但是，面试官非要问怎么办？可以从处理问题的角度来回答（对应图中事后），这是一个中规中矩的案例：电商公司的运营后台系统，偶发性的引发 OOM 异常，堆内存溢出。</p><p>1）因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，单方面的加大了堆内存从 4G 调整到 8G -Xms8g。</p><p>2）但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError 参数 获得堆内存的 dump 文件。</p><p>3）用 JProfiler 对 堆 dump 文件进行分析，通过 JProfiler 查看到占用内存最大的对象是 String 对象，本来想跟踪着 String 对象找到其引用的地方，但 dump 文件太大，跟踪进去的时候总是卡死，而 String 对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p><p>4）通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，有个方法引起了我的注意，<code>导出订单信息</code>。</p><p>5）因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成 excel，这个过程会产生大量的 String 对象。</p><p>6）为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现导出订单的按钮前端居然没有做点击后按钮置灰交互事件，后端也没有做防止重复提交，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，然后就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和 EXCEL 对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p><p>7）知道了问题就容易解决了，最终没有调整任何 JVM 参数，只是做了两个处理：</p><ul><li>在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击</li><li>后端代码加分布式锁，做防重处理</li></ul><p>这样双管齐下，保证导出的请求不会一直打到服务端，问题解决！</p><h3 id="36-线上服务-CPU-占用过高怎么排查？">36.线上服务 CPU 占用过高怎么排查？</h3><p>问题分析：CPU 高一定是某个程序长期占用了 CPU 资源。</p><p><img src="https://s2.loli.net/2023/03/31/AoRhv7QzCB3gK9b.png" alt="CPU飙高"></p><p>1）所以先需要找出那个进程占用 CPU 高。</p><ul><li>top 列出系统各个进程的资源占用情况。</li></ul><p>2）然后根据找到对应进行里哪个线程占用 CPU 高。</p><ul><li>top -Hp 进程 ID 列出对应进程里面的线程占用资源情况</li></ul><p>3）找到对应线程 ID 后，再打印出对应线程的堆栈信息</p><ul><li>printf “%x\n” PID 把线程 ID 转换为 16 进制。</li><li>jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为 16 进制的线程 ID 对应的线程信息。</li></ul><p>4）最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p><p>查看是否有线程长时间的 watting 或 blocked，如果线程长期处于 watting 状态下， 关注 watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</p><h3 id="37-内存飙高问题怎么排查？">37.内存飙高问题怎么排查？</h3><p>分析： 内存飚高如果是发生在 java 进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p><p>1）先观察垃圾回收的情况</p><ul><li>jstat -gc PID 1000 查看 GC 次数，时间等信息，每隔一秒打印一次。</li><li>jmap -histo PID | head -20 查看堆内存占用空间最大的前 20 个对象类型,可初步查看是哪个对象占用了内存。</li></ul><p>如果每次 GC 次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p><p>2）导出堆内存文件快照</p><ul><li>jmap -dump:live,format=b,file=/home/myheapdump.hprof PID dump 堆内存信息到文件。</li></ul><p>3）使用 visualVM 对 dump 文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p><h3 id="38-频繁-minor-gc-怎么办？">38.频繁 minor gc 怎么办？</h3><p>优化 Minor GC 频繁问题：通常情况下，由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此可以通过增大新生代空间<code>-Xmn</code>来降低 Minor GC 的频率。</p><h3 id="39-频繁-Full-GC-怎么办？">39.频繁 Full GC 怎么办？</h3><p>Full GC 的排查思路大概如下：</p><p>1）清楚从程序角度，有哪些原因导致 FGC？</p><ul><li><strong>大对象</strong>：系统一次性加载了过多数据到内存中（比如 SQL 查询未做分页），导致大对象进入了老年代。</li><li><strong>内存泄漏</strong>：频繁创建了大量对象，但是无法被回收（比如 IO 对象使用完后未调用 close 方法释放资源），先引发 FGC，最后导致 OOM.</li><li>程序频繁生成一些<strong>长生命周期的对象</strong>，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发 FGC. （即本文中的案例）</li><li><strong>程序 BUG</strong></li><li>代码中<strong>显式调用了 gc</strong>方法，包括自己的代码甚至框架中的代码。</li><li>JVM 参数设置问题：包括总内存大小、新生代和老年代的大小、Eden 区和 S 区的大小、元空间大小、垃圾回收算法等等。</li></ul><p>2）清楚排查问题时能使用哪些工具</p><ul><li>公司的监控系统：大部分公司都会有，可全方位监控 JVM 的各项指标。</li><li>JDK 的自带工具，包括 jmap、jstat 等常用命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看堆内存各区域的使用率以及GC情况</span></span><br><span class="line">jstat -gcutil -h20 pid 1000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看堆内存中的存活对象，并按空间排序</span></span><br><span class="line">jmap -histo pid | head -n20</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dump堆内存文件</span></span><br><span class="line">jmap -dump:format=b,file=heap pid</span><br></pre></td></tr></table></figure><ul><li>可视化的堆内存分析工具：JVisualVM、MAT 等</li></ul><p>3）排查指南</p><ul><li>查看监控，以了解出现问题的时间点以及当前 FGC 的频率（可对比正常情况看频率是否正常）</li><li>了解该时间点之前有没有程序上线、基础组件升级等情况。</li><li>了解 JVM 的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析 JVM 参数设置是否合理。</li><li>再对步骤 1 中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用 gc 方法比较容易排查。</li><li>针对大对象或者长生命周期对象导致的 FGC，可通过 jmap -histo 命令并结合 dump 堆内存文件作进一步分析，需要先定位到可疑对象。</li><li>通过可疑对象定位到具体代码再次分析，这时候要结合 GC 原理和 JVM 参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。</li></ul><h3 id="40-有没有处理过内存泄漏问题？是如何定位的？">40.有没有处理过内存泄漏问题？是如何定位的？</h3><p>内存泄漏是内在病源，外在病症表现可能有：</p><ul><li>应用程序长时间连续运行时性能严重下降</li><li>CPU 使用率飙升，甚至到 100%</li><li>频繁 Full GC，各种报警，例如接口超时报警等</li><li>应用程序抛出 <code>OutOfMemoryError</code> 错误</li><li>应用程序偶尔会耗尽连接对象</li></ul><p>严重<strong>内存泄漏</strong>往往伴随频繁的 <strong>Full GC</strong>，所以分析排查内存泄漏问题首先还得从查看 Full GC 入手。主要有以下操作步骤：</p><p>1）使用 <code>jps</code> 查看运行的 Java 进程 ID</p><p>2）使用<code>top -p [pid]</code> 查看进程使用 CPU 和 MEM 的情况</p><p>3）使用 <code>top -Hp [pid]</code> 查看进程下的所有线程占 CPU 和 MEM 的情况</p><p>4）将线程 ID 转换为 16 进制：<code>printf &quot;%x\n&quot; [pid]</code>，输出的值就是线程栈信息中的 <strong>nid</strong>。</p><p>例如：<code>printf &quot;%x\n&quot; 29471</code>，换行输出 <strong>731f</strong>。</p><p>5）抓取线程栈：<code>jstack 29452 &gt; 29452.txt</code>，可以多抓几次做个对比。</p><p>在线程栈信息中找到对应线程号的 16 进制值，如下是 <strong>731f</strong> 线程的信息。线程栈分析可使用 Visualvm 插件 <strong>TDA</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Service Thread&quot;</span> #<span class="number">7</span> daemon prio=<span class="number">9</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007fbe2c164000</span> nid=<span class="number">0x731f</span> runnable [<span class="number">0x0000000000000000</span>]</span><br><span class="line">  java.lang.Thread.State: RUNNABLE</span><br></pre></td></tr></table></figure><p>6）使用<code>jstat -gcutil [pid] 5000 10</code> 每隔 5 秒输出 GC 信息，输出 10 次，查看 <strong>YGC</strong> 和 <strong>Full GC</strong> 次数。通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。</p><p>或使用 <code>jstat -gccause [pid] 5000</code> ，同样是输出 GC 摘要信息。</p><p>或使用 <code>jmap -heap [pid]</code> 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。</p><p>7）如果发现 <code>Full GC</code> 次数太多，就很大概率存在内存泄漏了</p><p>8）使用 <code>jmap -histo:live [pid]</code> 输出每个类的对象数量，内存大小(字节单位)及全限定类名。</p><p>9）生成 <code>dump</code> 文件，借助工具分析哪 个对象非常多，基本就能定位到问题在那了</p><p>使用 jmap 生成 dump 文件：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># jmap -dump:live,format=b,file=<span class="number">29471.</span>dump <span class="number">29471</span></span><br><span class="line">Dumping heap to /root/dump ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure><p>10）dump 文件分析</p><p>可以使用 <strong>jhat</strong> 命令分析：<code>jhat -port 8000 29471.dump</code>，浏览器访问 jhat 服务，端口是 8000。</p><p>通常使用图形化工具分析，如 JDK 自带的 <strong>jvisualvm</strong>，从菜单 &gt; 文件 &gt; 装入 dump 文件。</p><p>或使用第三方式具分析的，如 <strong>JProfiler</strong> 也是个图形化工具，<strong>GCViewer</strong> 工具。Eclipse 或以使用 MAT 工具查看。或使用在线分析平台 <strong>GCEasy</strong>。</p><p><strong>注意</strong>：如果 dump 文件较大的话，分析会占比较大的内存。</p><p>11）在 dump 文析结果中查找存在大量的对象，再查对其的引用。</p><p>基本上就可以定位到代码层的逻辑了。</p><h3 id="41-有没有处理过内存溢出问题？">41.有没有处理过内存溢出问题？</h3><p>内存泄漏和内存溢出二者关系非常密切，内存溢出可能会有很多原因导致，内存泄漏最可能的罪魁祸首之一。</p><p>排查过程和排查内存泄漏过程类似。</p><h2 id="四、虚拟机执行">四、虚拟机执行</h2><h3 id="42-能说一下类的生命周期吗？">42.能说一下类的生命周期吗？</h3><p>一个类从被加载到虚拟机内存中开始，到从内存中卸载，整个生命周期需要经过七个阶段：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading），其中验证、准备、解析三个部分统称为连接（Linking）。</p><p><img src="https://s2.loli.net/2023/03/31/5PuHf6axlqts93h.png" alt="类的生命周期"></p><h3 id="43-类加载的过程知道吗？">43.类加载的过程知道吗？</h3><p>加载是 JVM 加载的起点，具体什么时候开始加载，《Java 虚拟机规范》中并没有进行强制约束，可以交给虚拟机的具体实现来自由把握。</p><p>在加载过程，JVM 要做三件事情：</p><p><img src="https://s2.loli.net/2023/03/31/Xtqx2gZePvpSBd4.png" alt="加载"></p><ul><li><p>1）通过一个类的全限定名来获取定义此类的二进制字节流。</p></li><li><p>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>3）在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</p></li></ul><p>加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java 虚拟机规范》未规定此区域的具体数据结构。</p><p>类型数据妥善安置在方法区之后，会在 Java 堆内存中实例化一个 java.lang.Class 类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。</p><h3 id="44-类加载器有哪些？">44.类加载器有哪些？</h3><p>主要有四种类加载器:</p><ul><li><p><strong>启动类加载器</strong>(Bootstrap ClassLoader)用来加载 java 核心类库，无法被 java 程序直接引用。</p></li><li><p><strong>扩展类加载器</strong>(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。</p></li><li><p><strong>系统类加载器</strong>（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p></li><li><p><strong>用户自定义类加载器</strong> (user class loader)，用户通过继承 java.lang.ClassLoader 类的方式自行实现的类加载器。</p></li></ul><h3 id="45-什么是双亲委派机制？">45.什么是双亲委派机制？</h3><p><img src="https://s2.loli.net/2023/03/31/l9OduginjcZCqfY.png" alt="双亲委派模型"></p><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p><h3 id="46-为什么要用双亲委派机制？">46.为什么要用双亲委派机制？</h3><p>答案是为了保证应用程序的稳定有序。</p><p>例如类 java.lang.Object，它存放在 rt.jar 之中，通过双亲委派机制，保证最终都是委派给处于模型最顶端的启动类加载器进行加载，保证 Object 的一致。反之，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类。</p><h3 id="47-如何破坏双亲委派机制？">47.如何破坏双亲委派机制？</h3><p>如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass()方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。而如果想打破双亲委派模型则需要重写 loadClass()方法。</p><h3 id="48-历史上有哪几次双亲委派机制的破坏？">48.历史上有哪几次双亲委派机制的破坏？</h3><p>双亲委派机制在历史上主要有三次破坏：</p><p><img src="https://s2.loli.net/2023/03/31/Ur7cwxMdbqlCihv.png" alt="双亲委派模型的三次破坏"></p><blockquote><p><strong>第一次破坏</strong></p></blockquote><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即 JDK 1.2 面世以前的“远古”时代。</p><p>由于双亲委派模型在 JDK 1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.ClassLoader 则在 Java 的第一个版本中就已经存在，为了向下兼容旧代码，所以无法以技术手段避免 loadClass()被子类覆盖的可能性，只能在 JDK 1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass()中编写代码。</p><blockquote><p><strong>第二次破坏</strong></p></blockquote><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，如果有基础类型又要调用回用户的代码，那该怎么办呢？</p><p>例如我们比较熟悉的 JDBC:</p><p>各个厂商各有不同的 JDBC 的实现，Java 在核心包<code>\lib</code>里定义了对应的 SPI，那么这个就毫无疑问由<code>启动类加载器</code>加载器加载。</p><p>但是各个厂商的实现，是没办法放在核心包里的，只能放在<code>classpath</code>里，只能被<code>应用类加载器</code>加载。那么，问题来了，启动类加载器它就加载不到厂商提供的 SPI 服务代码。</p><p>为了解决这个问题，引入了一个不太优雅的设计：线程上下文类加载器 （Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为。</p><blockquote><p><strong>第三次破坏</strong></p></blockquote><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，例如代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。</p><p>OSGi 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><h3 id="49-你觉得应该怎么实现一个热部署功能？">49.你觉得应该怎么实现一个热部署功能？</h3><p>我们已经知道了 Java 类的加载过程。一个 Java 类文件到虚拟机里的对象，要经过如下过程:首先通过 Java 编译器，将 Java 文件编译成 class 字节码，类加载器读取 class 字节码，再将类转化为实例，对实例 newInstance 就可以生成对象。</p><p>类加载器 ClassLoader 功能，也就是将 class 字节码转换到类的实例。在 Java 应用中，所有的实例都是由类加载器，加载而来。</p><p>一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的 java 类（如 com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。</p><p>这个时候问题就来了，如果我们希望将 java 类卸载，并且替换更新版本的 java 类，该怎么做呢？</p><p>既然在类加载器中，Java 类只能被加载一次，并且无法卸载。那么我们是不是可以直接把 Java 类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写 ClassLoader 的 findClass 方法。</p><p>想要实现热部署可以分以下三个步骤：</p><ul><li>1）销毁原来的自定义 ClassLoader</li><li>2）更新 class 类文件</li><li>3）创建新的 ClassLoader 去加载更新后的 class 类文件。</li></ul><p>到此，一个热部署的功能就这样实现了。</p><h3 id="50-Tomcat-的类加载机制了解吗？">50.Tomcat 的类加载机制了解吗？</h3><p>Tomcat 是主流的 Java Web 服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。</p><p>Tomcat 类加载器如下：</p><p><img src="https://s2.loli.net/2023/03/31/8kRIwj4dD7yun1f.png" alt="Tomcat类加载器"></p><p>Tomcat 实际上也是破坏了双亲委派模型的。</p><p>Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖 hollis.jar，但是 A 应用需要依赖 1.0.0 版本，但是 B 应用需要依赖 1.0.1 版本。这两个版本中都有一个类是 com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。</p><p>所以，Tomcat 破坏了<strong>双亲委派原则</strong>，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。</p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> JVM篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程(修正版)</title>
      <link href="/posts/d18c1c50.html"/>
      <url>/posts/d18c1c50.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><h3 id="1-并行跟并发有什么区别？">1.并行跟并发有什么区别？</h3><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p><ul><li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li><li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</li></ul><p><img src="https://s2.loli.net/2023/03/29/zaxOh4yAoJLGiEv.png" alt="并行和并发"></p><p>就好像我们去食堂打饭，并行就是我们在多个窗口排队，几个阿姨同时打菜；并发就是我们挤在一个窗口，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p><p><img src="https://s2.loli.net/2023/03/29/GjVgmpEaSiIYfT5.png" alt="并行并发和食堂打饭"></p><h3 id="2-说说什么是进程和线程？">2.说说什么是进程和线程？</h3><p>要说线程，必须得先说说进程。</p><ul><li>进程：进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</li><li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li></ul><p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p><p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p><p><img src="https://s2.loli.net/2023/03/29/QpLioCzM5Ia8RdO.png" alt="程序进程线程关系"></p><p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p><h3 id="3-说说线程有几种创建方式？">3.说说线程有几种创建方式？</h3><p>Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。</p><p><img src="https://s2.loli.net/2023/03/29/a2UIgQjkiWAoYS1.png" alt="线程创建三种方式"></p><ul><li>继承Thread类，重写run()方法，调用start()方法启动线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承Thread类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is child thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>实现 Runnable 接口，重写run()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Runnable!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTask</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p><ul><li>实现Callable接口，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallerTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,i am running!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        FutureTask&lt;String&gt; task=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">CallerTask</span>());</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待执行完成，并获取返回结果</span></span><br><span class="line">            String result=task.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？">4.为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h3><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p><p><img src="https://s2.loli.net/2023/03/29/7AjEIcvDkZBMKOe.png" alt="start方法"></p><p><strong>为什么我们不能直接调用run()方法</strong>也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p><h3 id="5-线程有哪些常用的调度方法？">5.线程有哪些常用的调度方法？</h3><p><img src="https://s2.loli.net/2023/03/29/rVsnIKeRu2Gp5yW.png" alt="线程常用调度方法"></p><p><strong>线程等待与通知</strong></p><p>在Object类中有一些函数可以用于线程的等待与通知。</p><ul><li><p>wait()：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：</p><ul><li><p>（1） 线程A调用了共享对象 notify()或者 notifyAll()方法；</p></li><li><p>（2）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</p></li></ul></li><li><p>wait(long timeout) ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</p></li><li><p>wait(long timeout, int nanos)，其内部调用的是 wait(long timout）函数。</p></li></ul><p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p><ul><li>notify() : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用 wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li><li>notifyAll() ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li></ul><p>Thread类也提供了一个方法用于等待的方法：</p><ul><li>join()：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</li></ul><p><strong>线程休眠</strong></p><ul><li>sleep(long millis)  :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</li></ul><p><strong>让出优先权</strong></p><ul><li>yield() ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</li></ul><p><strong>线程中断</strong></p><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><ul><li>void interrupt() ：中断线程，例如，当线程A运行时，线程B可以调用线程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</li><li>boolean isInterrupted() 方法： 检测当前线程是否被中断。</li><li>boolean interrupted() 方法： 检测当前线程是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li></ul><h3 id="6-线程有几种状态？">6.线程有几种状态？</h3><p>在Java中，线程共有六种状态：</p><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态：线程被创建，但还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”</td></tr><tr><td>BLOCKED</td><td>阻塞状态：表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的</td></tr><tr><td>TERMINATED</td><td>终止状态：表示当前线程已经执行完毕</td></tr></tbody></table><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="https://s2.loli.net/2023/03/29/AMO9smxIwYHCT6G.png" alt="Java线程状态变化"></p><h3 id="7-什么是线程上下文切换？">7.什么是线程上下文切换？</h3><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。</p><p><img src="https://s2.loli.net/2023/03/29/xscP4YqFtuJdm8O.png" alt="线程切换-2020-12-16-2107"></p><p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p><p><img src="https://s2.loli.net/2023/03/29/rs3I7XvyzQ8t5bW.png" alt="上下文切换时机"></p><h3 id="8-守护线程了解吗？">8.守护线程了解吗？</h3><p>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</p><p>在JVM 启动时会调用 main 函数，main函数所在的线程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</p><p>那么守护线程和用户线程有什么区别呢？不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。只要有一个用户线程还没结束，正常情况下JVM就不会退出。</p><h3 id="9-线程间有哪些通信方式？">9.线程间有哪些通信方式？</h3><p><img src="https://s2.loli.net/2023/03/29/NBjTPxVZHb62hYu.png" alt="线程间通信方式"></p><ul><li><p><strong>volatile和synchronized关键字</strong></p><p>关键字<code>volatile</code>可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p><p>关键字<code>synchronized</code>可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p></li><li><p><strong>等待/通知机制</strong></p><p>可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</p></li><li><p><strong>管道输入/输出流</strong></p><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p><p>管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、 PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p></li><li><p><strong>使用Thread.join()</strong></p><p>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)两个具备超时特性的方法。</p></li><li><p><strong>使用ThreadLocal</strong></p><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p></li></ul><h2 id="ThreadLocal">ThreadLocal</h2><div class="note info flat"><p>ThreadLocal其实应用场景不是很多，但却是被炸了千百遍的面试老油条，涉及到多线程、数据结构、JVM，可问的点比较多，一定要拿下。</p></div><h3 id="10-ThreadLocal是什么？">10.ThreadLocal是什么？</h3><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><p><img src="https://s2.loli.net/2023/03/29/Evy6d2iAnubf3ah.png" alt="ThreadLocal线程副本"></p><ul><li><p>创建</p><p>创建了一个ThreadLoca变量localVariable，任何一个线程都能并发访问localVariable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ThreadLocal变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p>写入</p><p>线程可以在任何地方使用localVariable，写入变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.set(<span class="string">&quot;鄙人三某”);</span></span><br></pre></td></tr></table></figure></li><li><p>读取</p><p>线程在任何地方读取的都是它写入的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localVariable.get();</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-你在工作中用到过ThreadLocal吗？">11.你在工作中用到过ThreadLocal吗？</h3><p>有用到过的，用来做用户信息上下文的存储。</p><p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接口，都会在请求头中携带一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p><p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p><p>这时候我们就可以用到 ThreadLocal，在控制层拦截请求把用户信息存入 ThreadLocal ，这样我们在任何一个地方，都可以取出 ThreadLocal 中存的用户数据。</p><p><img src="https://s2.loli.net/2023/03/29/muARcVQPCD1azq7.png" alt="ThreadLoca存放用户上下文"></p><p>很多其它场景的 cookie、session 等等数据隔离也都可以通过 ThreadLocal 去实现。</p><p>我们常用的数据库连接池也用到了 ThreadLocal ：</p><ul><li>数据库连接池的连接交给 ThreadLocal 进行管理，保证当前线程的操作都是同一个 Connnection。</li></ul><h3 id="12-ThreadLocal怎么实现的呢？">12.ThreadLocal怎么实现的呢？</h3><p>我们看一下 ThreadLocal 的 set(T) 方法，发现先获取到当前线程，再获取<code>ThreadLocalMap</code>，然后把元素存到这个 map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//讲当前元素存入map</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal实现的秘密都在这个<code>ThreadLocalMap</code>了，Thread类中定义了一个类型为<code>ThreadLocal.ThreadLocalMap</code>的成员变量<code>threadLocals</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span></span><br><span class="line">   ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点类</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="comment">//key赋值</span></span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        <span class="comment">//value赋值</span></span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个<strong>弱引用</strong>，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">WeakReference</span><span class="params">(T referent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(referent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key的赋值，使用的是WeakReference的赋值。</p><p><img src="https://s2.loli.net/2023/03/29/nrzOlTQN9KfksqU.png" alt="ThreadLoca结构图"></p><blockquote><p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p></blockquote><ul><li>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，每个线程都有一个属于自己的ThreadLocalMap。</li><li>ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal的弱引用，value是ThreadLocal的泛型值。</li><li>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li><li>ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap里存取值。</li></ul><h3 id="13-ThreadLocal-内存泄露是怎么回事？">13.ThreadLocal 内存泄露是怎么回事？</h3><p>我们先来分析一下使用ThreadLocal时的内存，我们都知道，在JVM中，栈内存线程私有，存储了对象的引用，堆内存线程共享，存储了对象实例。</p><p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p><p><img src="https://s2.loli.net/2023/03/29/ftvRPVcUs3xhlbr.png" alt="ThreadLocal内存分配"></p><p>ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用。</p><blockquote><p>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</p></blockquote><p>那么现在问题就来了，弱引用很容易被回收，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会<strong>造成了内存泄漏问题</strong>。</p><blockquote><p>那怎么解决内存泄漏问题呢？</p></blockquote><p>很简单，使用完ThreadLocal后，及时调用remove()方法释放内存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    localVariable.set(<span class="string">&quot;鄙人三某”);</span></span><br><span class="line"><span class="string">    ……</span></span><br><span class="line"><span class="string">&#125; finally &#123;</span></span><br><span class="line"><span class="string">    localVariable.remove();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>那为什么key还要设计成弱引用？</p></blockquote><p>key设计成弱引用同样是为了防止内存泄漏。</p><p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLocal的强引用就没有了，但是此时key还强引用指向ThreadLocal，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p><h3 id="14-ThreadLocalMap的结构了解吗？">14.ThreadLocalMap的结构了解吗？</h3><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接口的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<code>元素数组</code>和<code>散列方法</code>。</p><p><img src="https://s2.loli.net/2023/03/29/kzqS9jdJFCArTna.png" alt="ThreadLocalMap结构示意图"></p><ul><li><p>元素数组</p><p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure></li><li><p>散列方法</p><p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的threadLocalHashCode计算有点东西，每创建一个ThreadLocal对象，它就会新增<code>0x61c88647</code>，这个值很特殊，它是<strong>斐波那契数</strong>  也叫 <strong>黄金分割数</strong>。<code>hash</code>增量为 这个数字，带来的好处就是 <code>hash</code> <strong>分布非常均匀</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="15-ThreadLocalMap怎么解决Hash冲突的？">15.ThreadLocalMap怎么解决Hash冲突的？</h3><p>我们可能都知道HashMap使用了链表来解决冲突，也就是所谓的链地址法。</p><p>ThreadLocalMap没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式——<strong>开放定址法</strong>。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p><p><img src="https://s2.loli.net/2023/03/29/WgK9hZprnRINxiw.png" alt="ThreadLocalMap解决冲突"></p><p>如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p><p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p><h3 id="16-ThreadLocalMap扩容机制了解吗？">16.ThreadLocalMap扩容机制了解吗？</h3><p>在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了列表的扩容阈值<code>(len*2/3)</code>，就开始执行<code>rehash()</code>逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure><p>再着看rehash()具体实现：这里会先去清理过期的Entry，然后还要根据条件判断<code>size &gt;= threshold - threshold / 4</code> 也就是<code>size &gt;= threshold* 3/4</code>来决定是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//清理过期Entry</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理过期Entry</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着看看具体的<code>resize()</code>方法，扩容后的<code>newTab</code>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的<code>newTab</code>，遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到<code>newTab</code>中了，然后table引用指向<code>newTab</code></p><p><img src="https://s2.loli.net/2023/03/29/EDjibTMl2cRsCyh.png" alt="ThreadLocalMap扩容"></p><p>具体代码：</p><p><img src="https://s2.loli.net/2023/03/29/bJsV9dkAut54zfE.png" alt="ThreadLocalMap resize"></p><h3 id="17-父子线程怎么共享数据？">17.父子线程怎么共享数据？</h3><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p><p>这时候可以用到另外一个类——<code>InheritableThreadLocal </code>。</p><p>使用起来很简单，在主线程的InheritableThreadLocal实例设置值，在子线程中就可以拿到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        threadLocal.set(<span class="string">&quot;不擅技术&quot;</span>);</span><br><span class="line">        <span class="comment">//子线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">                System.out.println(<span class="string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那原理是什么呢？</p></blockquote><p>原理很简单，在Thread类里还有另外一个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>在Thread.init的时候，如果父线程的<code>inheritableThreadLocals</code>不为空，就把它赋给当前线程（子线程）的<code>inheritableThreadLocals </code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure><h2 id="Java内存模型">Java内存模型</h2><h3 id="18-说一下你对Java内存模型（JMM）的理解？">18.说一下你对Java内存模型（JMM）的理解？</h3><p>Java内存模型（Java Memory Model，JMM），是一种抽象的模型，被定义出来屏蔽各种硬件和操作系统的内存访问差异。</p><p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在<code>主内存</code>（Main Memory）中，每个线程都有一个私有的<code>本地内存</code>（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。</p><p>Java内存模型的抽象图：</p><p><img src="https://s2.loli.net/2023/03/29/PmDaMH7Gfiopv9X.png" alt="Java内存模型"></p><p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="https://s2.loli.net/2023/03/29/LKczwTgCoUdakW1.png" alt="实际线程工作模型"></p><p>图里面的是一个双核 CPU 系统架构 ，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 共享的二级缓存。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p><h3 id="19-说说你对原子性、可见性、有序性的理解？">19.说说你对原子性、可见性、有序性的理解？</h3><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p><ul><li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</li><li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</li><li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</li></ul><blockquote><p>分析下面几行代码的原子性？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">i++;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>第1句是基本类型赋值，是原子性操作。</li><li>第2句先读i的值，再赋值到j，两步操作，不能保证原子性。</li><li>第3和第4句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</li></ul><blockquote><p>原子性、可见性、有序性都应该怎么保证呢？</p></blockquote><ul><li>原子性：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<code>synchronized </code>。</li><li>可见性：Java是利用<code>volatile</code>关键字来保证可见性的，除此之外，<code>final</code>和<code>synchronized</code>也能保证可见性。</li><li>有序性：<code>synchronized</code>或者<code>volatile</code>都可以保证多线程之间操作的有序性。</li></ul><h3 id="20-那说说什么是指令重排？">20.那说说什么是指令重排？</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。</p><ol><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ol><p>从Java源代码到最终实际执行的指令序列，会分别经历下面3种重排序，如图：</p><p><img src="https://s2.loli.net/2023/03/29/RtSraOzCbuyx2hG.png" alt="多级指令重排"></p><p>我们比较熟悉的双重校验单例模式就是一个经典的指令重排的例子，<code>Singleton instance=new Singleton()；</code>对应的JVM指令分为三步：分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p><p><img src="https://s2.loli.net/2023/03/29/dyIhKpXaukV3Zw4.png" alt="双重校验单例模式异常情形"></p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h3 id="21-指令重排有限制吗？happens-before了解吗？">21.指令重排有限制吗？happens-before了解吗？</h3><p>指令重排也是有一些限制的，有两个规则<code>happens-before</code>和<code>as-if-serial</code>来约束。</p><p>happens-before的定义：</p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法</li></ul><p>happens-before和我们息息相关的有六大规则：</p><ul><li><strong>程序顺序规则</strong>（Program Order Rule）：在一个线程内，按照程序代码顺序，前面的操作 happens-before 于后续的所有操作。</li><li><strong>volatile 变量规则</strong>（Volatile Variable Rule）：对于一个 volatile 域的写操作 happens-before 于这个域的后续读操作。</li><li><strong>传递性规则</strong>（Transitive Rule）：如果 A happens-before B，B happens-before C，则 A happens-before C。</li><li><strong>锁定规则</strong>（Synchronization Rule）：一个 unlock 操作 happens-before 于后续的 lock 操作。也就是说，如果一个线程释放锁，那么后续获得这个锁的线程将能够看到之前线程的所有操作。</li><li><strong>线程启动规则</strong>（Thread Start Rule）：一个线程的开始操作 happens-before 于该线程启动后的任意操作。</li><li><strong>线程join规则</strong>（Thread Join Rule）：主线程A等待子线程B完成，当子线程B执行完毕后，主线程A可以看到线程B的所有操作。也就是说，子线程B中的任意操作，happens-before join()的返回。</li></ul><h3 id="22-as-if-serial又是什么？单线程的程序一定是顺序的吗？">22. as-if-serial又是什么？单线程的程序一定是顺序的吗？</h3><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），<strong>单线程程序的执行结果不能被改变</strong>。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;   <span class="comment">// A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1.0</span>;   <span class="comment">// B </span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>上面3个操作的数据依赖关系：</p><p><img src="https://s2.loli.net/2023/04/05/cR31XIZvog2YSUl.png" alt="javathread-24.png"></p><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><p>所以最终，程序可能会有两种执行顺序：</p><p><img src="https://s2.loli.net/2023/03/29/YaxTMAbvpIOhLms.png" alt="两种执行结果"></p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p><h3 id="23-volatile实现原理了解吗？">23.volatile实现原理了解吗？</h3><p><code>volatile</code> 有两个作用，保证<strong>可见性</strong>和<strong>有序性</strong>。</p><blockquote><p>volatile怎么保证可见性的呢？</p></blockquote><p>相比 <code>synchronized</code> 的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p><p><code>volatile</code> 可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为 <code>volatile</code> 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><p>例如，我们声明一个 <code>volatile</code> 变量 <code>volatile int x = 0</code>，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p><p><img src="https://s2.loli.net/2023/03/29/JQro2tkvCIcMRZu.png" alt="volatile内存可见性"></p><blockquote><p>volatile怎么保证有序性的呢？</p></blockquote><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><p><img src="https://s2.loli.net/2023/03/29/rkY7usEinlLwbjP.png" alt="volatile重排序规则表"></p><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ol><li>在每个volatile写操作的前面插入一个<code>StoreStore</code>屏障</li><li>在每个volatile写操作的后面插入一个<code>StoreLoad</code>屏障</li><li>在每个volatile读操作的后面插入一个<code>LoadLoad</code>屏障</li><li>在每个volatile读操作的后面插入一个<code>LoadStore</code>屏障</li></ol><p><img src="https://s2.loli.net/2023/03/29/IZHNsv53oLcPUuO.png" alt="volatile写插入内存屏障后生成的指令序列示意图"></p><p><img src="https://s2.loli.net/2023/03/29/kPih1mqHL7g2CAB.png" alt="volatile写插入内存屏障后生成的指令序列示意图"></p><h2 id="锁">锁</h2><h3 id="24-synchronized用过吗？怎么使用？">24.synchronized用过吗？怎么使用？</h3><p>synchronized经常用的，用来保证代码的原子性。</p><p>synchronized主要有三种用法：</p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>修饰静态方法</strong>：也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 class 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ static 表明这是该类的⼀个静态资源，不管 new 了多少个对象，只有⼀份）。</p><p>如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 synchronized ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 synchronized ⽅法占⽤的锁是当前实例对象锁。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。 synchronized(类.class) 表示进⼊同步代码前要获得 当前 <strong>class</strong> 的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"> <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-synchronized的实现原理？">25.synchronized的实现原理？</h3><blockquote><p>synchronized是怎么加锁的呢？</p></blockquote><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p><ol><li><p>synchronized修饰代码块时，JVM采用<code>monitorenter</code>、<code>monitorexit</code>两个指令来实现同步，<code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指向同步代码块的结束位置。</p><p>反编译一段synchronized修饰代码块代码，<code>javap -c -s -v -l SynchronizedDemo.class</code>，可以看到相应的字节码指令。</p></li></ol><p><img src="https://s2.loli.net/2023/03/29/h5wzDTCsGRSqgJX.png" alt="monitorenter和monitorexit"></p><ol start="2"><li>synchronized修饰同步方法时，JVM采用<code>ACC_SYNCHRONIZED</code>标记符来实现同步，这个标识指明了该方法是一个同步方法。</li></ol><p>同样可以写段代码反编译看一下。</p><p><img src="https://s2.loli.net/2023/03/29/TCFQNpkKcZb6GHL.png" alt="synchronized修饰同步方法"></p><blockquote><p>synchronized锁住的是什么呢？</p></blockquote><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是<strong>基于Monitor实现</strong>的。</p><p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong>。</p><p>所谓的Monitor其实是一种<strong>同步工具</strong>，也可以说是一种<strong>同步机制</strong>。在Java虚拟机（HotSpot）中，Monitor是由<strong>ObjectMonitor实现</strong>的，可以叫做内部锁，或者Monitor锁。</p><p>ObjectMonitor的工作原理：</p><ul><li>ObjectMonitor有两个队列：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。</li><li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait() 方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入 _WaitSet 中，等待被唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 记录线程获取锁的次数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//锁的重入次数</span></span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;  <span class="comment">// 指向持有ObjectMonitor对象的线程</span></span><br><span class="line">    _WaitSet      = NULL;  <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ;  <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以类比一个去医院就诊的例子[18]：</p><ul><li><p>首先，患者在<strong>门诊大厅</strong>前台或自助挂号机<strong>进行挂号</strong>；</p></li><li><p>随后，挂号结束后患者找到对应的<strong>诊室就诊</strong>：</p><ul><li>诊室每次只能有一个患者就诊；</li><li>如果此时诊室空闲，直接进入就诊；</li><li>如果此时诊室内有其它患者就诊，那么当前患者进入<strong>候诊室</strong>，等待叫号；</li></ul></li><li><p>就诊结束后，<strong>走出就诊室</strong>，候诊室的<strong>下一位候诊患者</strong>进入就诊室。</p></li></ul><p><img src="https://s2.loli.net/2023/03/29/jXEPJwipd6GcQ58.png" alt="就诊-图片来源参考[18]"></p><p>这个过程就和Monitor机制比较相似：</p><ul><li><strong>门诊大厅</strong>：所有待进入的线程都必须先在<strong>入口</strong>（Entry Set）挂号才有资格；</li><li><strong>就诊室</strong>：就诊室_<strong>Owner</strong>里里只能有一个线程就诊，就诊完线程就自行离开</li><li><strong>候诊室</strong>：就诊室繁忙时，进入<strong>等待区</strong>（Wait Set），就诊室空闲的时候就从<strong>等待区</strong>（Wait Set）叫新的线程</li></ul><p><img src="https://s2.loli.net/2023/03/29/OfomjvCJWqxHsB8.png" alt="Java Montior机制"></p><p>所以我们就知道了，同步是锁住的什么东西：</p><ul><li>monitorenter，在判断拥有同步标识 ACC_SYNCHRONIZED 抢先进入此方法的线程会优先拥有 Monitor 的 owner ，此时计数器 +1。</li><li>monitorexit，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li></ul><h3 id="26-除了原子性，synchronized可见性，有序性，可重入性怎么实现？">26.除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h3><blockquote><p>synchronized怎么保证可见性？</p></blockquote><ul><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>线程加锁后，其它线程无法获取主内存中的共享变量。</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li></ul><blockquote><p>synchronized怎么保证有序性？</p></blockquote><p>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</p><p>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</p><p>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</p><blockquote><p>synchronized怎么实现可重入的呢？</p></blockquote><p>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</p><p>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了，所以是可重入的。</p><h3 id="27-锁升级？synchronized优化了解吗？">27.锁升级？synchronized优化了解吗？</h3><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p><p>Java对象头里，有一块结构，叫<code>Mark Word</code>标记字段，这块结构会随着锁的状态变化而变化。</p><p>64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p><p><img src="https://s2.loli.net/2023/03/29/gzYN679KTw1pQD8.png" alt="Mark Word变化"></p><p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p><blockquote><p>synchronized做了哪些优化？</p></blockquote><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong>。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p><ul><li><p>偏向锁：在无竞争的情况下，只是在Mark Word里存储当前线程指针。</p></li><li><p>轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</p></li><li><p>自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</p></li><li><p>锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</p></li><li><p>锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p></li></ul><blockquote><p>锁升级的过程是什么样的？</p></blockquote><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁----&gt;重量级锁，这个方向基本上是不可逆的。</p><p><img src="https://s2.loli.net/2023/03/29/rhFiWbzIMYK9S3H.png" alt="锁升级方向"></p><p>我们看一下升级的过程：</p><h4 id="偏向锁：">偏向锁：</h4><p><strong>偏向锁的获取：</strong></p><ol><li>判断是否为可偏向状态–MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’</li><li>如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤’5’，否则进入步骤‘3’</li><li>通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’</li><li>CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，<strong>偏向锁升级为轻量级锁</strong>，然后被阻塞在安全点的线程继续往下执行同步代码块</li><li>执行同步代码</li></ol><p><strong>偏向锁的撤销：</strong></p><ol><li>偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到safepoint时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；</li><li>撤销----T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态----该状态达到阈值20则执行批量重偏向</li><li>升级----T线程还在同步代码块中，则将T线程的偏向锁<strong>升级为轻量级锁</strong>，当前线程执行轻量级锁状态下的锁获取步骤----该状态达到阈值40则执行批量撤销</li></ol><h4 id="轻量级锁：">轻量级锁：</h4><p><strong>轻量级锁的获取：</strong></p><ol><li>进行加锁操作时，jvm会判断是否已经是 <code>重量级锁</code>，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中</li><li>复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’</li><li>更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态</li><li>更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘4’</li><li>表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。</li><li>表示该锁对象已经被其他线程抢占，则进行<strong>自旋等待</strong>（默认10次），等待次数达到阈值仍未获取到锁，则<strong>升级为重量级锁</strong></li></ol><p>大体上省简的升级过程：</p><p><img src="https://s2.loli.net/2023/03/29/A2GBsaXScdwUekP.png" alt="锁升级简略过程"></p><p>完整的升级过程：</p><p><img src="https://s2.loli.net/2023/03/29/QvlJxtUCGYw21cL.png" alt="synchronized 锁升级过程-来源参考[14]"></p><h3 id="28-说说synchronized和ReentrantLock的区别？">28.说说synchronized和ReentrantLock的区别？</h3><p>可以从锁的实现、功能特点、性能等几个维度去回答这个问题：</p><ul><li><strong>锁的实现：</strong> synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成）</li><li><strong>性能：</strong> 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</li><li><strong>功能特点：</strong> ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。<ul><li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li><li>synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。</li><li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li></ul></li></ul><p>下面的表格列出了两种锁之间的区别：</p><p><img src="https://s2.loli.net/2023/03/29/LwcQPm2vV5YFZGk.png" alt="synchronized和ReentrantLock的区别"></p><h3 id="29-AQS了解多少？">29.AQS了解多少？</h3><p>AbstractQueuedSynchronizer 抽象同步队列，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><ul><li>AQS是基于一个FIFO的双向队列，其内部定义了一个节点类Node，Node 节点内部的 SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE 用来标记线程是 <strong>取独占资源时被挂起后放入AQS队列</strong></li><li>AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</li><li>获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。</li><li>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。</li></ul><p><img src="https://s2.loli.net/2023/03/29/lHCecK9p5v8XBmE.png" alt="AQS抽象队列同步器"></p><p><img src="https://s2.loli.net/2023/03/29/kKIeWZxXpntDSgq.png" alt="CLH队列"></p><p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：</p><p><img src="https://s2.loli.net/2023/03/29/s356yEtzva7brXO.png" alt="AQS变种CLH队列"></p><p>AQS 中的 CLH 变体等待队列拥有以下特性：</p><ul><li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li><li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li><li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li><li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li></ul><p>ps:AQS源码里面有很多细节可问，建议有时间好好看看AQS源码。</p><h3 id="30-ReentrantLock实现原理？">30.<strong>ReentrantLock</strong>实现原理？</h3><p>ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p><p>看看ReentrantLock的加锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建非公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 获取锁操作</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行代码逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 解锁操作</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new ReentrantLock() </code>构造函数默认创建的是非公平锁 NonfairSync。</p><p><strong>公平锁 FairSync</strong></p><ol><li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</li><li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大</li></ol><p><strong>非公平锁 NonfairSync</strong></p><ul><li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</li><li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li></ul><p>默认创建的对象lock()的时候：</p><ul><li>如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为1 ，然后直接返回。如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加1后返回。</li><li>如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法线程会被放入 AQS 队列阻塞挂起。</li></ul><p><img src="https://s2.loli.net/2023/03/29/HkOWbjDiTfnzr8s.png" alt="ReentrantLock 非公平锁加锁流程简图"></p><h3 id="31-ReentrantLock怎么实现公平锁的？">31.ReentrantLock怎么实现公平锁的？</h3><p><code>new ReentrantLock() </code>构造函数默认创建的是非公平锁 NonfairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">--- ReentrantLock</span><br><span class="line"><span class="comment">// true 代表公平锁，false 代表非公平锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。</p><p><strong>非公平锁和公平锁的两处不同：</strong></p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><p><img src="https://s2.loli.net/2023/03/29/SpBEd4qUt7xrjeG.png" alt="公平锁tryAcquire"></p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h3 id="32-CAS呢？CAS了解多少？">32.CAS呢？CAS了解多少？</h3><p>CAS叫做CompareAndSwap，⽐较并交换，主要是通过处理器的指令来保证操作的原⼦性的。</p><p>CAS 指令包含 3 个参数：共享变量的内存地址 A、预期的值 B 和共享变量的新值 C。</p><p>只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条 CPU 指令，CAS 指令本身是能够保证原子性的 。</p><h3 id="33-CAS-有什么问题？如何解决？">33.CAS 有什么问题？如何解决？</h3><p>CAS的经典三大问题：</p><p><img src="https://s2.loli.net/2023/03/29/wQtN6X5kcrWdhHv.png" alt="CAS三大问题"></p><h4 id="ABA-问题">ABA 问题</h4><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p><blockquote><p>怎么解决ABA问题？加版本号</p></blockquote><p>每次修改变量，都在这个变量的版本号上加1，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种时效性的检验。</p><p>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p><h4 id="循环性能开销">循环性能开销</h4><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p><blockquote><p>怎么解决循环性能开销问题？</p></blockquote><p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p><h4 id="只能保证一个变量的原子操作">只能保证一个变量的原子操作</h4><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p><blockquote><p>怎么解决只能保证一个变量的原子操作问题？</p></blockquote><ul><li>可以考虑改用锁来保证操作的原子性</li><li>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。</li></ul><h3 id="34-Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？">34.Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h3><p><img src="https://s2.loli.net/2023/03/29/3M8T2uFopDSfQgt.png" alt="Java保证原子性方法"></p><ul><li>使用循环原子类，例如AtomicInteger，实现i++原子操作</li><li>使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性</li><li>使用synchronized，对i++操作加锁</li></ul><h3 id="35-原子操作类了解多少？">35.原子操作类了解多少？</h3><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i=1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于3，而是等于2。因为A和B线程在更新变量i的时候拿到的i都是1，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p><p>其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p><p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p><p><img src="https://s2.loli.net/2023/03/29/AhJWDfbudcNQyF4.png" alt="原子操作类"></p><p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类：</p><ul><li><p>AtomicBoolean：原子更新布尔类型。</p></li><li><p>AtomicInteger：原子更新整型。</p></li><li><p>AtomicLong：原子更新长整型。</p></li></ul><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下4个类：</p><ul><li><p>AtomicIntegerArray：原子更新整型数组里的元素。</p></li><li><p>AtomicLongArray：原子更新长整型数组里的元素。</p></li><li><p>AtomicReferenceArray：原子更新引用类型数组里的元素。</p></li><li><p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型</p></li></ul><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类：</p><ul><li><p>AtomicReference：原子更新引用类型。</p></li><li><p>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</p></li><li><p>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</p></li></ul><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新：</p><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的 ABA问题。</li></ul><h3 id="36-AtomicInteger-的原理？">36.AtomicInteger 的原理？</h3><p>一句话概括：<strong>使用CAS实现</strong>。</p><p>以AtomicInteger的添加方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Unsafe</code>类的实例来进行添加操作，来看看具体的CAS操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareAndSwapInt 是一个native方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。</p><h3 id="37-线程死锁了解吗？该如何避免？">37.线程死锁了解吗？该如何避免？</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。</p><p><img src="https://s2.loli.net/2023/03/29/l2NYiWx1rC8hXPV.png" alt="死锁示意图"></p><p>那么为什么会产生死锁呢？ 死锁的产生必须具备以下四个条件：</p><p><img src="https://s2.loli.net/2023/03/29/UIc1dxeWOV6nGAY.png" alt="死锁产生必备四条件"></p><ul><li>互斥条件：指线程对己经获取到的资源进行它性使用，即该资源同时只由一个线程占用。如果此时还有其它线程请求获取获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。</li><li>请求并持有条件：指一个 线程己经持有了至少一个资源，但又提出了新的资源请求，而新资源己被其它线程占有，所以当前线程会被阻塞，但阻塞 的同时并不释放自己已经获取的资源。</li><li>不可剥夺条件：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后才由自己释放该资源。</li><li>环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合 {T0，T1，T2,…… ，Tn} 中 T0 正在等待一 T1 占用的资源，Tl1正在等待 T2用的资源，…… Tn 在等待己被 T0占用的资源。</li></ul><p>该如何避免死锁呢？答案是<strong>至少破坏死锁发生的一个条件</strong>。</p><ul><li><p>其中，互斥这个条件我们没有办法破坏，因为用锁为的就是互斥。不过其他三个条件都是有办法破坏掉的，到底如何做呢？</p></li><li><p>对于“请求并持有”这个条件，可以一次性请求所有的资源。</p></li><li><p>对于“不可剥夺”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</p></li><li><p>对于“环路等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后就不存在环路了。</p></li></ul><h3 id="38-那死锁问题怎么排查呢？">38.那死锁问题怎么排查呢？</h3><p>可以使用jdk自带的命令行工具排查：</p><ol><li>使用jps查找运行的Java进程：jps -l</li><li>使用jstack查看线程堆栈信息：jstack -l  进程id</li></ol><p>基本就可以看到死锁的信息。</p><p>还可以利用图形化工具，比如JConsole。出现线程死锁以后，点击JConsole线程面板的<code>检测到死锁</code>按钮，将会看到线程的死锁信息。</p><p><img src="https://s2.loli.net/2023/03/29/osgxMz1SY5Q8iJy.png" alt="线程死锁检测"></p><h2 id="并发工具类">并发工具类</h2><h3 id="39-CountDownLatch（倒计数器）了解吗？">39.CountDownLatch（倒计数器）了解吗？</h3><p>CountDownLatch，倒计数器，有两个常见的应用场景[18]：</p><p><strong>场景1：协调子线程结束动作：等待所有子线程运行结束</strong></p><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p><p>例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。</p><p><img src="https://s2.loli.net/2023/03/29/dKPGmS1yz687QwE.jpg" alt="王者荣耀等待玩家确认-来源参考[18]"></p><p>CountDownLatch模仿这个场景(参考[18])：</p><p>创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。</p><p>在这段代码中，<code>new CountDownLatch(5)</code>用户创建初始的latch数量，各玩家通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 兰陵王 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 安其拉 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 哪吒 = <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatch::countDown);</span><br><span class="line">    Thread 铠 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 稍等，上个卫生间，马上到...</span></span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;所有玩家已经就位！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>场景2. 协调子线程开始动作：统一各线程动作开始的时机</strong></p><p>王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。</p><p>所以大家得一块出生，在</p><p><img src="https://s2.loli.net/2023/03/29/YbcfVLznkJFqRvp.jpg" alt="王者荣耀-来源参考[18]"></p><p>在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了<code>start()</code>线程，但是它们在运行时都在等待<code>countDownLatch</code>的信号，在信号未收到前，它们不会往下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Thread 大乔 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 兰陵王 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 安其拉 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 哪吒 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line">    Thread 铠 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; waitToFight(countDownLatch));</span><br><span class="line"></span><br><span class="line">    大乔.start();</span><br><span class="line">    兰陵王.start();</span><br><span class="line">    安其拉.start();</span><br><span class="line">    哪吒.start();</span><br><span class="line">    铠.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">    System.out.println(<span class="string">&quot;敌方还有5秒达到战场，全军出击！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">waitToFight</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await(); <span class="comment">// 在此等待信号再继续</span></span><br><span class="line">        System.out.println(<span class="string">&quot;收到，发起进攻！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch的<strong>核心方法</strong>也不多：</p><ul><li><code>await()</code>：等待latch降为0；</li><li><code>boolean await(long timeout, TimeUnit unit)</code>：等待latch降为0，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。</li><li><code>countDown()</code>：latch数量减1；</li><li><code>getCount()</code>：获取当前的latch数量。</li></ul><h3 id="40-CyclicBarrier（同步屏障）了解吗？">40.CyclicBarrier（同步屏障）了解吗？</h3><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>它和CountDownLatch类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有CyclicBarrier，自然是它有和CountDownLatch不同的地方。</p><p>不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨——“想结衣结衣不依,迷爱理爱理不理。”我们来还原一下事情的经过：小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。</p><p><img src="https://s2.loli.net/2023/03/29/i8cglbSTXAMKBan.png" alt="想结衣结衣不依,迷爱理爱理不理。"></p><p>我们拿代码模拟这一场景，发现CountDownLatch无能为力了，因为CountDownLatch的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用CyclicBarrier就可以实现，因为它可以重复利用。</p><p><img src="https://s2.loli.net/2023/03/29/eELPaOx36kr87BR.png" alt="小约翰可汗选妃模拟代码"></p><p>运行结果：</p><p><img src="https://s2.loli.net/2023/03/29/VCQgGA3xie4OS6P.png" alt="运行结果"></p><p>CyclicBarrier最最核心的方法，仍然是await()：</p><ul><li>如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生<strong>被中断</strong>、<strong>屏障被拆除</strong>、<strong>屏障被重设</strong>等情况；</li></ul><p>上面的例子抽象一下，本质上它的流程就是这样就是这样：</p><p><img src="https://s2.loli.net/2023/03/29/J7mMqeNrWFoX5Qg.png" alt="CyclicBarrier工作流程"></p><h3 id="41-CyclicBarrier和CountDownLatch有什么区别？">41.CyclicBarrier和CountDownLatch有什么区别？</h3><p>两者最核心的区别[18]：</p><ul><li>CountDownLatch是一次性的，而CyclicBarrier则可以多次设置屏障，实现重复利用；</li><li>CountDownLatch中的各个子线程不可以等待其他线程，只能完成自己的任务；而CyclicBarrier中的各个线程可以等待其他线程</li></ul><p>它们区别用一个表格整理：</p><table><thead><tr><th>CyclicBarrier</th><th>CountDownLatch</th></tr></thead><tbody><tr><td>CyclicBarrier是可重用的，其中的线程会等待所有的线程完成任务。届时，屏障将被拆除，并可以选择性地做一些特定的动作。</td><td>CountDownLatch是一次性的，不同的线程在同一个计数器上工作，直到计数器为0.</td></tr><tr><td>CyclicBarrier面向的是线程数</td><td>CountDownLatch面向的是任务数</td></tr><tr><td>在使用CyclicBarrier时，你必须在构造中指定参与协作的线程数，这些线程必须调用await()方法</td><td>使用CountDownLatch时，则必须要指定任务数，至于这些任务由哪些线程完成无关紧要</td></tr><tr><td>CyclicBarrier可以在所有的线程释放后重新使用</td><td>CountDownLatch在计数器为0时不能再使用</td></tr><tr><td>在CyclicBarrier中，如果某个线程遇到了中断、超时等问题时，则处于await的线程都会出现问题</td><td>在CountDownLatch中，如果某个线程出现问题，其他线程不受影响</td></tr></tbody></table><h3 id="42-Semaphore（信号量）了解吗？">42.Semaphore（信号量）了解吗？</h3><p><code>Semaphore</code>（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车 。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入；如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿，显示空车位数量，等待的车辆就能进停车场。</p><p><img src="https://s2.loli.net/2023/03/29/hHbt8GSligsCpUQ.jpg" alt="停车场空闲车位提示-图片来源网络"></p><p>我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，Semaphore的本质就是<strong>协调多个线程对共享资源的获取</strong>。</p><p><img src="https://s2.loli.net/2023/03/29/cKwH9vijJz3bMZE.jpg" alt="Semaphore许可获取-来源参考[18]"></p><p>我们再来看一个<code>Semaphore</code>的用途：它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。</p><p>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREAD_COUNT</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();</span><br><span class="line">                        System.out.println(<span class="string">&quot;save data&quot;</span>);</span><br><span class="line">                        s.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。Semaphore的构造方法<code> Semaphore（int permits</code>）接受一个整型的数字，表示可用的许可证数量。<code>Semaphore（10）</code>表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。</p><h3 id="43-Exchanger-了解吗？">43.Exchanger 了解吗？</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p><p><img src="https://s2.loli.net/2023/03/29/5zfJTiWUVbFQBmv.jpg" alt="英雄交换猎物-来源参考[18]"></p><p>这两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">&quot;银行流水A&quot;</span>; <span class="comment">// A录入银行流水数据 </span></span><br><span class="line">                    exgr.exchange(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">&quot;银行流水B&quot;</span>; <span class="comment">// B录入银行流水数据 </span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> exgr.exchange(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;A和B数据是否一致：&quot;</span> + A.equals(B) + <span class="string">&quot;，A录入的是：&quot;</span></span><br><span class="line">                            + A + <span class="string">&quot;，B录入是：&quot;</span> + B);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeOut, TimeUnit unit) </code>设置最大等待时长。</p><h2 id="线程池">线程池</h2><h3 id="44-什么是线程池？">44.什么是线程池？</h3><p><strong>线程池：</strong> 简单理解，它就是一个管理线程的池子。</p><p><img src="https://s2.loli.net/2023/03/29/ujRN2YFAILsfX1o.png" alt="管理线程的池子"></p><ul><li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li><li><strong>提高响应速度。</strong> 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li><li><strong>重复利用。</strong> 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li></ul><h3 id="45-能说说工作中线程池的应用吗？">45.能说说工作中线程池的应用吗？</h3><p>之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。</p><p><img src="https://s2.loli.net/2023/03/29/VmfSGTKsjQ4Hwhy.png" alt="业务示例"></p><p>主要代码如下：</p><p><img src="https://s2.loli.net/2023/03/29/uQPCX7bL8gDG1VH.png" alt="主要代码"></p><p>完整可运行代码地址：<a href="https://gitee.com/fighter3/thread-demo.git">https://gitee.com/fighter3/thread-demo.git</a></p><p>线程池的参数如下：</p><ul><li><p>corePoolSize：线程核心参数选择了CPU数×2</p></li><li><p>maximumPoolSize：最大线程数选择了和核心线程数相同</p></li><li><p>keepAliveTime：非核心闲置线程存活时间直接置为0</p></li><li><p>unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒</p></li><li><p>workQueue：线程池等待队列，使用 LinkedBlockingQueue阻塞队列</p></li></ul><p>同时还用了synchronized 来加锁，保证数据不会被重复推送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (PushProcessServiceImpl.class) &#123;&#125;</span><br></pre></td></tr></table></figure><p>ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。</p><h3 id="46-能简单说一下线程池的工作流程吗？">46.能简单说一下线程池的工作流程吗？</h3><p>用一个通俗的比喻：</p><p>有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。</p><p>老三去办业务，可能会遇到什么情况呢？</p><ol><li>老三发现有空间的在营业的窗口，直接去找小姐姐办理业务。</li></ol><p><img src="https://s2.loli.net/2023/03/29/NC3FRriEu842TVo.png" alt="直接办理"></p><ol start="2"><li>老三发现没有空闲的窗口，就在排队区排队等。</li></ol><p><img src="https://s2.loli.net/2023/03/29/kUMQ6yOorFwN5Id.png" alt="排队等待"></p><ol start="3"><li>老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。</li></ol><p><img src="https://s2.loli.net/2023/03/29/j6ukqDE3IfwMsGL.png" alt="排队区满"></p><ol start="4"><li>老三一看，六个窗口都满了，等待区也没位置了。老三急了，要闹，经理赶紧出来了，经理该怎么办呢？</li></ol><p><img src="https://s2.loli.net/2023/03/29/t5as1nASefPkgiQ.png" alt="等待区，排队区都满"></p><blockquote><ol><li><p>我们银行系统已经瘫痪</p></li><li><p>谁叫你来办的你找谁去</p></li><li><p>看你比较急，去队里加个塞</p></li><li><p>今天没办法，不行你看改一天</p></li></ol></blockquote><p>上面的这个流程几乎就跟 JDK 线程池的大致流程类似，</p><blockquote><ol><li>营业中的 3个窗口对应核心线程池数：corePoolSize</li><li>总的营业窗口数6对应：maximumPoolSize</li><li>打开的临时窗口在多少时间内无人办理则关闭对应窗口：unit</li><li>排队区就是等待队列：workQueue</li><li>无法办理的时候银行给出的解决方法对应：RejectedExecutionHandler</li><li>threadFactory 该参数在 JDK 中是 线程工厂，用来创建线程对象，一般不会动。</li></ol></blockquote><p>所以我们线程池的工作流程也比较好理解了：</p><ol><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</li><li>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</li></ol><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。</li></ul><p><img src="https://s2.loli.net/2023/03/29/Dn1KWNlgwqYVJxz.png" alt="线程池执行流程"></p><ol start="3"><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p></li><li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p></li></ol><h3 id="47-线程池主要参数有哪些？">47.线程池主要参数有哪些？</h3><p><img src="https://s2.loli.net/2023/03/29/FH2iVvlp4PxDJzy.png" alt="线程池参数"></p><p>线程池有七大参数，需要重点关注<code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>、<code>handler</code>这四个。</p><ol><li>corePoolSize</li></ol><p>此值是用来初始化线程池中核心线程数，当线程池中线程池数&lt; <code>corePoolSize</code>时，系统默认是添加一个任务才创建一个线程池。当线程数 = corePoolSize时，新任务会追加到workQueue中。</p><ol start="2"><li>maximumPoolSize</li></ol><p><code>maximumPoolSize</code>表示允许的最大线程数 = (非核心线程数+核心线程数)，当<code>BlockingQueue</code>也满了，但线程池中总线程数 &lt; <code>maximumPoolSize</code>时候就会再次创建新的线程。</p><ol start="3"><li>keepAliveTime</li></ol><p>非核心线程 =(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。</p><ol start="4"><li>unit</li></ol><p>线程池中非核心线程保持存活的时间的单位</p><ul><li>TimeUnit.DAYS;天</li><li>TimeUnit.HOURS;小时</li><li>TimeUnit.MINUTES;分钟</li><li>TimeUnit.SECONDS;秒</li><li>TimeUnit.MILLISECONDS;  毫秒</li><li>TimeUnit.MICROSECONDS;  微秒</li><li>TimeUnit.NANOSECONDS;  纳秒</li></ul><ol start="5"><li>workQueue</li></ol><p>线程池等待队列，维护着等待执行的<code>Runnable</code>对象。当运行当线程数= corePoolSize时，新的任务会被添加到<code>workQueue</code>中，如果<code>workQueue</code>也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。</p><ol start="6"><li>threadFactory</li></ol><p>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。</p><ol start="7"><li>handler</li></ol><p><code>corePoolSize</code>、<code>workQueue</code>、<code>maximumPoolSize</code>都不可用的时候执行的饱和策略。</p><h3 id="48-线程池的拒绝策略有哪些？">48.线程池的拒绝策略有哪些？</h3><p>类比前面的例子，无法办理业务时的处理方式，帮助记忆：</p><p><img src="https://s2.loli.net/2023/03/29/ls45IoyUCFiDxXb.png" alt="四种策略"></p><ul><li>AbortPolicy ：直接抛出异常，默认使用此策略</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy：丢弃阻塞队列里最老的任务，也就是队列里靠前的任务</li><li>DiscardPolicy ：当前任务直接丢弃</li></ul><p>想实现自己的拒绝策略，实现RejectedExecutionHandler接口即可。</p><h3 id="49-线程池有哪几种工作队列？">49.线程池有哪几种工作队列？</h3><p>常用的阻塞队列主要有以下几种：</p><p><img src="https://s2.loli.net/2023/03/29/8ldfLXvFt1YKTVG.png" alt="线程池常用阻塞队列"></p><ul><li>ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</li><li>LinkedBlockingQueue：LinkedBlockingQueue（可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</li><li>DelayQueue：DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</li><li>PriorityBlockingQueue：PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列</li><li>SynchronousQueue：SynchronousQueue（同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</li></ul><h3 id="50-线程池提交execute和submit有什么区别？">50.线程池提交execute和submit有什么区别？</h3><ol><li>execute 用于提交不需要返回值的任务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="type">Object</span> <span class="variable">s</span> <span class="operator">=</span> future.get(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">    <span class="comment">// 处理中断异常 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123; </span><br><span class="line">    <span class="comment">// 处理无法执行任务异常 </span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="comment">// 关闭线程池 executor.shutdown();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="51-线程池怎么关闭知道吗？">51.线程池怎么关闭知道吗？</h3><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p><strong>shutdown() 将线程池状态置为shutdown,并不会立即停止</strong>：</p><ol><li>停止接收外部submit的任务</li><li>内部正在跑的任务和队列里等待的任务，会执行完</li><li>等到第二步完成后，才真正停止</li></ol><p><strong>shutdownNow() 将线程池状态置为stop。一般会立即停止，事实上不一定</strong>：</p><ol><li>和shutdown()一样，先停止接收外部提交的任务</li><li>忽略队列里等待的任务</li><li>尝试将正在跑的任务interrupt中断</li><li>返回未执行的任务列表</li></ol><p>shutdown 和shutdownnow简单来说区别如下：</p><ul><li>shutdownNow()能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li><li>shutdown()只是关闭了提交通道，用submit()是无效的；而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</li></ul><h3 id="52-线程池的线程数应该怎么配置？">52.线程池的线程数应该怎么配置？</h3><p>线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。</p><ol><li>计算密集型：大部分都在用CPU跟内存，加密，逻辑操作业务处理等。</li><li>IO密集型：数据库链接，网络通讯传输等。</li></ol><p><img src="https://s2.loli.net/2023/03/29/PlbwSeJBm3hkLjC.png" alt="常见线程池参数配置方案-来源美团技术博客"></p><p>一般的经验，不同类型线程池的参数配置：</p><ol><li>计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在<strong>页缺失</strong>(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure><ol start="2"><li>IO密集型：线程数适当大一点，机器的Cpu核心数*2。</li><li>混合型：可以考虑根绝情况将它拆分成CPU密集型和IO密集型任务，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</li></ol><p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p><h3 id="53-有哪几种常见的线程池？">53.有哪几种常见的线程池？</h3><p>面试常问，主要有四种，都是通过工具类Excutors创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。</p><p><img src="https://s2.loli.net/2023/03/29/i3rpXsKt69WUoPx.png" alt="四大线程池"></p><ul><li><p>newFixedThreadPool  (固定数目线程的线程池)</p></li><li><p>newCachedThreadPool (可缓存线程的线程池)</p></li><li><p>newSingleThreadExecutor (单线程的线程池)</p></li><li><p>newScheduledThreadPool (定时及周期执行的线程池)</p></li></ul><h3 id="54-能说一下四种常见线程池的原理吗？">54.能说一下四种常见线程池的原理吗？</h3><p>前三种线程池的构造直接调用ThreadPoolExecutor的构造方法。</p><h4 id="newSingleThreadExecutor">newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>核心线程数为1</li><li>最大线程数也为1</li><li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li><li>keepAliveTime为0</li></ul><p><img src="https://s2.loli.net/2023/03/29/pwRDbXsVcG4Z5MH.png" alt="SingleThreadExecutor运行流程"></p><p>工作流程：</p><ul><li>提交任务</li><li>线程池是否有一条线程在，如果没有，新建线程执行任务</li><li>如果有，将任务加到阻塞队列</li><li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</li></ul><p><strong>适用场景</strong></p><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p><h4 id="newFixedThreadPool">newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数和最大线程数大小一样</li><li>没有所谓的非空闲时间，即keepAliveTime为0</li><li>阻塞队列为无界队列LinkedBlockingQueue，可能会导致OOM</li></ul><p><img src="https://s2.loli.net/2023/03/29/qtvzpxbcDYSlFwZ.png" alt="FixedThreadPool"></p><p>工作流程：</p><ul><li>提交任务</li><li>如果线程数少于核心线程，创建核心线程执行任务</li><li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li><li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li></ul><p><strong>使用场景</strong></p><p>FixedThreadPool 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p><h4 id="newCachedThreadPool">newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点：</strong></p><ul><li>核心线程数为0</li><li>最大线程数为Integer.MAX_VALUE，即无限大，可能会因为无限创建线程，导致OOM</li><li>阻塞队列是SynchronousQueue</li><li>非核心线程空闲存活时间为60秒</li></ul><p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。</p><p><img src="https://s2.loli.net/2023/03/29/9GoPCfeAFMu1NJX.png" alt="CachedThreadPool执行流程"></p><p>工作流程：</p><ul><li>提交任务</li><li>因为没有核心线程，所以任务直接加到SynchronousQueue队列。</li><li>判断是否有空闲线程，如果有，就去取出任务执行。</li><li>如果没有空闲线程，就新建一个线程执行。</li><li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li></ul><p><strong>适用场景</strong></p><p>用于并发执行大量短期的小任务。</p><h4 id="newScheduledThreadPool">newScheduledThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程池特点</strong></p><ul><li>最大线程数为Integer.MAX_VALUE，也有OOM的风险</li><li>阻塞队列是DelayedWorkQueue</li><li>keepAliveTime为0</li><li>scheduleAtFixedRate() ：按某种速率周期执行</li><li>scheduleWithFixedDelay()：在某个延迟后执行</li></ul><p><img src="https://s2.loli.net/2023/03/29/AMRiUXFOjbwfZSQ.png" alt="ScheduledThreadPool执行流程"></p><p><strong>工作机制</strong></p><ul><li>线程从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前时间。</li><li>线程执行这个ScheduledFutureTask。</li><li>线程修改ScheduledFutureTask的time变量为下次将要被执行的时间。</li><li>线程把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add()）。</li></ul><p><img src="https://s2.loli.net/2023/03/29/x6VCbJaqQR5XyZn.png" alt="ScheduledThreadPoolExecutor执行流程"></p><p><strong>使用场景</strong></p><p>周期性执行任务的场景，需要限制线程数量的场景</p><blockquote><p>使用无界队列的线程池会导致什么问题吗？</p></blockquote><p>例如newFixedThreadPool使用了无界的阻塞队列LinkedBlockingQueue，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致OOM。</p><h3 id="55-线程池异常怎么处理知道吗？">55.线程池异常怎么处理知道吗？</h3><p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p><p>常见的异常处理方式：</p><p><img src="https://s2.loli.net/2023/03/29/57erTs8vNZFba2z.png" alt="线程池异常处理"></p><h3 id="56-能说一下线程池有几种状态吗？">56.能说一下线程池有几种状态吗？</h3><p>线程池有这几个状态：RUNNING,SHUTDOWN,STOP,TIDYING,TERMINATED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>线程池各个状态切换图：</p><p><img src="https://s2.loli.net/2023/03/29/mL3XZcRsbipNh1a.png" alt="线程池状态切换图"></p><p><strong>RUNNING</strong></p><ul><li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li><li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li><li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li></ul><p><strong>SHUTDOWN</strong></p><ul><li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li>队列为空，并且线程池中执行的任务也为空,进入TIDYING状态;</li></ul><p><strong>STOP</strong></p><ul><li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；</li><li>线程池中执行的任务为空,进入TIDYING状态;</li></ul><p><strong>TIDYING</strong></p><ul><li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li><li>terminated()执行完毕，进入TERMINATED状态</li></ul><p><strong>TERMINATED</strong></p><ul><li>该状态表示线程池彻底终止</li></ul><h3 id="57-线程池如何实现参数的动态修改？">57.线程池如何实现参数的动态修改？</h3><p>线程池提供了几个  setter方法来设置线程池的参数。</p><p><img src="https://s2.loli.net/2023/03/29/GOiN1ltXTP9wSmv.png" alt="JDK 线程池参数设置接口来源参考[7]"></p><p>这里主要有两个思路：</p><p><img src="https://s2.loli.net/2023/03/29/TPBZz2fXg3nvGU4.png" alt="动态修改线程池参数"></p><ul><li><p>在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。</p></li><li><p>如果限制了配置中心的使用，也可以自己去扩展<strong>ThreadPoolExecutor</strong>，重写方法，监听线程池参数变化，来动态修改线程池参数。</p></li></ul><h3 id="线程池调优了解吗？">线程池调优了解吗？</h3><p>线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下：</p><p><img src="https://s2.loli.net/2023/03/29/PlbwSeJBm3hkLjC.png" alt="线程池评估方案 来源参考[7]"></p><p>上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。</p><p>事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。</p><p>事后要注意仔细观察，随时调整。</p><p><img src="https://s2.loli.net/2023/03/29/pho91R8AIdiOGuP.png" alt="线程池调优"></p><p>具体的调优案例可以查看参考[7]美团技术博客。</p><h3 id="58-你能设计实现一个线程池吗？">58.你能设计实现一个线程池吗？</h3><p>⭐这道题在阿里的面试中出现频率比较高</p><p>线程池实现原理可以查看 <a href="https://mp.weixin.qq.com/s/Exy7pRGND9TCjRd9TZK4jg">要是以前有人这么讲线程池，我早就该明白了！</a>  ，当然，我们自己实现， 只需要抓住线程池的核心流程-参考[6]：</p><p><img src="https://s2.loli.net/2023/03/29/HWOJUI6McZNFbd8.png" alt="线程池主要实现流程"></p><p>我们自己的实现就是完成这个核心流程：</p><ul><li>线程池中有N个工作线程</li><li>把任务提交给线程池运行</li><li>如果线程池已满，把任务放入队列</li><li>最后当有空闲时，获取队列中任务来执行</li></ul><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录线程池中线程数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 核心线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, BlockingQueue workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//如果小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="built_in">this</span>.corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//添加任务失败</span></span><br><span class="line">            <span class="keyword">if</span> (!addWorker(command)) &#123;</span><br><span class="line">                <span class="comment">//执行饱和拒绝策略</span></span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//往任务队列添加任务</span></span><br><span class="line">        <span class="comment">//offer() 方法是一种非阻塞的插入方法，如果队列已满，则返回 false，表示插入失败</span></span><br><span class="line">        <span class="keyword">if</span> (!workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">//添加任务失败</span></span><br><span class="line">            <span class="keyword">if</span> (!addWorker(command)) &#123;</span><br><span class="line">                <span class="comment">//执行饱和拒绝策略</span></span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 饱和拒绝策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Cannot execute command. ctl size is &quot;</span> + ctl.get() + <span class="string">&quot;. workQueue size is &quot;</span> + workQueue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="built_in">this</span>.maximumPoolSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(command);</span><br><span class="line">        worker.thread.start();</span><br><span class="line">        ctl.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable firstTask)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行传入的Runnable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.firstTask;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    <span class="comment">//如果线程池已满，跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (ctl.get() &gt; maximumPoolSize) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//跳出循环后线程数减一</span></span><br><span class="line">                ctl.decrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从阻塞队列中获取任务</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;workQueue size is &quot;</span> + workQueue.size());</span><br><span class="line">                    <span class="keyword">return</span> workQueue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个实现了线程池主要流程的类就完成了。</p><h3 id="59-单机线程池执行断电了应该怎么处理？">59.单机线程池执行断电了应该怎么处理？</h3><p><br>我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销<code>正在处理</code>的已经执行成功的操作。然后重新执行整个阻塞队列。</p><p>也就是说，对阻塞队列持久化；正在处理任务事务控制；断电之后正在处理任务的回滚，通过日志恢复该次操作；服务器重启后阻塞队列中的数据再加载。</p><h2 id="并发容器和框架">并发容器和框架</h2><p>关于一些并发容器，可以去看看 <a href="https://mp.weixin.qq.com/s/SHkQ7LEOT0itt4bXMoDBPw">面渣逆袭：Java集合连环三十问  </a>，里面有<code>CopyOnWriteList</code>和<code>ConcurrentHashMap</code>这两种线程安全容器类的问答。。</p><h3 id="60-Fork-Join框架了解吗？">60.Fork/Join框架了解吗？</h3><p>Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p>要想掌握Fork/Join框架，首先需要理解两个点，<strong>分而治之</strong>和<strong>工作窃取算法</strong>。</p><p><strong>分而治之</strong></p><p>Fork/Join框架的定义，其实就体现了分治思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p><p><img src="https://s2.loli.net/2023/03/29/e3SdVs9KbY8zvQO.png" alt="Fork/Join分治算法"></p><p><strong>工作窃取算法</strong></p><p>大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。</p><p>那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的<strong>工作窃取</strong>。</p><p>工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p><img src="https://s2.loli.net/2023/03/29/yLmqikv3c8jZnuK.png" alt="工作窃取"></p><p>看一个Fork/Join框架应用的例子，计算1~n之间的和：1+2+3+…+n</p><ul><li>设置一个分割阈值，任务大于阈值就拆分任务</li><li>任务有结果，所以需要继承RecursiveTask</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">16</span>; <span class="comment">// 阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果任务足够小就计算任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">canCompute</span> <span class="operator">=</span> (end - start) &lt;= THRESHOLD;</span><br><span class="line">        <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(start, middle);</span><br><span class="line">            <span class="type">CountTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">// 执行子任务</span></span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork(); <span class="comment">// 等待子任务执行完，并得到其结果</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.join(); <span class="comment">// 合并子任务</span></span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(); <span class="comment">// 生成一个计算任务，负责计算1+2+3+4</span></span><br><span class="line">        <span class="type">CountTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountTask</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 执行一个任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForkJoinTask与一般Task的主要区别在于它需要实现compute方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用fork方法时，又会进compute方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识(修正版)</title>
      <link href="/posts/f34a924e.html"/>
      <url>/posts/f34a924e.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java-概述">Java 概述</h2><h3 id="1-什么是-Java？">1.什么是 Java？</h3><p><img src="https://s2.loli.net/2023/03/30/8UblSAir6X4ORMK.png" alt="下辈子还学Java"></p><p>PS：碎怂 Java，有啥好介绍的。哦，面试啊。</p><p>Java 是一门面向对象的编程语言，不仅吸收了 C++语言的各种优点，还摒弃了 C++里难以理解的多继承、指针等概念，因此 Java 语言具有功能强大和简单易用两个特征。Java 语言作为静态面向对象编程语言的优秀代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</p><h3 id="2-Java-语言有哪些特点？">2.Java 语言有哪些特点？</h3><p>Java 语言有很多优秀（可吹）的特点，以下几个是比较突出的：</p><p><img src="https://s2.loli.net/2023/03/30/OdIHUwFBfpiLsTW.png" alt="Java语言特点"></p><ul><li>面向对象（封装，继承，多态）；</li><li>平台无关性，平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。</li><li>支持多线程。C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持；</li><li>编译与解释并存；</li></ul><h3 id="3-JVM、JDK-和-JRE-有什么区别？">3.JVM、JDK 和 JRE 有什么区别？</h3><p><strong>JVM</strong>：Java Virtual Machine，Java 虚拟机，Java 程序运行在 Java 虚拟机上。针对不同系统的实现（Windows，Linux，macOS）不同的 JVM，因此 Java 语言可以实现跨平台。</p><p><strong>JRE</strong>： Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p><p><strong>JDK</strong>: Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p><p><img src="https://s2.loli.net/2023/03/30/tXsoTiegArY6xS1.png" alt="JDK、JRE、JVM关系"></p><h3 id="4-说说什么是跨平台性？原理是什么">4.说说什么是跨平台性？原理是什么</h3><p>所谓跨平台性，是指 Java 语言编写的程序，一次编译后，可以在多个系统平台上运行。</p><p>实现原理：Java 程序是通过 Java 虚拟机在系统平台上运行的，只要该系统可以安装相应的 Java 虚拟机，该系统就可以运行 java 程序。</p><h3 id="5-什么是字节码？采用字节码的好处是什么">5.什么是字节码？采用字节码的好处是什么?</h3><p>所谓的字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p><img src="https://s2.loli.net/2023/03/30/epFz4MgwdJNKuOP.png" alt="Java程序执行过程"></p><p>只需要把 Java 程序编译成 Java 虚拟机能识别的 Java 字节码，不同的平台安装对应的 Java 虚拟机，这样就可以可以实现 Java 语言的平台无关性。</p><h3 id="6-为什么说-Java-语言“编译与解释并存”？">6.为什么说 Java 语言“编译与解释并存”？</h3><p>高级编程语言按照程序的执行方式分为<strong>编译型</strong>和<strong>解释型</strong>两种。</p><p>简单来说，编译型语言是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码；解释型语言是指解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p>比如，你想读一本外国的小说，你可以找一个翻译人员帮助你翻译，有两种选择方式，你可以先等翻译人员将全本的小说（也就是源码）都翻译成汉语，再去阅读，也可以让翻译人员翻译一段，你在旁边阅读一段，慢慢把书读完。</p><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须再经过 JVM，解释成操作系统能识别的机器码，在由操作系统执行。因此，我们可以认为 Java 语言<strong>编译</strong>与<strong>解释</strong>并存。</p><p><img src="https://s2.loli.net/2023/03/30/rCsZVEiyH8LgJFM.png" alt="编译与解释"></p><h2 id="基础语法">基础语法</h2><h3 id="7-Java-有哪些数据类型？">7.Java 有哪些数据类型？</h3><p><b>定义：</b>Java 语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><p>Java 语言数据类型分为两种：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p><img src="https://s2.loli.net/2023/03/30/iDM28nVWU73CqSY.png" alt="Java数据类型"></p><p><b>基本数据类型：</b></p><ul><li>数值型<ul><li>整数类型（byte、short、int、long）</li><li>浮点类型（float、double）</li></ul></li><li>字符型（char）</li><li>布尔型（boolean）</li></ul><p>Java 基本数据类型范围和默认值：</p><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td></tr><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>‘u0000’</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td></tr><tr><td><code>boolean</code></td><td>1</td><td></td><td>false</td></tr></tbody></table><p><strong>引用数据类型：</strong></p><ul><li>类（class）</li><li>接口（interface）</li><li>数组([])</li></ul><h3 id="8-自动类型转换、强制类型转换？看看这几行代码？">8.自动类型转换、强制类型转换？看看这几行代码？</h3><p>Java 所有的数值型变量可以相互转换，当把一个表数范围小的数值或变量直接赋给另一个表数范围大的变量时，可以进行自动类型转换；反之，需要强制转换。</p><p><img src="https://s2.loli.net/2023/03/30/azf85HZLogSICVw.png" alt="Java自动类型转换方向"></p><p>这就好像，小杯里的水倒进大杯没问题，但大杯的水倒进小杯就不行了，可能会溢出。</p><blockquote><p><code>float f=3.4</code>，对吗？</p></blockquote><p>不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换<code>float f =(float)3.4;</code>或者写成<code>float f =3.4F</code></p><blockquote><p><code>short s1 = 1; s1 = s1 + 1；</code>对吗？<code>short s1 = 1; s1 += 1;</code>对吗？</p></blockquote><p>对于 short s1 = 1; s1 = s1 + 1;编译出错，由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。</p><p>而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p><h3 id="9-什么是自动拆箱-封箱？">9.什么是自动拆箱/封箱？</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>Java 可以自动对基本数据类型和它们的包装类进行装箱和拆箱。</p><p><img src="https://s2.loli.net/2023/03/30/OfqJ527gAXiYzNZ.png" alt="装箱和拆箱"></p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="10-和-有什么区别？">10.&amp;和&amp;&amp;有什么区别？</h3><p>&amp;运算符有两种用法：<code>短路与</code>、<code>逻辑与</code>。</p><p>&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才是 true。</p><p>&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;。</p><p>例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为<code>username != null &amp;&amp;!username.equals(&quot;&quot;)</code>，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。</p><p><strong>注意</strong>：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><h3 id="11-switch-是否能作用在-byte-long-String-上？">11.switch 是否能作用在 byte/long/String 上？</h3><p>Java5 以前 switch(expr)中，expr 只能是 byte、short、char、int。</p><p>从 Java 5 开始，Java 中引入了枚举类型， expr 也可以是 enum 类型。</p><p>从 Java 7 开始，expr 还可以是字符串(String)，但是长整型(long)在目前所有的版本中都是不可以的。</p><h3 id="12-break-continue-return-的区别及作用？">12.break ,continue ,return 的区别及作用？</h3><ul><li>break 跳出整个循环，不再执行循环(<strong>结束当前的循环体</strong>)</li><li>continue 跳出本次循环，继续执行下次循环(<strong>结束正在执行的循环 进入下一个循环条件</strong>)</li><li>return 程序返回，不再执行下面的代码(<strong>结束当前的方法 直接返回</strong>)</li></ul><p><img src="https://s2.loli.net/2023/03/30/JqiMy9UAg85kD23.png" alt="break 、continue 、return"></p><h3 id="13-用最有效率的方法计算-2-乘以-8？">13.用最有效率的方法计算 2 乘以 8？</h3><p>2 &lt;&lt; 3。<strong>位运算</strong>，数字的二进制位左移三位相当于乘以 2 的三次方。</p><h3 id="14-说说自增自减运算？看下这几个代码运行结果？">14.说说自增自减运算？看下这几个代码运行结果？</h3><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p><p>++和–运算符可以放在变量之前，也可以放在变量之后。</p><p>当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。</p><p>例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。</p><p>用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。</p><blockquote><p>看一下这段代码运行结果？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i = i++;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><p>答案是 1。有点离谱对不对。</p><p>对于 JVM 而言，它对自增运算的处理，是会先定义一个临时变量来接收 i 的值，然后进行自增运算，最后又将临时变量赋给了值为 2 的 i，所以最后的结果为 1。</p><p>相当于这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">i++；</span><br><span class="line">i = temp;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码会输出什么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    count = count++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;count = &quot;</span>+count);</span><br></pre></td></tr></table></figure><p>答案是 0。</p><p>和上面的题目一样的道理，同样是用了临时变量，count 实际是等于临时变量的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">autoAdd</span><span class="params">(<span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> count;</span><br><span class="line">    count = coutn + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：笔试面试可能会碰到的奇葩题，开发这么写，见一次吊一次。</p><h2 id="面向对象">面向对象</h2><h3 id="15-⾯向对象和⾯向过程的区别">15.⾯向对象和⾯向过程的区别?</h3><ul><li><strong>⾯向过程</strong> ：面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的一次调用就可以。</li><li><strong>⾯向对象</strong> ：面向对象，把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事件在解决整个问题的过程所发生的行为。 目的是为了写出通用的代码，加强代码的重用，屏蔽差异性。</li></ul><p>用一个比喻：面向过程是编年体；面向对象是纪传体。</p><p><img src="https://s2.loli.net/2023/03/30/rw2xyGdEJSfcZOA.png" alt="面向对象和面向过程的区别"></p><h3 id="16-面向对象有哪些特性">16.面向对象有哪些特性</h3><p><img src="https://s2.loli.net/2023/03/30/laXzLBk4VSPKA3b.png" alt="面向对象三大特征"></p><ul><li><p><b>封装</b></p><p>封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法。</p></li><li><p><b>继承</b></p><p>继承是使⽤已存在的类的定义作为基础创建新的类，新类的定义可以增加新的属性或新的方法，也可以继承父类的属性和方法。通过继承可以很方便地进行代码复用。</p></li></ul><blockquote><p>关于继承有以下三个要点：</p></blockquote><ol><li><p>⼦类拥有⽗类对象所有的属性和⽅法（包括私有属性和私有⽅法），但是⽗类中的私有属性和⽅法⼦类是⽆法访问，只是拥有。</p></li><li><p>⼦类可以拥有⾃⼰属性和⽅法，即⼦类可以对⽗类进⾏扩展。</p></li><li><p>⼦类可以⽤⾃⼰的⽅式实现⽗类的⽅法。</p></li></ol><ul><li><p><b>多态</b></p><p>所谓多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）。</p></li></ul><h3 id="17-重载（overload）和重写（override）的区别？">17.重载（overload）和重写（override）的区别？</h3><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><ul><li><p>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</p></li><li><p>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</p></li></ul><p>方法重载的规则：</p><ol><li>方法名一致，参数列表中参数的顺序，类型，个数不同。</li><li>重载与方法的返回值无关，存在于父类和子类，同类中。</li><li>可以抛出不同的异常，可以有不同修饰符。</li></ol><h3 id="18-访问修饰符-public、private、protected、以及不写（默认）时的区别？">18.访问修饰符 public、private、protected、以及不写（默认）时的区别？</h3><p>Java 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p><ul><li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li><li><strong>private</strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong>public</strong> : 对所有类可见。可以修饰类、接口、变量、方法</li><li><strong>protected</strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul><p><img src="https://s2.loli.net/2023/03/30/XTYr4dtCOmbgH7L.png" alt="访问修饰符和可见性"></p><h3 id="19-this-关键字有什么作用？">19.this 关键字有什么作用？</h3><p>this 是自身的一个对象，代表对象本身，可以理解为：<strong>指向对象本身的一个指针</strong>。</p><p>this 的用法在 Java 中大体可以分为 3 种：</p><ol><li><p>普通的直接引用，this 相当于是指向当前对象本身</p></li><li><p>形参与成员变量名字重名，用 this 来区分：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>引用本类的构造函数</li></ol><h3 id="20-抽象类-abstract-class-和接口-interface-有什么区别？">20.抽象类(abstract class)和接口(interface)有什么区别？</h3><ol><li><p>接⼝的⽅法默认是 public ，所有⽅法在接⼝中不能有实现(Java 8 开始接⼝⽅法可以有默认实现），⽽抽象类可以有⾮抽象的⽅法。</p></li><li><p>接⼝中除了 static 、 final 变量，不能有其他变量，⽽抽象类中则不⼀定。</p></li><li><p>⼀个类可以实现多个接⼝，但只能实现⼀个抽象类。接⼝⾃⼰本身可以通过 extends 关键字扩展多个接⼝。</p></li><li><p>接⼝⽅法默认修饰符是 public ，抽象⽅法可以有 public 、 protected 和 default 这些修饰符（抽象⽅法就是为了被重写所以不能使⽤ private 关键字修饰！）。</p></li><li><p>从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的规范。</p></li></ol><blockquote><ol><li><p>在 JDK8 中，接⼝也可以定义静态⽅法，可以直接⽤接⼝名调⽤。实现类和实现是不可以调⽤的。如果同时实现两个接⼝，接⼝中定义了⼀样的默认⽅法，则必须重写，不然会报错。</p></li><li><p>jdk9 的接⼝被允许定义私有⽅法 。</p></li></ol></blockquote><p>总结⼀下 jdk7~jdk9 Java 中接⼝的变化：</p><ol><li><p>在 jdk 7 或更早版本中，接⼝⾥⾯只能有常量变量和抽象⽅法。这些接⼝⽅法必须由选择实现接⼝的类实现。</p></li><li><p>jdk 8 的时候接⼝可以有默认⽅法和静态⽅法功能。</p></li><li><p>jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法。</p></li></ol><h3 id="21-成员变量与局部变量的区别有哪些？">21.成员变量与局部变量的区别有哪些？</h3><ol><li><p><strong>从语法形式上看</strong>：成员变量是属于类的，⽽局部变量是在⽅法中定义的变量或是⽅法的参数；成员变量可以被 public , private , static 等修饰符所修饰，⽽局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</p></li><li><p><strong>从变量在内存中的存储⽅式来看</strong>：如果成员变量是使⽤ static 修饰的，那么这个成员变量是属于类的，如果没有使⽤ static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引⽤数据类型，那存放的是指向堆内存对象的引⽤或者是指向常量池中的地址。</p></li><li><p><strong>从变量在内存中的⽣存时间上看</strong>：成员变量是对象的⼀部分，它随着对象的创建⽽存在，⽽局部变量随着⽅法的调⽤⽽⾃动消失。</p></li><li><p><strong>成员变量如果没有被赋初值</strong>：则会⾃动以类型的默认值⽽赋值（⼀种情况例外:被 final 修饰的成员变量也必须显式地赋值），⽽局部变量则不会⾃动赋值。</p></li></ol><h3 id="22-静态变量和实例变量的区别？静态方法、实例方法呢？">22.静态变量和实例变量的区别？静态方法、实例方法呢？</h3><blockquote><p>静态变量和实例变量的区别？</p></blockquote><p><strong>静态变量:</strong> 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个副本。</p><p><strong>实例变量:</strong> 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。</p><blockquote><p>静态⽅法和实例⽅法有何不同?</p></blockquote><p>类似地。</p><p><strong>静态方法</strong>：static 修饰的方法，也被称为类方法。在外部调⽤静态⽅法时，可以使⽤&quot;<strong>类名.⽅法名</strong>&quot;的⽅式，也可以使⽤&quot;<strong>对象名.⽅法名</strong>&quot;的⽅式。静态方法里不能访问类的非静态成员变量和方法。</p><p><strong>实例⽅法</strong>：依存于类的实例，需要使用&quot;<strong>对象名.⽅法名</strong>&quot;的⽅式调用；可以访问类的所有成员变量和方法。</p><h3 id="24-final-关键字有什么作用？">24.final 关键字有什么作用？</h3><p>final 表示不可变的意思，可用于修饰类、属性和方法：</p><ul><li><p>被 final 修饰的类不可以被继承</p></li><li><p>被 final 修饰的方法不可以被重写</p></li><li><p>被 final 修饰的变量不可变，被 final 修饰的变量必须被显式第指定初始值，还得注意的是，这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变。</p><p>例如：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">System.out.println(sb);  <span class="comment">//abcd</span></span><br></pre></td></tr></table></figure><p>一张图说明：</p><p><img src="https://s2.loli.net/2023/03/30/ACHQL7FBqhiXsIT.png" alt="final修饰变量"></p><h3 id="25-final、finally、finalize-的区别？">25.final、finally、finalize 的区别？</h3><ul><li><p>final 用于修饰变量、方法和类：final 修饰的类不可被继承；修饰的方法不可被重写；修饰的变量不可变。</p></li><li><p>finally 作为异常处理的一部分，它只能在 <code>try/catch</code> 语句中，并且附带一个语句块表示这段语句最终一定被执行（无论是否抛出异常），经常被用在需要释放资源的情况下，<code>System.exit (0)</code> 可以阻断 finally 执行。</p></li><li><p>finalize 是在 <code>java.lang.Object</code> 里定义的方法，也就是说每一个对象都有这么个方法，这个方法在 <code>gc</code> 启动，该对象被回收的时候被调用。</p><p>一个对象的 finalize 方法只会被调用一次，finalize 被调用不一定会立即回收该对象，所以有可能调用 finalize 后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会再次调用 finalize 了，进而产生问题，因此不推荐使用 finalize 方法。</p></li></ul><h3 id="26-和-equals-的区别？">26.==和 equals 的区别？</h3><p><strong>==</strong> : 它的作⽤是判断两个对象的地址是不是相等。即，判断两个对象是不是同⼀个对象(基本数据类型 <strong>==</strong> 比较的是值，引⽤数据类型 <strong>==</strong> 比较的是内存地址)。</p><p><strong>equals()</strong> : 它的作⽤也是判断两个对象是否相等。但是这个“相等”一般也分两种情况：</p><ul><li><p>默认情况：类没有覆盖 equals() ⽅法。则通过 equals() 比较该类的两个对象时，等价于通过“ <strong>==</strong> ”比较这两个对象，还是相当于比较内存地址。</p></li><li><p>自定义情况：类覆盖了 equals() ⽅法。我们平时覆盖的 equals()方法一般是比较两个对象的内容是否相同，自定义了一个相等的标准，也就是两个对象的值是否相等。</p></li></ul><p>举个例⼦，Person，我们认为两个人的编号和姓名相同，就是一个人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(no, person.no) &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(no, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="27-hashCode-与-equals">27.hashCode 与 equals?</h3><p>这个也是面试常问——“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode ⽅法？”</p><blockquote><p>什么是 HashCode？</p></blockquote><p>hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个 int 整数，定义在 Object 类中， 是一个本地⽅法，这个⽅法通常⽤来将对象的内存地址转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>哈希码主要在哈希表这类集合映射的时候用到，哈希表存储的是键值对(key-value)，它的特点是：能根据“键”快速的映射到对应的“值”。这其中就利⽤到了哈希码！</p><blockquote><p>为什么要有 hashCode？</p></blockquote><p>上面已经讲了，主要是在哈希表这种结构中用的到。</p><p>例如 HashMap 怎么把 key 映射到对应的 value 上呢？用的就是哈希取余法，也就是拿哈希码和存储元素的数组的长度取余，获取 key 对应的 value 所在的下标位置。</p><blockquote><p>为什么重写 quals 时必须重写 hashCode ⽅法？</p></blockquote><p>如果两个对象相等，则 hashcode ⼀定也是相同的。两个对象相等，对两个对象分别调⽤ equals ⽅法都返回 true。反之，两个对象有相同的 hashcode 值，它们也不⼀定是相等的 。因此，<strong>equals</strong> ⽅法被覆盖过，则 <strong>hashCode</strong> ⽅法也必须被覆盖。</p><p>hashCode() 的默认⾏为是对堆上的对象产⽣独特值。如果没有重写 hashCode() ，则该 class 的两个对象⽆论如何都不会相等（即使这两个对象指向相同的数据）</p><blockquote><p>为什么两个对象有相同的 hashcode 值，它们也不⼀定是相等的？</p></blockquote><p>因为可能会<strong>碰撞</strong>， hashCode() 所使⽤的散列算法也许刚好会让多个对象传回相同的散列值。越糟糕的散列算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode ）。</p><h3 id="28-Java-是值传递，还是引用传递？">28.Java 是值传递，还是引用传递？</h3><p>Java 语言是<strong>值传递</strong>。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。</p><p>JVM 的内存分为堆和栈，其中栈中存储了基本数据类型和引用数据类型实例的地址，也就是对象地址。</p><p>而对象所占的空间是在堆中开辟的，所以传递的时候可以理解为把变量存储的对象地址给传递过去，因此引用类型也是值传递。</p><p><img src="https://s2.loli.net/2023/03/30/P8zcMaxXEgSmUyw.png" alt="Java引用数据值传递示意图"></p><h3 id="29-深拷贝和浅拷贝">29.深拷贝和浅拷贝?</h3><ul><li><strong>浅拷贝</strong>：仅拷贝被拷贝对象的成员变量的值，也就是基本数据类型变量的值，和引用数据类型变量的地址值，而对于引用类型变量指向的堆中的对象不会拷贝。</li><li><strong>深拷贝</strong>：完全拷贝一个对象，拷贝被拷贝对象的成员变量的值，堆中的对象也会拷贝一份。</li></ul><p>例如现在有一个 order 对象，里面有一个 products 列表，它的浅拷贝和深拷贝的示意图：</p><p><img src="https://s2.loli.net/2023/03/30/nFZHKcSh4uBDfrU.png" alt="浅拷贝和深拷贝示意图"></p><p>因此深拷贝是安全的，浅拷贝的话如果有引用类型，那么拷贝后对象，引用类型变量修改，会影响原对象。</p><blockquote><p>浅拷贝如何实现呢？</p></blockquote><p>Object 类提供的 clone()方法可以非常简单地实现对象的浅拷贝。</p><blockquote><p>深拷贝如何实现呢？</p></blockquote><ul><li>重写克隆方法：重写克隆方法，引用类型变量单独克隆，这里可能会涉及多层递归。</li><li>序列化：可以先将原对象序列化，再反序列化成拷贝对象。</li></ul><h3 id="30-Java-创建对象有哪几种方式？">30.Java 创建对象有哪几种方式？</h3><p>Java 中有以下四种创建对象的方式:</p><p><img src="https://s2.loli.net/2023/03/30/CjTom86xZba2PQK.png" alt="Java创建对象的四种方式"></p><ul><li>new 创建新对象</li><li>通过反射机制</li><li>采用 clone 机制</li><li>通过序列化机制</li></ul><p>前两者都需要显式地调用构造方法。对于 clone 机制,需要注意浅拷贝和深拷贝的区别，对于序列化机制需要明确其实现原理，在 Java 中序列化可以通过实现 Externalizable 或者 Serializable 来实现。</p><p>最近整理了一份牛逼的学习资料，包括但不限于Java基础部分（JVM、Java集合框架、多线程），还囊括了 <strong>数据库、计算机网络、算法与数据结构、设计模式、框架类Spring、Netty、微服务（Dubbo，消息队列） 网关</strong> 等等等等……详情戳：<a href="https://tobebetterjavaer.com/pdf/programmer-111.html">可以说是2022年全网最全的学习和找工作的PDF资源了</a></p><p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>111</strong> 即可免费领取。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt=""></p><h2 id="String">String</h2><h3 id="31-String-是-Java-基本数据类型吗？可以被继承吗？">31.String 是 Java 基本数据类型吗？可以被继承吗？</h3><blockquote><p>String 是 Java 基本数据类型吗？</p></blockquote><p>不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type）。</p><p>String 是一个比较特殊的引用数据类型。</p><blockquote><p>String 类可以继承吗？</p></blockquote><p>不行。String 类使用 final 修饰，是所谓的不可变类，无法被继承。</p><h3 id="32-String-和-StringBuilder、StringBuffer-的区别？">32.String 和 StringBuilder、StringBuffer 的区别？</h3><ul><li>String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。</li><li>StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。</li><li>StringBuilder：StringBuffer 的非线程安全版本，性能上更高一些。</li></ul><h3 id="33-String-str1-new-String-“abc”-和-String-str2-“abc”-和-区别？">33.String str1 = new String(“abc”)和 String str2 = “abc” 和 区别？</h3><p>两个语句都会去字符串常量池中检查是否已经存在 “abc”，如果有则直接使用，如果没有则会在常量池中创建 “abc” 对象。</p><p><img src="https://s2.loli.net/2023/03/30/QszoyVvJLurimG1.png" alt="堆与常量池中的String"></p><p>但是不同的是，String str1 = new String(“abc”) 还会通过 new String() 在堆里创建一个 “abc” 字符串对象实例。所以后者可以理解为被前者包含。</p><blockquote><p>String s = new String(“abc”)创建了几个对象？</p></blockquote><p>很明显，一个或两个。如果字符串常量池已经有“abc”，则是一个；否则，两个。</p><p>当字符创常量池没有 “abc”，此时会创建如下两个对象：</p><ul><li>一个是字符串字面量 “abc” 所对应的、字符串常量池中的实例</li><li>另一个是通过 new String() 创建并初始化的，内容与&quot;abc&quot;相同的实例，在堆中。</li></ul><h3 id="34-String-不是不可变类吗？字符串拼接是如何实现的？">34.String 不是不可变类吗？字符串拼接是如何实现的？</h3><p>String 的确是不可变的，“<strong>+</strong>”的拼接操作，其实是会生成新的对象。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure><p>在<strong>jdk1.8 之前</strong>，a 和 b 初始化时位于字符串常量池，ab 拼接后的对象位于堆中。经过拼接新生成了 String 对象。如果拼接多次，那么会生成多个中间对象。</p><p>内存如下：</p><p><img src="https://s2.loli.net/2023/03/30/MVWYgJw4ivdrfe8.png" alt="jdk1.8之前的字符串拼接"></p><p>在<strong>Java8 时</strong>JDK 对“+”号拼接进行了优化，上面所写的拼接方式会被优化为基于 StringBuilder 的 append 方法进行处理。Java 会在编译期对“+”号进行处理。</p><p>下面是通过 javap -verbose 命令反编译字节码的结果，很显然可以看到 StringBuilder 的创建和 append 方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">     <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String hello</span></span><br><span class="line">     <span class="number">2</span>: astore_1</span><br><span class="line">     <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String world!</span></span><br><span class="line">     <span class="number">5</span>: astore_2</span><br><span class="line">     <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">     <span class="number">9</span>: dup</span><br><span class="line">    <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    <span class="number">13</span>: aload_1</span><br><span class="line">    <span class="number">14</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    <span class="number">17</span>: aload_2</span><br><span class="line">    <span class="number">18</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    <span class="number">21</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">    <span class="number">24</span>: astore_3</span><br><span class="line">    <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是说其实上面的代码其实相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(a);</span><br><span class="line">sb.append(b);</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><p>此时，如果再笼统的回答：通过加号拼接字符串会创建多个 String 对象，因此性能比 StringBuilder 差，就是错误的了。因为本质上加号拼接的效果最终经过编译器处理之后和 StringBuilder 是一致的。</p><p>当然，循环里拼接还是建议用 StringBuilder，为什么，因为循环一次就会创建一个新的 StringBuilder 对象，大家可以自行实验。</p><h3 id="35-intern-方法有什么作用？">35.intern 方法有什么作用？</h3><p>JDK 源码里已经对这个方法进行了说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;</span><br><span class="line">* When the intern method is invoked, <span class="keyword">if</span> the pool already contains a</span><br><span class="line">* string equal to <span class="built_in">this</span> &#123;<span class="meta">@code</span> String&#125; object as determined by</span><br><span class="line">* the &#123;<span class="meta">@link</span> #equals(Object)&#125; method, then the string from the pool is</span><br><span class="line">* returned. Otherwise, <span class="built_in">this</span> &#123;<span class="meta">@code</span> String&#125; object is added to the</span><br><span class="line">* pool and a reference to <span class="built_in">this</span> &#123;<span class="meta">@code</span> String&#125; object is returned.</span><br><span class="line">* &lt;p&gt;</span><br></pre></td></tr></table></figure><p>意思也很好懂：</p><ul><li>如果当前字符串内容存在于字符串常量池（即 equals()方法为 true，也就是内容一样），直接返回字符串常量池中的字符串</li><li>否则，将此 String 对象添加到池中，并返回 String 对象的引用</li></ul><p>最近整理了一份牛逼的学习资料，包括但不限于Java基础部分（JVM、Java集合框架、多线程），还囊括了 <strong>数据库、计算机网络、算法与数据结构、设计模式、框架类Spring、Netty、微服务（Dubbo，消息队列） 网关</strong> 等等等等……详情戳：<a href="https://tobebetterjavaer.com/pdf/programmer-111.html">可以说是2022年全网最全的学习和找工作的PDF资源了</a></p><p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>111</strong> 即可免费领取。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt=""></p><h2 id="Integer">Integer</h2><h3 id="36-Integer-a-127，Integer-b-127；Integer-c-128，Integer-d-128；，相等吗">36.Integer a= 127，Integer b = 127；Integer c= 128，Integer d = 128；，相等吗?</h3><p>答案是 a 和 b 相等，c 和 d 不相等。</p><ul><li>对于基本数据类型==比较的值</li><li>对于引用数据类型==比较的是地址</li></ul><p>Integer a= 127 这种赋值，是用到了 Integer 自动装箱的机制。自动装箱的时候会去缓存池里取 Integer 对象，没有取到才会创建新的对象。</p><p>如果整型字面量的值在-128 到 127 之间，那么自动装箱时不会 new 新的 Integer 对象，而是直接引用缓存池中的 Integer 对象，超过范围 a1==b1 的结果是 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">    System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">    System.out.println(b==b1);  <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(c == d);  <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>什么是 Integer 缓存？</p></blockquote><p>因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置<code>JVM-XX:AutoBoxCacheMax=</code>来修改缓存的最大值，最小值改不了。</p><p>实现的原理是 int 在自动装箱的时候会调用 Integer.valueOf，进而用到了 IntegerCache。</p><p><img src="https://s2.loli.net/2023/03/30/HkScqhjxDynVWTK.png" alt="Integer.valueOf"></p><p>很简单，就是判断下值是否在缓存范围之内，如果是的话去 IntegerCache 中取，不是的话就创建一个新的 Integer 对象。</p><p>IntegerCache 是一个静态内部类， 在静态块中会初始化好缓存值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="comment">//创建Integer对象存储</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">               cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">        ……</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="37-String-怎么转成-Integer-的？原理？">37.String 怎么转成 Integer 的？原理？</h3><p>PS:这道题印象中在一些面经中出场过几次。</p><p>String 转成 Integer，主要有两个方法：</p><ul><li>Integer.parseInt(String s)</li><li>Integer.valueOf(String s)</li></ul><p>不管哪一种，最终还是会调用 Integer 类内中的<code>parseInt(String s, int radix)</code>方法。</p><p>抛去一些边界之类的看看核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s, <span class="type">int</span> radix)</span></span><br><span class="line">                <span class="keyword">throws</span> NumberFormatException</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//是否是负数</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">negative</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//char字符数组下标和长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = s.length();</span><br><span class="line">        ……</span><br><span class="line">        <span class="type">int</span> digit;</span><br><span class="line">        <span class="comment">//判断字符长度是否大于0，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">                <span class="comment">//返回指定基数中字符表示的数值。（此处是十进制数值）</span></span><br><span class="line">                digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">                <span class="comment">//进制位乘以数值</span></span><br><span class="line">                result *= radix;</span><br><span class="line">                result -= digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据上面得到的是否负数，返回相应的值</span></span><br><span class="line">        <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>去掉枝枝蔓蔓（当然这些枝枝蔓蔓可以去看看，源码 cover 了很多情况），其实剩下的就是一个简单的字符串遍历计算，不过计算方式有点反常规，是用负的值累减。</p><p><img src="https://s2.loli.net/2023/03/30/rdCEagQXKqnZNRh.png" alt="parseInt示意图"></p><p>最近整理了一份牛逼的学习资料，包括但不限于Java基础部分（JVM、Java集合框架、多线程），还囊括了 <strong>数据库、计算机网络、算法与数据结构、设计模式、框架类Spring、Netty、微服务（Dubbo，消息队列） 网关</strong> 等等等等……详情戳：<a href="https://tobebetterjavaer.com/pdf/programmer-111.html">可以说是2022年全网最全的学习和找工作的PDF资源了</a></p><p>微信搜 <strong>沉默王二</strong> 或扫描下方二维码关注二哥的原创公众号沉默王二，回复 <strong>111</strong> 即可免费领取。</p><p><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/gongzhonghao.png" alt=""></p><h2 id="Object">Object</h2><h3 id="38-Object-类的常见方法">38.Object 类的常见方法?</h3><p>Object 类是一个特殊的类，是所有类的父类，也就是说所有类都可以调用它的方法。它主要提供了以下 11 个方法，大概可以分为六类：</p><p><img src="https://s2.loli.net/2023/03/30/UwmZMrQiCX27ytN.png" alt="Object类的方法"></p><p><strong>对象比较</strong>：</p><ul><li>public native int hashCode() ：native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的 HashMap。</li><li>public boolean equals(Object obj)：用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写用户比较字符串的值是否相等。</li></ul><p><strong>对象拷贝</strong>：</p><ul><li>protected native Object clone() throws CloneNotSupportedException：naitive 方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为 true，x.clone().getClass() == x.getClass() 为 true。Object 本身没有实现 Cloneable 接口，所以不重写 clone 方法并且进行调用的话会发生 CloneNotSupportedException 异常。</li></ul><p><strong>对象转字符串：</strong></p><ul><li>public String toString()：返回类的名字@实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</li></ul><p><strong>多线程调度：</strong></p><ul><li>public final native void notify()：native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</li><li>public final native void notifyAll()：native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</li><li>public final native void wait(long timeout) throws InterruptedException：native 方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 。timeout 是等待时间。</li><li>public final void wait(long timeout, int nanos) throws InterruptedException：多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。</li><li>public final void wait() throws InterruptedException：跟之前的 2 个 wait 方法一样，只不过该方法一直等待，没有超时时间这个概念</li></ul><p><strong>反射：</strong></p><ul><li>public final native Class&lt;?&gt; getClass()：native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</li></ul><p><strong>垃圾回收：</strong></p><ul><li>protected void finalize() throws Throwable ：通知垃圾收集器回收对象。</li></ul><h2 id="异常处理">异常处理</h2><h3 id="39-Java-中异常处理体系">39.Java 中异常处理体系?</h3><p>Java 的异常体系是分为多层的。</p><p><img src="https://s2.loli.net/2023/03/30/YydwuhcGikBlnrI.png" alt="Java异常体系"></p><p><code>Throwable</code>是 Java 语言中所有错误或异常的基类。 Throwable 又分为<code>Error</code>和<code>Exception</code>，其中 Error 是系统内部错误，比如虚拟机异常，是程序无法处理的。<code>Exception</code>是程序问题导致的异常，又分为两种：</p><ul><li>CheckedException 受检异常：编译器会强制检查并要求处理的异常。</li><li>RuntimeException 运行时异常：程序运行中出现异常，比如我们熟悉的空指针、数组下标越界等等</li></ul><h3 id="40-异常的处理方式？">40.异常的处理方式？</h3><p>针对异常的处理主要有两种方式：</p><p><img src="https://s2.loli.net/2023/03/30/cy1fGHrtvLqdBO3.png" alt="异常处理"></p><ul><li><strong>遇到异常不进行具体处理，而是继续抛给调用者 （throw，throws）</strong></li></ul><p>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。</p><p>throws 用在方法上，后面跟的是异常类，可以跟多个；而 throw 用在方法内，后面跟的是异常对象。</p><ul><li><strong>try catch 捕获异常</strong></li></ul><p>在 catch 语句块中补货发生的异常，并进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//包含可能会出现异常的代码以及声明异常的方法</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">     <span class="comment">//捕获异常并进行处理</span></span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123;                                                       &#125;</span><br><span class="line">     <span class="comment">//可选，必执行的代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>try-catch 捕获异常的时候还可以选择加上 finally 语句块，finally 语句块不管程序是否正常执行，最终它都会必然执行。</p><h3 id="41-三道经典异常处理代码题">41.三道经典异常处理代码题</h3><blockquote><p>题目 1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：31。</p><p>try、catch。finally 的基础用法，在 return 前会先执行 finally 语句块，所以是先输出 finally 里的 3，再输出 return 的 1。</p><blockquote><p>题目 2</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test1());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：3。</p><p>try 返回前先执行 finally，结果 finally 里不按套路出牌，直接 return 了，自然也就走不到 try 里面的 return 了。</p><p>finally 里面使用 return 仅存在于面试题中，实际开发这么写要挨吊的。</p><blockquote><p>题目 3</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test1());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：2。</p><p>大家可能会以为结果应该是 3，因为在 return 前会执行 finally，而 i 在 finally 中被修改为 3 了，那最终返回 i 不是应该为 3 吗？</p><p>但其实，在执行 finally 之前，JVM 会先将 i 的结果暂存起来，然后 finally 执行完毕后，会返回之前暂存的结果，而不是返回 i，所以即使 i 已经被修改为 3，最终返回的还是之前暂存起来的结果 2。</p><h2 id="I-O">I/O</h2><h3 id="42-Java-中-IO-流分为几种">42.Java 中 IO 流分为几种?</h3><p>流按照不同的特点，有很多种划分方式。</p><ul><li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li><li>按照操作单元划分，可以划分为<strong>字节流</strong>和<strong>字符流</strong>；</li><li>按照流的角色划分为<strong>节点流</strong>和<strong>处理流</strong></li></ul><p>Java Io 流共涉及 40 多个类，看上去杂乱，其实都存在一定的关联， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><strong>InputStream</strong>/<strong>Reader</strong>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><strong>OutputStream</strong>/<strong>Writer</strong>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><img src="https://s2.loli.net/2023/03/30/IZPteLpOGozHSjf.jpg" alt="IO-操作方式分类-图片来源参考[2]"></p><blockquote><p>IO 流用到了什么设计模式？</p></blockquote><p>其实，Java 的 IO 流体系还用到了一个设计模式——<strong>装饰器模式</strong>。</p><p>InputStream 相关的部分类图如下，篇幅有限，装饰器模式就不展开说了。</p><p><img src="https://s2.loli.net/2023/03/30/iYbgUHFAs3OIoQD.png" alt="Java IO流用到装饰器模式"></p><h3 id="43-既然有了字节流-为什么还要有字符流">43.既然有了字节流,为什么还要有字符流?</h3><p>其实字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还比较耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。</p><p>所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h3 id="44-BIO、NIO、AIO？">44.BIO、NIO、AIO？</h3><p><img src="https://s2.loli.net/2023/03/30/elN2aoiGEhdjBbW.png" alt="BIO、NIO、AIO"></p><p><strong>BIO</strong>(blocking I/O) ： 就是传统的 IO，同步阻塞，服务器实现模式为一个连接一个线程，即<strong>客户端有连接请求时服务器端就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销，可以通过连接池机制改善(实现多个客户连接服务器)。</p><p><img src="https://s2.loli.net/2023/03/30/Bru4RcSYW5pLkAj.png" alt="BIO、NIO、AIO"></p><p>BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。</p><p><strong>NIO</strong> ：全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)。</p><p>NIO 是<strong>同步非阻塞</strong>的，服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有 IO 请求就进行处理：</p><p><img src="https://s2.loli.net/2023/03/30/rUoxpAX94dOnRMa.png" alt="NIO线程"></p><p>NIO 的数据是面向<strong>缓冲区 Buffer</strong>的，必须从 Buffer 中读取或写入。</p><p>所以完整的 NIO 示意图：</p><p><img src="https://s2.loli.net/2023/03/30/hP8TSG51rpMQxsJ.png" alt="NIO完整示意图"></p><p>可以看出，NIO 的运行机制：</p><ul><li>每个 Channel 对应一个 Buffer。</li><li>Selector 对应一个线程，一个线程对应多个 Channel。</li><li>Selector 会根据不同的事件，在各个通道上切换。</li><li>Buffer 是内存块，底层是数据。</li></ul><p><strong>AIO</strong>：JDK 7 引入了 Asynchronous I/O，是<strong>异步不阻塞</strong>的 IO。在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h2 id="序列化">序列化</h2><h3 id="45-什么是序列化？什么是反序列化？">45.什么是序列化？什么是反序列化？</h3><p>什么是序列化，序列化就是<strong>把 Java 对象转为二进制流</strong>，方便存储和传输。</p><p>所以<strong>反序列化就是把二进制流恢复成对象</strong>。</p><p><img src="https://s2.loli.net/2023/03/30/u21UI54JGbmyrdV.png" alt="序列化和反序列化"></p><p>类比我们生活中一些大件物品的运输，运输的时候把它拆了打包，用的时候再拆包组装。</p><blockquote><p>Serializable 接口有什么用？</p></blockquote><p>这个接口只是一个标记，没有具体的作用，但是如果不实现这个接口，在有些序列化场景会报错，所以一般建议，创建的 JavaBean 类都实现 Serializable。</p><blockquote><p>serialVersionUID 又有什么用？</p></blockquote><p>serialVersionUID 就是起验证作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure><p>我们经常会看到这样的代码，这个 ID 其实就是用来验证序列化的对象和反序列化对应的对象 ID 是否一致。</p><p>这个 ID 的数字其实不重要，无论是 1L 还是 IDE 自动生成的，只要序列化时候对象的 serialVersionUID 和反序列化时候对象的 serialVersionUID 一致的话就行。</p><p>如果没有显示指定 serialVersionUID ，则编译器会根据类的相关信息自动生成一个，可以认为是一个指纹。</p><p>所以如果你没有定义一个 serialVersionUID， 结果序列化一个对象之后，在反序列化之前把对象的类的结构改了，比如增加了一个成员变量，则此时的反序列化会失败。</p><p>因为类的结构变了，所以 serialVersionUID 就不一致。</p><blockquote><p>Java 序列化不包含静态变量？</p></blockquote><p>序列化的时候是不包含静态变量的。</p><blockquote><p>如果有些变量不想序列化，怎么办？</p></blockquote><p>对于不想进行序列化的变量，使用<code>transient</code>关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。<code>transient</code> 只能修饰变量，不能修饰类和方法。</p><h3 id="46-说说有几种序列化方式？">46.说说有几种序列化方式？</h3><p>Java 序列化方式有很多，常见的有三种：</p><p><img src="https://s2.loli.net/2023/03/30/bGuRYsFOgvwdB8k.png" alt="Java常见序列化方式"></p><ul><li>Java 对象序列化 ：Java 原生序列化方法即通过 Java 原生流(InputStream 和 OutputStream 之间的转化)的方式进行转化，一般是对象输出流 <code>ObjectOutputStream</code>和对象输入流<code>ObjectInputStream</code>。</li><li>Json 序列化：这个可能是我们最常用的序列化方式，Json 序列化的选择很多，一般会使用 jackson 包，通过 ObjectMapper 类来进行一些操作，比如将对象转化为 byte 数组或者将 json 串转化为对象。</li><li>ProtoBuff 序列化：ProtocolBuffer 是一种轻便高效的结构化数据存储格式，ProtoBuff 序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li></ul><h2 id="泛型">泛型</h2><h3 id="47-Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？">47.Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h3><blockquote><p>什么是泛型？</p></blockquote><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">12</span>);</span><br><span class="line"><span class="comment">//这里直接添加会报错</span></span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; clazz = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"><span class="comment">//但是通过反射添加，是可以的</span></span><br><span class="line">add.invoke(list, <span class="string">&quot;kl&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><img src="https://s2.loli.net/2023/03/30/mdQvKBcM4N6tGUp.png" alt="泛型类、泛型接口、泛型方法"></p><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure><blockquote><p>泛型常用的通配符有哪些？</p></blockquote><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><blockquote><p>什么是泛型擦除？</p></blockquote><p>所谓的泛型擦除，官方名叫“类型擦除”。</p><p>Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的类型信息都会被擦掉。</p><p>也就是说，在运行的时候是没有泛型的。</p><p>例如这段代码，往一群猫里放条狗：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Cat&gt; cats = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Cat&gt;();</span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;  <span class="comment">// 注意我在这里把范型去掉了，但是list和cats是同一个链表！</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());  <span class="comment">// 完全没问题！</span></span><br></pre></td></tr></table></figure><p>因为 Java 的范型只存在于源码里，编译的时候给你静态地检查一下范型类型是否正确，而到了运行时就不检查了。上面这段代码在 JRE（Java<strong>运行</strong>环境）看来和下面这段没区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">cats</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();  <span class="comment">// 注意：没有范型！</span></span><br><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> cats;</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br></pre></td></tr></table></figure><p>为什么要类型擦除呢？</p><p>主要是为了向下兼容，因为 JDK5 之前是没有泛型的，为了让 JVM 保持向下兼容，就出了类型擦除这个策略。</p><h2 id="注解">注解</h2><h3 id="48-说一下你对注解的理解？">48.说一下你对注解的理解？</h3><p><strong>Java 注解本质上是一个标记</strong>，可以理解成生活中的一个人的一些小装扮，比如戴什么什么帽子，戴什么眼镜。</p><p><img src="https://s2.loli.net/2023/03/30/qMki9FIU7H1TOgW.png" alt="Java注解和帽子"></p><p>注解可以标记在类上、方法上、属性上等，标记自身也可以设置一些值，比如帽子颜色是绿色。</p><p>有了标记之后，我们就可以在编译或者运行阶段去识别这些标记，然后搞一些事情，这就是注解的用处。</p><p>例如我们常见的 AOP，使用注解作为切点就是运行期注解的应用；比如 lombok，就是注解在编译期的运行。</p><p>注解生命周期有三大类，分别是：</p><ul><li>RetentionPolicy.SOURCE：给编译器用的，不会写入 class 文件</li><li>RetentionPolicy.CLASS：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了</li><li>RetentionPolicy.RUNTIME：会写入 class 文件，永久保存，可以通过反射获取注解信息</li></ul><p>所以我上文写的是解析的时候，没写具体是解析啥，因为不同的生命周期的解析动作是不同的。</p><p>像常见的：</p><p><img src="https://s2.loli.net/2023/03/30/KF1yXzo4pLCx6eG.png" alt="Override注解"></p><p>就是给编译器用的，编译器编译的时候检查没问题就 over 了，class 文件里面不会有 Override 这个标记。</p><p>再比如 Spring 常见的 Autowired ，就是 RUNTIME 的，所以<strong>在运行的时候可以通过反射得到注解的信息</strong>，还能拿到标记的值 required 。</p><p><img src="https://s2.loli.net/2023/03/30/vo2gMKGjUVny6fq.png" alt="Autowired注解"></p><h2 id="反射">反射</h2><h3 id="49-什么是反射？应用？原理？">49.什么是反射？应用？原理？</h3><blockquote><p>什么是反射？</p></blockquote><p>我们通常都是利用<code>new</code>方式来创建对象实例，这可以说就是一种“正射”，这种方式在编译时候就确定了类型信息。</p><p>而如果，我们想在时候动态地获取类信息、创建类实例、调用类方法这时候就要用到<strong>反射</strong>。</p><p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p><p>反射最核心的四个类：</p><p><img src="https://s2.loli.net/2023/03/30/G4PAaDEYitqQhFp.png" alt="Java反射相关类"></p><blockquote><p>反射的应用场景？</p></blockquote><p>一般我们平时都是在在写业务代码，很少会接触到直接使用反射机制的场景。</p><p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</p><p>像 Spring 里的很多 <strong>注解</strong> ，它真正的功能实现就是利用反射。</p><p>就像为什么我们使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为我们可以基于反射操作类，然后获取到类/属性/方法/方法的参数上的注解，注解这里就有两个作用，一是标记，我们对注解标记的类/属性/方法进行对应的处理；二是注解本身有一些信息，可以参与到处理的逻辑中。</p><blockquote><p>反射的原理？</p></blockquote><p>我们都知道 Java 程序的执行分为编译和运行两步，编译之后会生成字节码(.class)文件，JVM 进行类加载的时候，会加载字节码文件，将类型相关的所有信息加载进方法区，反射就是去获取这些信息，然后进行各种操作。</p><h2 id="JDK1-8-新特性">JDK1.8 新特性</h2><p>JDK 已经出到 17 了，但是你迭代你的版本，我用我的 8。JDK1.8 的一些新特性，当然现在也不新了，其实在工作中已经很常用了。</p><h3 id="50-JDK1-8-都有哪些新特性？">50.JDK1.8 都有哪些新特性？</h3><p>JDK1.8 有不少新特性，我们经常接触到的新特性如下：</p><p><img src="https://s2.loli.net/2023/03/30/jUIJPQsH4Wdz1rA.png" alt="JDK1.8主要新特性"></p><ul><li><p>接口默认方法：Java 8 允许我们给接口添加一个非抽象的方法实现，只需要使用 default 关键字修饰即可</p></li><li><p>Lambda 表达式和函数式接口：Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码。Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），使用 Lambda 表达式使代码更加简洁，但是也不要滥用，否则会有可读性等问题，《Effective Java》作者 Josh Bloch 建议使用 Lambda 表达式最好不要超过 3 行。</p></li><li><p>Stream API：用函数式编程方式在集合类上进行复杂操作的工具，配合 Lambda 表达式可以方便的对集合进行处理。</p><p>Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。</p><p>简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p></li><li><p>日期时间 API：Java 8 引入了新的日期时间 API 改进了日期时间的管理。</p></li><li><p>Optional 类：用来解决空指针异常的问题。很久以前 Google Guava 项目引入了 Optional 作为解决空指针异常的一种方式，不赞成代码被 null 检查的代码污染，期望程序员写整洁的代码。受 Google Guava 的鼓励，Optional 现在是 Java 8 库的一部分。</p></li></ul><h3 id="51-Lambda-表达式了解多少？">51.Lambda 表达式了解多少？</h3><p>Lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码。</p><p>比如我们以前使用 Runnable 创建并运行线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running before Java8!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>这是通过内部类的方式来重写 run 方法，使用 Lambda 表达式，还可以更加简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; System.out.println(<span class="string">&quot;Thread is running since Java8!&quot;</span>) ).start();</span><br></pre></td></tr></table></figure><p>当然不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Functional Interface）才能缩写成 Lambda 表示式。</p><p>所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。</p><blockquote><p>Java8 有哪些内置函数式接口？</p></blockquote><p>JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 <strong>Comparator</strong> 和 <strong>Runnable</strong>，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。</p><p>除了这两个之外，还有 Callable、Predicate、Function、Supplier、Consumer 等等。</p><h3 id="52-Optional-了解吗？">52.Optional 了解吗？</h3><p><code>Optional</code>是用于防范<code>NullPointerException</code>。</p><p>可以将 <code>Optional</code> 看做是包装对象（可能是 <code>null</code>, 也有可能非 <code>null</code>）的容器。当我们定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，我们就可以考虑用 <code>Optional</code> 来包装它，这也是在 Java 8 被推荐使用的做法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">&quot;bam&quot;</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();           <span class="comment">// true</span></span><br><span class="line">optional.get();                 <span class="comment">// &quot;bam&quot;</span></span><br><span class="line">optional.orElse(<span class="string">&quot;fallback&quot;</span>);    <span class="comment">// &quot;bam&quot;</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure><h3 id="53-Stream-流用过吗？">53.Stream 流用过吗？</h3><p><code>Stream</code> 流，简单来说，使用 <code>java.util.Stream</code> 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 <em>中间操作</em> 亦或是 <em>终端操作</em>。 终端操作会返回一个结果，而中间操作会返回一个 <code>Stream</code> 流。</p><p>Stream 流一般用于集合，我们对一个集合做几个常见操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringCollection.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>Filter 过滤</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa2&quot;, &quot;aaa1&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>Sorted 排序</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;aaa1&quot;, &quot;aaa2&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Map 转换</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Match 匹配</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">anyStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都是以 a 开头的</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">allStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证 list 中 string 是否都不是以 z 开头的,</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneStartsWithZ</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li><strong>Count 计数</strong></li></ul><p><code>count</code> 是一个终端操作，它能够统计 <code>stream</code> 流中的元素总数，返回值是 <code>long</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先对 list 中字符串开头为 b 进行过滤，让后统计数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">startsWithB</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">        .count();</span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><strong>Reduce</strong></li></ul><p><code>Reduce</code> 中文翻译为：<em>减少、缩小</em>。通过入参的 <code>Function</code>，我们能够将 <code>list</code> 归约成一个值。它的返回类型是 <code>Optional</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;</span></span><br></pre></td></tr></table></figure><p>以上是常见的几种流式操作，还有其它的一些流式操作，可以帮助我们更便捷地处理集合数据。</p><p><img src="https://s2.loli.net/2023/03/30/H5CpFuMArsXjKBw.png" alt="Java Stream流"></p>]]></content>
      
      
      <categories>
          
          <category> java面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试八股文 </tag>
            
            <tag> java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
